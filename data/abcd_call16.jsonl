{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Array","signature":"func Array(key string, val zapcore.ArrayMarshaler) Field","start_line":33,"end_line":35,"code":"func Array(key string, val zapcore.ArrayMarshaler) Field {\n\n\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n","neighbors":[{"path":"array.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Array constructs a field with the given key and ArrayMarshaler. It provides\n// a flexible, but still type-safe and efficient, way to add array-like types\n// to the logging context. The struct's MarshalLogArray method is called lazily."},{"path":"array.go","start_line":36,"end_line":55,"code":"\n// Bools constructs a field that carries a slice of bools.\nfunc Bools(key string, bs []bool) Field {\n\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"Bools","path":"array.go"},{"symbol":"ByteStrings","path":"array.go"},{"symbol":"Complex128s","path":"array.go"},{"symbol":"Complex64s","path":"array.go"},{"symbol":"Durations","path":"array.go"},{"symbol":"Errors","path":"array.go"},{"symbol":"Float32s","path":"array.go"},{"symbol":"Float64s","path":"array.go"},{"symbol":"Int16s","path":"array.go"},{"symbol":"Int32s","path":"array.go"},{"symbol":"Int64s","path":"array.go"},{"symbol":"Int8s","path":"array.go"},{"symbol":"Ints","path":"array.go"},{"symbol":"ObjectValues","path":"array.go"},{"symbol":"Objects","path":"array.go"},{"symbol":"Stringers","path":"array.go"},{"symbol":"Strings","path":"array.go"},{"symbol":"Times","path":"array.go"},{"symbol":"Uint16s","path":"array.go"},{"symbol":"Uint32s","path":"array.go"},{"symbol":"Uint64s","path":"array.go"},{"symbol":"Uint8s","path":"array.go"},{"symbol":"Uintptrs","path":"array.go"},{"symbol":"Uints","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Bools","signature":"func Bools(key string, bs []bool) Field","start_line":38,"end_line":40,"code":"func Bools(key string, bs []bool) Field {\n\n\treturn Array(key, bools(bs))\n}\n","neighbors":[{"path":"array.go","start_line":18,"end_line":37,"code":"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Array constructs a field with the given key and ArrayMarshaler. It provides\n// a flexible, but still type-safe and efficient, way to add array-like types\n// to the logging context. The struct's MarshalLogArray method is called lazily.\nfunc Array(key string, val zapcore.ArrayMarshaler) Field {\n\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n\n// Bools constructs a field that carries a slice of bools."},{"path":"array.go","start_line":41,"end_line":60,"code":"\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"ByteStrings","signature":"func ByteStrings(key string, bss [][]byte) Field","start_line":44,"end_line":46,"code":"func ByteStrings(key string, bss [][]byte) Field {\n\n\treturn Array(key, byteStringsArray(bss))\n}\n","neighbors":[{"path":"array.go","start_line":24,"end_line":43,"code":"\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Array constructs a field with the given key and ArrayMarshaler. It provides\n// a flexible, but still type-safe and efficient, way to add array-like types\n// to the logging context. The struct's MarshalLogArray method is called lazily.\nfunc Array(key string, val zapcore.ArrayMarshaler) Field {\n\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n\n// Bools constructs a field that carries a slice of bools.\nfunc Bools(key string, bs []bool) Field {\n\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text."},{"path":"array.go","start_line":47,"end_line":66,"code":"\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Complex128s","signature":"func Complex128s(key string, nums []complex128) Field","start_line":49,"end_line":51,"code":"func Complex128s(key string, nums []complex128) Field {\n\n\treturn Array(key, complex128s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":29,"end_line":48,"code":"\n// Array constructs a field with the given key and ArrayMarshaler. It provides\n// a flexible, but still type-safe and efficient, way to add array-like types\n// to the logging context. The struct's MarshalLogArray method is called lazily.\nfunc Array(key string, val zapcore.ArrayMarshaler) Field {\n\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n\n// Bools constructs a field that carries a slice of bools.\nfunc Bools(key string, bs []bool) Field {\n\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers."},{"path":"array.go","start_line":52,"end_line":71,"code":"\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Complex64s","signature":"func Complex64s(key string, nums []complex64) Field","start_line":54,"end_line":56,"code":"func Complex64s(key string, nums []complex64) Field {\n\n\treturn Array(key, complex64s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":34,"end_line":53,"code":"\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n\n// Bools constructs a field that carries a slice of bools.\nfunc Bools(key string, bs []bool) Field {\n\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers."},{"path":"array.go","start_line":57,"end_line":76,"code":"\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Durations","signature":"func Durations(key string, ds []time.Duration) Field","start_line":59,"end_line":61,"code":"func Durations(key string, ds []time.Duration) Field {\n\n\treturn Array(key, durations(ds))\n}\n","neighbors":[{"path":"array.go","start_line":39,"end_line":58,"code":"\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations."},{"path":"array.go","start_line":62,"end_line":81,"code":"\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Float64s","signature":"func Float64s(key string, nums []float64) Field","start_line":64,"end_line":66,"code":"func Float64s(key string, nums []float64) Field {\n\n\treturn Array(key, float64s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":44,"end_line":63,"code":"func ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats."},{"path":"array.go","start_line":67,"end_line":86,"code":"\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Float32s","signature":"func Float32s(key string, nums []float32) Field","start_line":69,"end_line":71,"code":"func Float32s(key string, nums []float32) Field {\n\n\treturn Array(key, float32s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":49,"end_line":68,"code":"func Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats."},{"path":"array.go","start_line":72,"end_line":91,"code":"\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Ints","signature":"func Ints(key string, nums []int) Field","start_line":74,"end_line":76,"code":"func Ints(key string, nums []int) Field {\n\n\treturn Array(key, ints(nums))\n}\n","neighbors":[{"path":"array.go","start_line":54,"end_line":73,"code":"func Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers."},{"path":"array.go","start_line":77,"end_line":96,"code":"\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}\n\n// Int8s constructs a field that carries a slice of integers.\nfunc Int8s(key string, nums []int8) Field {\n\treturn Array(key, int8s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Int64s","signature":"func Int64s(key string, nums []int64) Field","start_line":79,"end_line":81,"code":"func Int64s(key string, nums []int64) Field {\n\n\treturn Array(key, int64s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":59,"end_line":78,"code":"func Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers."},{"path":"array.go","start_line":82,"end_line":101,"code":"\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}\n\n// Int8s constructs a field that carries a slice of integers.\nfunc Int8s(key string, nums []int8) Field {\n\treturn Array(key, int8s(nums))\n}\n\n// Objects constructs a field with the given key, holding a list of the\n// provided objects that can be marshaled by Zap.\n//\n// Note that these objects must implement zapcore.ObjectMarshaler directly."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Int32s","signature":"func Int32s(key string, nums []int32) Field","start_line":84,"end_line":86,"code":"func Int32s(key string, nums []int32) Field {\n\n\treturn Array(key, int32s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":64,"end_line":83,"code":"func Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers."},{"path":"array.go","start_line":87,"end_line":106,"code":"\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}\n\n// Int8s constructs a field that carries a slice of integers.\nfunc Int8s(key string, nums []int8) Field {\n\treturn Array(key, int8s(nums))\n}\n\n// Objects constructs a field with the given key, holding a list of the\n// provided objects that can be marshaled by Zap.\n//\n// Note that these objects must implement zapcore.ObjectMarshaler directly.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the Request type, not its pointer (*Request).\n// If it's on the pointer, use ObjectValues.\n//\n// Given an object that implements MarshalLogObject on the value receiver, you"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Int16s","signature":"func Int16s(key string, nums []int16) Field","start_line":89,"end_line":91,"code":"func Int16s(key string, nums []int16) Field {\n\n\treturn Array(key, int16s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":69,"end_line":88,"code":"func Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers."},{"path":"array.go","start_line":92,"end_line":111,"code":"\n// Int8s constructs a field that carries a slice of integers.\nfunc Int8s(key string, nums []int8) Field {\n\treturn Array(key, int8s(nums))\n}\n\n// Objects constructs a field with the given key, holding a list of the\n// provided objects that can be marshaled by Zap.\n//\n// Note that these objects must implement zapcore.ObjectMarshaler directly.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the Request type, not its pointer (*Request).\n// If it's on the pointer, use ObjectValues.\n//\n// Given an object that implements MarshalLogObject on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Author struct{ ... }\n//\tfunc (a Author) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Int8s","signature":"func Int8s(key string, nums []int8) Field","start_line":94,"end_line":96,"code":"func Int8s(key string, nums []int8) Field {\n\n\treturn Array(key, int8s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":74,"end_line":93,"code":"func Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}\n\n// Int8s constructs a field that carries a slice of integers."},{"path":"array.go","start_line":97,"end_line":116,"code":"\n// Objects constructs a field with the given key, holding a list of the\n// provided objects that can be marshaled by Zap.\n//\n// Note that these objects must implement zapcore.ObjectMarshaler directly.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the Request type, not its pointer (*Request).\n// If it's on the pointer, use ObjectValues.\n//\n// Given an object that implements MarshalLogObject on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Author struct{ ... }\n//\tfunc (a Author) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar authors []Author = ...\n//\tlogger.Info(\"loading article\", zap.Objects(\"authors\", authors))\n//\n// Similarly, given a type that implements MarshalLogObject on its pointer\n// receiver, you can log a slice of pointers to that object with Objects like"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Objects","signature":"func Objects[T zapcore.ObjectMarshaler](key string, values []T) Field","start_line":130,"end_line":132,"code":"func Objects[T zapcore.ObjectMarshaler](key string, values []T) Field {\n\n\treturn Array(key, objects[T](values))\n}\n","neighbors":[{"path":"array.go","start_line":110,"end_line":129,"code":"//\tfunc (a Author) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar authors []Author = ...\n//\tlogger.Info(\"loading article\", zap.Objects(\"authors\", authors))\n//\n// Similarly, given a type that implements MarshalLogObject on its pointer\n// receiver, you can log a slice of pointers to that object with Objects like\n// so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))\n//\n// If instead, you have a slice of values of such an object, use the\n// ObjectValues constructor.\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))"},{"path":"array.go","start_line":133,"end_line":152,"code":"\ntype objects[T zapcore.ObjectMarshaler] []T\n\nfunc (os objects[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tif err := arr.AppendObject(o); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ObjectMarshalerPtr is a constraint that specifies that the given type\n// implements zapcore.ObjectMarshaler on a pointer receiver.\ntype ObjectMarshalerPtr[T any] interface {\n\t*T\n\tzapcore.ObjectMarshaler\n}\n\n// ObjectValues constructs a field with the given key, holding a list of the"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(objects[T]).MarshalLogArray","signature":"func (os objects[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":136,"end_line":143,"code":"func (os objects[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor _, o := range os {\n\t\tif err := arr.AppendObject(o); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":116,"end_line":135,"code":"// receiver, you can log a slice of pointers to that object with Objects like\n// so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))\n//\n// If instead, you have a slice of values of such an object, use the\n// ObjectValues constructor.\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))\nfunc Objects[T zapcore.ObjectMarshaler](key string, values []T) Field {\n\treturn Array(key, objects[T](values))\n}\n\ntype objects[T zapcore.ObjectMarshaler] []T\n"},{"path":"array.go","start_line":144,"end_line":163,"code":"\n// ObjectMarshalerPtr is a constraint that specifies that the given type\n// implements zapcore.ObjectMarshaler on a pointer receiver.\ntype ObjectMarshalerPtr[T any] interface {\n\t*T\n\tzapcore.ObjectMarshaler\n}\n\n// ObjectValues constructs a field with the given key, holding a list of the\n// provided objects, where pointers to these objects can be marshaled by Zap.\n//\n// Note that pointers to these objects must implement zapcore.ObjectMarshaler.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the *Request type, not the value (Request).\n// If it's on the value, use Objects.\n//\n// Given an object that implements MarshalLogObject on the pointer receiver,\n// you can log a slice of those objects with ObjectValues like so:\n//\n//\ttype Request struct{ ... }"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"ObjectValues","signature":"func ObjectValues[T any, P ObjectMarshalerPtr[T]](key string, values []T) Field","start_line":174,"end_line":176,"code":"func ObjectValues[T any, P ObjectMarshalerPtr[T]](key string, values []T) Field {\n\n\treturn Array(key, objectValues[T, P](values))\n}\n","neighbors":[{"path":"array.go","start_line":154,"end_line":173,"code":"//\n// Note that pointers to these objects must implement zapcore.ObjectMarshaler.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the *Request type, not the value (Request).\n// If it's on the value, use Objects.\n//\n// Given an object that implements MarshalLogObject on the pointer receiver,\n// you can log a slice of those objects with ObjectValues like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))\n//\n// If instead, you have a slice of pointers of such an object, use the Objects\n// field constructor.\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))"},{"path":"array.go","start_line":177,"end_line":196,"code":"\ntype objectValues[T any, P ObjectMarshalerPtr[T]] []T\n\nfunc (os objectValues[T, P]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range os {\n\t\t// It is necessary for us to explicitly reference the \"P\" type.\n\t\t// We cannot simply pass \"\u0026os[i]\" to AppendObject because its type\n\t\t// is \"*T\", which the type system does not consider as\n\t\t// implementing ObjectMarshaler.\n\t\t// Only the type \"P\" satisfies ObjectMarshaler, which we have\n\t\t// to convert \"*T\" to explicitly.\n\t\tvar p P = \u0026os[i]\n\t\tif err := arr.AppendObject(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Strings constructs a field that carries a slice of strings."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(objectValues[T, P]).MarshalLogArray","signature":"func (os objectValues[T, P]) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":180,"end_line":194,"code":"func (os objectValues[T, P]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range os {\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tvar p P = \u0026os[i]\n\t\tif err := arr.AppendObject(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":160,"end_line":179,"code":"// Given an object that implements MarshalLogObject on the pointer receiver,\n// you can log a slice of those objects with ObjectValues like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))\n//\n// If instead, you have a slice of pointers of such an object, use the Objects\n// field constructor.\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))\nfunc ObjectValues[T any, P ObjectMarshalerPtr[T]](key string, values []T) Field {\n\treturn Array(key, objectValues[T, P](values))\n}\n\ntype objectValues[T any, P ObjectMarshalerPtr[T]] []T\n"},{"path":"array.go","start_line":195,"end_line":214,"code":"\n// Strings constructs a field that carries a slice of strings.\nfunc Strings(key string, ss []string) Field {\n\treturn Array(key, stringArray(ss))\n}\n\n// Stringers constructs a field with the given key, holding a list of the\n// output provided by the value's String method\n//\n// Given an object that implements String on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (a Request) String() string\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Strings","signature":"func Strings(key string, ss []string) Field","start_line":197,"end_line":199,"code":"func Strings(key string, ss []string) Field {\n\n\treturn Array(key, stringArray(ss))\n}\n","neighbors":[{"path":"array.go","start_line":177,"end_line":196,"code":"\ntype objectValues[T any, P ObjectMarshalerPtr[T]] []T\n\nfunc (os objectValues[T, P]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range os {\n\t\t// It is necessary for us to explicitly reference the \"P\" type.\n\t\t// We cannot simply pass \"\u0026os[i]\" to AppendObject because its type\n\t\t// is \"*T\", which the type system does not consider as\n\t\t// implementing ObjectMarshaler.\n\t\t// Only the type \"P\" satisfies ObjectMarshaler, which we have\n\t\t// to convert \"*T\" to explicitly.\n\t\tvar p P = \u0026os[i]\n\t\tif err := arr.AppendObject(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Strings constructs a field that carries a slice of strings."},{"path":"array.go","start_line":200,"end_line":219,"code":"\n// Stringers constructs a field with the given key, holding a list of the\n// output provided by the value's String method\n//\n// Given an object that implements String on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (a Request) String() string\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method\n// must be declared on the Request type, not its pointer (*Request).\nfunc Stringers[T fmt.Stringer](key string, values []T) Field {\n\treturn Array(key, stringers[T](values))\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Stringers","signature":"func Stringers[T fmt.Stringer](key string, values []T) Field","start_line":216,"end_line":218,"code":"func Stringers[T fmt.Stringer](key string, values []T) Field {\n\n\treturn Array(key, stringers[T](values))\n}\n","neighbors":[{"path":"array.go","start_line":196,"end_line":215,"code":"// Strings constructs a field that carries a slice of strings.\nfunc Strings(key string, ss []string) Field {\n\treturn Array(key, stringArray(ss))\n}\n\n// Stringers constructs a field with the given key, holding a list of the\n// output provided by the value's String method\n//\n// Given an object that implements String on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (a Request) String() string\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method\n// must be declared on the Request type, not its pointer (*Request)."},{"path":"array.go","start_line":219,"end_line":238,"code":"\ntype stringers[T fmt.Stringer] []T\n\nfunc (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(stringers[T]).MarshalLogArray","signature":"func (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":222,"end_line":227,"code":"func (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":202,"end_line":221,"code":"// output provided by the value's String method\n//\n// Given an object that implements String on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (a Request) String() string\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method\n// must be declared on the Request type, not its pointer (*Request).\nfunc Stringers[T fmt.Stringer](key string, values []T) Field {\n\treturn Array(key, stringers[T](values))\n}\n\ntype stringers[T fmt.Stringer] []T\n"},{"path":"array.go","start_line":228,"end_line":247,"code":"\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Times","signature":"func Times(key string, ts []time.Time) Field","start_line":230,"end_line":232,"code":"func Times(key string, ts []time.Time) Field {\n\n\treturn Array(key, times(ts))\n}\n","neighbors":[{"path":"array.go","start_line":210,"end_line":229,"code":"//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method\n// must be declared on the Request type, not its pointer (*Request).\nfunc Stringers[T fmt.Stringer](key string, values []T) Field {\n\treturn Array(key, stringers[T](values))\n}\n\ntype stringers[T fmt.Stringer] []T\n\nfunc (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times."},{"path":"array.go","start_line":233,"end_line":252,"code":"\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uints","signature":"func Uints(key string, nums []uint) Field","start_line":235,"end_line":237,"code":"func Uints(key string, nums []uint) Field {\n\n\treturn Array(key, uints(nums))\n}\n","neighbors":[{"path":"array.go","start_line":215,"end_line":234,"code":"// must be declared on the Request type, not its pointer (*Request).\nfunc Stringers[T fmt.Stringer](key string, values []T) Field {\n\treturn Array(key, stringers[T](values))\n}\n\ntype stringers[T fmt.Stringer] []T\n\nfunc (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers."},{"path":"array.go","start_line":238,"end_line":257,"code":"\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uint64s","signature":"func Uint64s(key string, nums []uint64) Field","start_line":240,"end_line":242,"code":"func Uint64s(key string, nums []uint64) Field {\n\n\treturn Array(key, uint64s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":220,"end_line":239,"code":"type stringers[T fmt.Stringer] []T\n\nfunc (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers."},{"path":"array.go","start_line":243,"end_line":262,"code":"\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uint32s","signature":"func Uint32s(key string, nums []uint32) Field","start_line":245,"end_line":247,"code":"func Uint32s(key string, nums []uint32) Field {\n\n\treturn Array(key, uint32s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":225,"end_line":244,"code":"\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers."},{"path":"array.go","start_line":248,"end_line":267,"code":"\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uint16s","signature":"func Uint16s(key string, nums []uint16) Field","start_line":250,"end_line":252,"code":"func Uint16s(key string, nums []uint16) Field {\n\n\treturn Array(key, uint16s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":230,"end_line":249,"code":"func Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers."},{"path":"array.go","start_line":253,"end_line":272,"code":"\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uint8s","signature":"func Uint8s(key string, nums []uint8) Field","start_line":255,"end_line":257,"code":"func Uint8s(key string, nums []uint8) Field {\n\n\treturn Array(key, uint8s(nums))\n}\n","neighbors":[{"path":"array.go","start_line":235,"end_line":254,"code":"func Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers."},{"path":"array.go","start_line":258,"end_line":277,"code":"\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Uintptrs","signature":"func Uintptrs(key string, us []uintptr) Field","start_line":260,"end_line":262,"code":"func Uintptrs(key string, us []uintptr) Field {\n\n\treturn Array(key, uintptrs(us))\n}\n","neighbors":[{"path":"array.go","start_line":240,"end_line":259,"code":"func Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses."},{"path":"array.go","start_line":263,"end_line":282,"code":"\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n\ntype byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"Errors","signature":"func Errors(key string, errs []error) Field","start_line":265,"end_line":267,"code":"func Errors(key string, errs []error) Field {\n\n\treturn Array(key, errArray(errs))\n}\n","neighbors":[{"path":"array.go","start_line":245,"end_line":264,"code":"func Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors."},{"path":"array.go","start_line":268,"end_line":287,"code":"\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n\ntype byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n\ntype complex128s []complex128"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Array","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(bools).MarshalLogArray","signature":"func (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":271,"end_line":276,"code":"func (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":251,"end_line":270,"code":"\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n"},{"path":"array.go","start_line":277,"end_line":296,"code":"\ntype byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n\ntype complex128s []complex128\n\nfunc (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n\ntype complex64s []complex64"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendBool","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendBool","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*bools).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(byteStringsArray).MarshalLogArray","signature":"func (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":280,"end_line":285,"code":"func (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":260,"end_line":279,"code":"func Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n\ntype byteStringsArray [][]byte\n"},{"path":"array.go","start_line":286,"end_line":305,"code":"\ntype complex128s []complex128\n\nfunc (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n\ntype complex64s []complex64\n\nfunc (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n\ntype durations []time.Duration"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendByteString","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*byteStringsArray).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(complex128s).MarshalLogArray","signature":"func (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":289,"end_line":294,"code":"func (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":269,"end_line":288,"code":"type bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n\ntype byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n\ntype complex128s []complex128\n"},{"path":"array.go","start_line":295,"end_line":314,"code":"\ntype complex64s []complex64\n\nfunc (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n\ntype durations []time.Duration\n\nfunc (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n\ntype float64s []float64"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendComplex128","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*complex128s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(complex64s).MarshalLogArray","signature":"func (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":298,"end_line":303,"code":"func (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":278,"end_line":297,"code":"type byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n\ntype complex128s []complex128\n\nfunc (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n\ntype complex64s []complex64\n"},{"path":"array.go","start_line":304,"end_line":323,"code":"\ntype durations []time.Duration\n\nfunc (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n\ntype float64s []float64\n\nfunc (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n\ntype float32s []float32"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendComplex64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*complex64s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(durations).MarshalLogArray","signature":"func (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":307,"end_line":312,"code":"func (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":287,"end_line":306,"code":"type complex128s []complex128\n\nfunc (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n\ntype complex64s []complex64\n\nfunc (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n\ntype durations []time.Duration\n"},{"path":"array.go","start_line":313,"end_line":332,"code":"\ntype float64s []float64\n\nfunc (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n\ntype float32s []float32\n\nfunc (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n\ntype ints []int"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendDuration","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*durations).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(float64s).MarshalLogArray","signature":"func (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":316,"end_line":321,"code":"func (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":296,"end_line":315,"code":"type complex64s []complex64\n\nfunc (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n\ntype durations []time.Duration\n\nfunc (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n\ntype float64s []float64\n"},{"path":"array.go","start_line":322,"end_line":341,"code":"\ntype float32s []float32\n\nfunc (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n\ntype ints []int\n\nfunc (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n\ntype int64s []int64"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendFloat64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*float64s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(float32s).MarshalLogArray","signature":"func (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":325,"end_line":330,"code":"func (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":305,"end_line":324,"code":"type durations []time.Duration\n\nfunc (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n\ntype float64s []float64\n\nfunc (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n\ntype float32s []float32\n"},{"path":"array.go","start_line":331,"end_line":350,"code":"\ntype ints []int\n\nfunc (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n\ntype int64s []int64\n\nfunc (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n\ntype int32s []int32"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendFloat32","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*float32s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(ints).MarshalLogArray","signature":"func (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":334,"end_line":339,"code":"func (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":314,"end_line":333,"code":"type float64s []float64\n\nfunc (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n\ntype float32s []float32\n\nfunc (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n\ntype ints []int\n"},{"path":"array.go","start_line":340,"end_line":359,"code":"\ntype int64s []int64\n\nfunc (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n\ntype int32s []int32\n\nfunc (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n\ntype int16s []int16"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*ints).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(int64s).MarshalLogArray","signature":"func (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":343,"end_line":348,"code":"func (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":323,"end_line":342,"code":"type float32s []float32\n\nfunc (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n\ntype ints []int\n\nfunc (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n\ntype int64s []int64\n"},{"path":"array.go","start_line":349,"end_line":368,"code":"\ntype int32s []int32\n\nfunc (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n\ntype int16s []int16\n\nfunc (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n\ntype int8s []int8"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*int64s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(int32s).MarshalLogArray","signature":"func (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":352,"end_line":357,"code":"func (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":332,"end_line":351,"code":"type ints []int\n\nfunc (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n\ntype int64s []int64\n\nfunc (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n\ntype int32s []int32\n"},{"path":"array.go","start_line":358,"end_line":377,"code":"\ntype int16s []int16\n\nfunc (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n\ntype int8s []int8\n\nfunc (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n\ntype stringArray []string"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt32","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt32","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*int32s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(int16s).MarshalLogArray","signature":"func (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":361,"end_line":366,"code":"func (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":341,"end_line":360,"code":"type int64s []int64\n\nfunc (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n\ntype int32s []int32\n\nfunc (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n\ntype int16s []int16\n"},{"path":"array.go","start_line":367,"end_line":386,"code":"\ntype int8s []int8\n\nfunc (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n\ntype stringArray []string\n\nfunc (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n\ntype times []time.Time"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt16","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt16","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*int16s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(int8s).MarshalLogArray","signature":"func (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":370,"end_line":375,"code":"func (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":350,"end_line":369,"code":"type int32s []int32\n\nfunc (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n\ntype int16s []int16\n\nfunc (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n\ntype int8s []int8\n"},{"path":"array.go","start_line":376,"end_line":395,"code":"\ntype stringArray []string\n\nfunc (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n\ntype times []time.Time\n\nfunc (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n\ntype uints []uint"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt8","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt8","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*int8s).MarshalLogArray","path":"array.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(stringArray).MarshalLogArray","signature":"func (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":379,"end_line":384,"code":"func (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":359,"end_line":378,"code":"type int16s []int16\n\nfunc (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n\ntype int8s []int8\n\nfunc (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n\ntype stringArray []string\n"},{"path":"array.go","start_line":385,"end_line":404,"code":"\ntype times []time.Time\n\nfunc (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n\ntype uints []uint\n\nfunc (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint64s []uint64"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*stringArray).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(times).MarshalLogArray","signature":"func (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":388,"end_line":393,"code":"func (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":368,"end_line":387,"code":"type int8s []int8\n\nfunc (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n\ntype stringArray []string\n\nfunc (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n\ntype times []time.Time\n"},{"path":"array.go","start_line":394,"end_line":413,"code":"\ntype uints []uint\n\nfunc (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint64s []uint64\n\nfunc (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint32s []uint32"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendTime","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*times).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uints).MarshalLogArray","signature":"func (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":397,"end_line":402,"code":"func (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":377,"end_line":396,"code":"type stringArray []string\n\nfunc (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n\ntype times []time.Time\n\nfunc (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n\ntype uints []uint\n"},{"path":"array.go","start_line":403,"end_line":422,"code":"\ntype uint64s []uint64\n\nfunc (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint32s []uint32\n\nfunc (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint16s []uint16"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUint","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uints).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uint64s).MarshalLogArray","signature":"func (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":406,"end_line":411,"code":"func (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":386,"end_line":405,"code":"type times []time.Time\n\nfunc (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n\ntype uints []uint\n\nfunc (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint64s []uint64\n"},{"path":"array.go","start_line":412,"end_line":431,"code":"\ntype uint32s []uint32\n\nfunc (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint16s []uint16\n\nfunc (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint8s []uint8"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUint64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uint64s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uint32s).MarshalLogArray","signature":"func (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":415,"end_line":420,"code":"func (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":395,"end_line":414,"code":"type uints []uint\n\nfunc (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint64s []uint64\n\nfunc (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint32s []uint32\n"},{"path":"array.go","start_line":421,"end_line":440,"code":"\ntype uint16s []uint16\n\nfunc (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint8s []uint8\n\nfunc (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint8(nums[i])\n\t}\n\treturn nil\n}\n\ntype uintptrs []uintptr"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint32","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUint32","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uint32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uint16s).MarshalLogArray","signature":"func (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":424,"end_line":429,"code":"func (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":404,"end_line":423,"code":"type uint64s []uint64\n\nfunc (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint32s []uint32\n\nfunc (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint16s []uint16\n"},{"path":"array.go","start_line":430,"end_line":448,"code":"\ntype uint8s []uint8\n\nfunc (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint8(nums[i])\n\t}\n\treturn nil\n}\n\ntype uintptrs []uintptr\n\nfunc (nums uintptrs) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUintptr(nums[i])\n\t}\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint16","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUint16","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uint16s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uint8s).MarshalLogArray","signature":"func (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":433,"end_line":438,"code":"func (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUint8(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":413,"end_line":432,"code":"type uint32s []uint32\n\nfunc (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint16s []uint16\n\nfunc (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint8s []uint8\n"},{"path":"array.go","start_line":439,"end_line":448,"code":"\ntype uintptrs []uintptr\n\nfunc (nums uintptrs) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUintptr(nums[i])\n\t}\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint8","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUint8","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uint8s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"array.go","symbol":"(uintptrs).MarshalLogArray","signature":"func (nums uintptrs) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":442,"end_line":447,"code":"func (nums uintptrs) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range nums {\n\t\tarr.AppendUintptr(nums[i])\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"array.go","start_line":422,"end_line":441,"code":"type uint16s []uint16\n\nfunc (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint8s []uint8\n\nfunc (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint8(nums[i])\n\t}\n\treturn nil\n}\n\ntype uintptrs []uintptr\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendUintptr","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*uintptrs).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendByte","signature":"func (b *Buffer) AppendByte(v byte)","start_line":41,"end_line":43,"code":"func (b *Buffer) AppendByte(v byte) {\n\n\tb.bs = append(b.bs, v)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":21,"end_line":40,"code":"// Package buffer provides a thin wrapper around a byte slice. Unlike the\n// standard library's bytes.Buffer, it supports a portion of the strconv\n// package's zero-allocation formatters.\npackage buffer // import \"go.uber.org/zap/buffer\"\n\nimport (\n\t\"strconv\"\n\t\"time\"\n)\n\nconst _size = 1024 // by default, create 1 KiB buffers\n\n// Buffer is a thin wrapper around a byte slice. It's intended to be pooled, so\n// the only way to construct one is via a Pool.\ntype Buffer struct {\n\tbs   []byte\n\tpool Pool\n}\n\n// AppendByte writes a single byte to the Buffer."},{"path":"buffer/buffer.go","start_line":44,"end_line":63,"code":"\n// AppendBytes writes the given slice of bytes to the Buffer.\nfunc (b *Buffer) AppendBytes(v []byte) {\n\tb.bs = append(b.bs, v...)\n}\n\n// AppendString writes a string to the Buffer.\nfunc (b *Buffer) AppendString(s string) {\n\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.78},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffer).WriteByte","path":"buffer/buffer.go"},{"symbol":"(*Formatter).FormatFrame","path":"internal/stacktrace/stack.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).OpenNamespace","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).appendComplex","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"},{"symbol":"safeAppendStringLike","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendBytes","signature":"func (b *Buffer) AppendBytes(v []byte)","start_line":46,"end_line":48,"code":"func (b *Buffer) AppendBytes(v []byte) {\n\n\tb.bs = append(b.bs, v...)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":26,"end_line":45,"code":"import (\n\t\"strconv\"\n\t\"time\"\n)\n\nconst _size = 1024 // by default, create 1 KiB buffers\n\n// Buffer is a thin wrapper around a byte slice. It's intended to be pooled, so\n// the only way to construct one is via a Pool.\ntype Buffer struct {\n\tbs   []byte\n\tpool Pool\n}\n\n// AppendByte writes a single byte to the Buffer.\nfunc (b *Buffer) AppendByte(v byte) {\n\tb.bs = append(b.bs, v)\n}\n\n// AppendBytes writes the given slice of bytes to the Buffer."},{"path":"buffer/buffer.go","start_line":49,"end_line":68,"code":"\n// AppendString writes a string to the Buffer.\nfunc (b *Buffer) AppendString(s string) {\n\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendString","signature":"func (b *Buffer) AppendString(s string)","start_line":51,"end_line":53,"code":"func (b *Buffer) AppendString(s string) {\n\n\tb.bs = append(b.bs, s...)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":31,"end_line":50,"code":"const _size = 1024 // by default, create 1 KiB buffers\n\n// Buffer is a thin wrapper around a byte slice. It's intended to be pooled, so\n// the only way to construct one is via a Pool.\ntype Buffer struct {\n\tbs   []byte\n\tpool Pool\n}\n\n// AppendByte writes a single byte to the Buffer.\nfunc (b *Buffer) AppendByte(v byte) {\n\tb.bs = append(b.bs, v)\n}\n\n// AppendBytes writes the given slice of bytes to the Buffer.\nfunc (b *Buffer) AppendBytes(v []byte) {\n\tb.bs = append(b.bs, v...)\n}\n\n// AppendString writes a string to the Buffer."},{"path":"buffer/buffer.go","start_line":54,"end_line":73,"code":"\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)"}],"selection":{"visibility":"exported","reason":"other","score":0.74},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffer).WriteString","path":"buffer/buffer.go"},{"symbol":"(*Formatter).FormatFrame","path":"internal/stacktrace/stack.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).appendFloat","path":"zapcore/json_encoder.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).addSeparatorIfNecessary","path":"zapcore/console_encoder.go"},{"symbol":"safeAppendStringLike","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendInt","signature":"func (b *Buffer) AppendInt(i int64)","start_line":56,"end_line":58,"code":"func (b *Buffer) AppendInt(i int64) {\n\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":36,"end_line":55,"code":"\tbs   []byte\n\tpool Pool\n}\n\n// AppendByte writes a single byte to the Buffer.\nfunc (b *Buffer) AppendByte(v byte) {\n\tb.bs = append(b.bs, v)\n}\n\n// AppendBytes writes the given slice of bytes to the Buffer.\nfunc (b *Buffer) AppendBytes(v []byte) {\n\tb.bs = append(b.bs, v...)\n}\n\n// AppendString writes a string to the Buffer.\nfunc (b *Buffer) AppendString(s string) {\n\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10)."},{"path":"buffer/buffer.go","start_line":59,"end_line":78,"code":"\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"AppendInt","path":"../../../../usr/local/go/src/strconv/itoa.go"}],"callers":[{"symbol":"(*Formatter).FormatFrame","path":"internal/stacktrace/stack.go"},{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendTime","signature":"func (b *Buffer) AppendTime(t time.Time, layout string)","start_line":61,"end_line":63,"code":"func (b *Buffer) AppendTime(t time.Time, layout string) {\n\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":41,"end_line":60,"code":"func (b *Buffer) AppendByte(v byte) {\n\tb.bs = append(b.bs, v)\n}\n\n// AppendBytes writes the given slice of bytes to the Buffer.\nfunc (b *Buffer) AppendBytes(v []byte) {\n\tb.bs = append(b.bs, v...)\n}\n\n// AppendString writes a string to the Buffer.\nfunc (b *Buffer) AppendString(s string) {\n\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout."},{"path":"buffer/buffer.go","start_line":64,"end_line":83,"code":"\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(Time).AppendFormat","path":"../../../../usr/local/go/src/time/format.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendUint","signature":"func (b *Buffer) AppendUint(i uint64)","start_line":67,"end_line":69,"code":"func (b *Buffer) AppendUint(i uint64) {\n\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":47,"end_line":66,"code":"\tb.bs = append(b.bs, v...)\n}\n\n// AppendString writes a string to the Buffer.\nfunc (b *Buffer) AppendString(s string) {\n\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10)."},{"path":"buffer/buffer.go","start_line":70,"end_line":89,"code":"\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"AppendUint","path":"../../../../usr/local/go/src/strconv/itoa.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendBool","signature":"func (b *Buffer) AppendBool(v bool)","start_line":72,"end_line":74,"code":"func (b *Buffer) AppendBool(v bool) {\n\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":52,"end_line":71,"code":"\tb.bs = append(b.bs, s...)\n}\n\n// AppendInt appends an integer to the underlying buffer (assuming base 10).\nfunc (b *Buffer) AppendInt(i int64) {\n\tb.bs = strconv.AppendInt(b.bs, i, 10)\n}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer."},{"path":"buffer/buffer.go","start_line":75,"end_line":94,"code":"\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"AppendBool","path":"../../../../usr/local/go/src/strconv/atob.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendBool","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).AppendFloat","signature":"func (b *Buffer) AppendFloat(f float64, bitSize int)","start_line":78,"end_line":80,"code":"func (b *Buffer) AppendFloat(f float64, bitSize int) {\n\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":58,"end_line":77,"code":"}\n\n// AppendTime appends the time formatted using the specified layout.\nfunc (b *Buffer) AppendTime(t time.Time, layout string) {\n\tb.bs = t.AppendFormat(b.bs, layout)\n}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf."},{"path":"buffer/buffer.go","start_line":81,"end_line":100,"code":"\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"AppendFloat","path":"../../../../usr/local/go/src/strconv/ftoa.go"}],"callers":[{"symbol":"(*jsonEncoder).appendComplex","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).appendFloat","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Len","signature":"func (b *Buffer) Len() int","start_line":83,"end_line":85,"code":"func (b *Buffer) Len() int {\n\n\treturn len(b.bs)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":63,"end_line":82,"code":"}\n\n// AppendUint appends an unsigned integer to the underlying buffer (assuming\n// base 10).\nfunc (b *Buffer) AppendUint(i uint64) {\n\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice."},{"path":"buffer/buffer.go","start_line":86,"end_line":105,"code":"\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).addSeparatorIfNecessary","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Cap","signature":"func (b *Buffer) Cap() int","start_line":88,"end_line":90,"code":"func (b *Buffer) Cap() int {\n\n\treturn cap(b.bs)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":68,"end_line":87,"code":"\tb.bs = strconv.AppendUint(b.bs, i, 10)\n}\n\n// AppendBool appends a bool to the underlying buffer.\nfunc (b *Buffer) AppendBool(v bool) {\n\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice."},{"path":"buffer/buffer.go","start_line":91,"end_line":110,"code":"\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]\n}\n\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Bytes","signature":"func (b *Buffer) Bytes() []byte","start_line":93,"end_line":95,"code":"func (b *Buffer) Bytes() []byte {\n\n\treturn b.bs\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":73,"end_line":92,"code":"\tb.bs = strconv.AppendBool(b.bs, v)\n}\n\n// AppendFloat appends a float to the underlying buffer. It doesn't quote NaN\n// or +/- Inf.\nfunc (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice."},{"path":"buffer/buffer.go","start_line":96,"end_line":115,"code":"\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]\n}\n\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n\n// WriteByte writes a single byte to the Buffer.\n//"}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":null,"callers":[{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).encodeReflected","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).String","signature":"func (b *Buffer) String() string","start_line":98,"end_line":100,"code":"func (b *Buffer) String() string {\n\n\treturn string(b.bs)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":78,"end_line":97,"code":"func (b *Buffer) AppendFloat(f float64, bitSize int) {\n\tb.bs = strconv.AppendFloat(b.bs, f, 'f', -1, bitSize)\n}\n\n// Len returns the length of the underlying byte slice.\nfunc (b *Buffer) Len() int {\n\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice."},{"path":"buffer/buffer.go","start_line":101,"end_line":120,"code":"\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]\n}\n\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteByte(v byte) error {\n\tb.AppendByte(v)\n\treturn nil"}],"selection":{"visibility":"exported","reason":"other","score":0.68},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*pp).handleMethods","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"(http2FrameWriteRequest).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"},{"symbol":"contextName","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"stringify","path":"../../../../usr/local/go/src/context/context.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Reset","signature":"func (b *Buffer) Reset()","start_line":104,"end_line":106,"code":"func (b *Buffer) Reset() {\n\n\tb.bs = b.bs[:0]\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":84,"end_line":103,"code":"\treturn len(b.bs)\n}\n\n// Cap returns the capacity of the underlying byte slice.\nfunc (b *Buffer) Cap() int {\n\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array."},{"path":"buffer/buffer.go","start_line":107,"end_line":126,"code":"\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteByte(v byte) error {\n\tb.AppendByte(v)\n\treturn nil\n}\n\n// WriteString writes a string to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":null,"callers":[{"symbol":"(*jsonEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).truncate","path":"zapcore/json_encoder.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Write","signature":"func (b *Buffer) Write(bs []byte) (int, error)","start_line":109,"end_line":112,"code":"func (b *Buffer) Write(bs []byte) (int, error) {\n\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":89,"end_line":108,"code":"\treturn cap(b.bs)\n}\n\n// Bytes returns a mutable reference to the underlying byte slice.\nfunc (b *Buffer) Bytes() []byte {\n\treturn b.bs\n}\n\n// String returns a string copy of the underlying byte slice.\nfunc (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]\n}\n\n// Write implements io.Writer."},{"path":"buffer/buffer.go","start_line":113,"end_line":132,"code":"\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteByte(v byte) error {\n\tb.AppendByte(v)\n\treturn nil\n}\n\n// WriteString writes a string to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteString(s string) (int, error) {\n\tb.AppendString(s)\n\treturn len(s), nil\n}\n\n// TrimNewline trims any final \"\\n\" byte from the end of the buffer."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*jsonEncoder).AddReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).WriteByte","signature":"func (b *Buffer) WriteByte(v byte) error","start_line":118,"end_line":121,"code":"func (b *Buffer) WriteByte(v byte) error {\n\n\tb.AppendByte(v)\n\treturn nil\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":98,"end_line":117,"code":"func (b *Buffer) String() string {\n\treturn string(b.bs)\n}\n\n// Reset resets the underlying byte slice. Subsequent writes re-use the slice's\n// backing array.\nfunc (b *Buffer) Reset() {\n\tb.bs = b.bs[:0]\n}\n\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer"},{"path":"buffer/buffer.go","start_line":122,"end_line":141,"code":"\n// WriteString writes a string to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteString(s string) (int, error) {\n\tb.AppendString(s)\n\treturn len(s), nil\n}\n\n// TrimNewline trims any final \"\\n\" byte from the end of the buffer.\nfunc (b *Buffer) TrimNewline() {\n\tif i := len(b.bs) - 1; i \u003e= 0 {\n\t\tif b.bs[i] == '\\n' {\n\t\t\tb.bs = b.bs[:i]\n\t\t}\n\t}\n}\n\n// Free returns the Buffer to its Pool."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).WriteString","signature":"func (b *Buffer) WriteString(s string) (int, error)","start_line":127,"end_line":130,"code":"func (b *Buffer) WriteString(s string) (int, error) {\n\n\tb.AppendString(s)\n\treturn len(s), nil\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":107,"end_line":126,"code":"\n// Write implements io.Writer.\nfunc (b *Buffer) Write(bs []byte) (int, error) {\n\tb.bs = append(b.bs, bs...)\n\treturn len(bs), nil\n}\n\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteByte(v byte) error {\n\tb.AppendByte(v)\n\treturn nil\n}\n\n// WriteString writes a string to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer"},{"path":"buffer/buffer.go","start_line":131,"end_line":147,"code":"\n// TrimNewline trims any final \"\\n\" byte from the end of the buffer.\nfunc (b *Buffer) TrimNewline() {\n\tif i := len(b.bs) - 1; i \u003e= 0 {\n\t\tif b.bs[i] == '\\n' {\n\t\t\tb.bs = b.bs[:i]\n\t\t}\n\t}\n}\n\n// Free returns the Buffer to its Pool.\n//\n// Callers must not retain references to the Buffer after calling Free.\nfunc (b *Buffer) Free() {\n\tb.pool.put(b)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*Writer).WriteString","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*byteReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*genericReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*multiWriter).WriteString","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*singleStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(Header).writeSubset","path":"../../../../usr/local/go/src/net/http/header.go"},{"symbol":"WriteString","path":"../../../../usr/local/go/src/io/io.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).TrimNewline","signature":"func (b *Buffer) TrimNewline()","start_line":133,"end_line":139,"code":"func (b *Buffer) TrimNewline() {\n\n\tif i := len(b.bs) - 1; i \u003e= 0 {\n\t\tif b.bs[i] == '\\n' {\n\t\t\tb.bs = b.bs[:i]\n\t\t}\n\t}\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":113,"end_line":132,"code":"\n// WriteByte writes a single byte to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteByte(v byte) error {\n\tb.AppendByte(v)\n\treturn nil\n}\n\n// WriteString writes a string to the Buffer.\n//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteString(s string) (int, error) {\n\tb.AppendString(s)\n\treturn len(s), nil\n}\n\n// TrimNewline trims any final \"\\n\" byte from the end of the buffer."},{"path":"buffer/buffer.go","start_line":140,"end_line":147,"code":"\n// Free returns the Buffer to its Pool.\n//\n// Callers must not retain references to the Buffer after calling Free.\nfunc (b *Buffer) Free() {\n\tb.pool.put(b)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(*jsonEncoder).encodeReflected","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/buffer.go","symbol":"(*Buffer).Free","signature":"func (b *Buffer) Free()","start_line":144,"end_line":146,"code":"func (b *Buffer) Free() {\n\n\tb.pool.put(b)\n}\n","neighbors":[{"path":"buffer/buffer.go","start_line":124,"end_line":143,"code":"//\n// Error returned is always nil, function signature is compatible\n// with bytes.Buffer and bufio.Writer\nfunc (b *Buffer) WriteString(s string) (int, error) {\n\tb.AppendString(s)\n\treturn len(s), nil\n}\n\n// TrimNewline trims any final \"\\n\" byte from the end of the buffer.\nfunc (b *Buffer) TrimNewline() {\n\tif i := len(b.bs) - 1; i \u003e= 0 {\n\t\tif b.bs[i] == '\\n' {\n\t\t\tb.bs = b.bs[:i]\n\t\t}\n\t}\n}\n\n// Free returns the Buffer to its Pool.\n//\n// Callers must not retain references to the Buffer after calling Free."}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"(Pool).put","path":"buffer/pool.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"},{"symbol":"putJSONEncoder","path":"zapcore/json_encoder.go"},{"symbol":"writeContext$1","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/pool.go","symbol":"NewPool","signature":"func NewPool() Pool","start_line":33,"end_line":41,"code":"func NewPool() Pool {\n\n\treturn Pool{\n\t\tp: pool.New(func() *Buffer {\n\t\t\treturn \u0026Buffer{\n\t\t\t\tbs: make([]byte, 0, _size),\n\t\t\t}\n\t\t}),\n\t}\n}\n","neighbors":[{"path":"buffer/pool.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage buffer\n\nimport (\n\t\"go.uber.org/zap/internal/pool\"\n)\n\n// A Pool is a type-safe wrapper around a sync.Pool.\ntype Pool struct {\n\tp *pool.Pool[*Buffer]\n}\n\n// NewPool constructs a new Pool."},{"path":"buffer/pool.go","start_line":42,"end_line":54,"code":"\n// Get retrieves a Buffer from the pool, creating one if necessary.\nfunc (p Pool) Get() *Buffer {\n\tbuf := p.p.Get()\n\tbuf.Reset()\n\tbuf.pool = p\n\treturn buf\n}\n\nfunc (p Pool) put(buf *Buffer) {\n\tp.p.Put(buf)\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"New[*go.uber.org/zap/buffer.Buffer]","path":"internal/pool/pool.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/pool.go","symbol":"(Pool).Get","signature":"func (p Pool) Get() *Buffer","start_line":44,"end_line":49,"code":"func (p Pool) Get() *Buffer {\n\n\tbuf := p.p.Get()\n\tbuf.Reset()\n\tbuf.pool = p\n\treturn buf\n}\n","neighbors":[{"path":"buffer/pool.go","start_line":24,"end_line":43,"code":"\t\"go.uber.org/zap/internal/pool\"\n)\n\n// A Pool is a type-safe wrapper around a sync.Pool.\ntype Pool struct {\n\tp *pool.Pool[*Buffer]\n}\n\n// NewPool constructs a new Pool.\nfunc NewPool() Pool {\n\treturn Pool{\n\t\tp: pool.New(func() *Buffer {\n\t\t\treturn \u0026Buffer{\n\t\t\t\tbs: make([]byte, 0, _size),\n\t\t\t}\n\t\t}),\n\t}\n}\n\n// Get retrieves a Buffer from the pool, creating one if necessary."},{"path":"buffer/pool.go","start_line":50,"end_line":54,"code":"\nfunc (p Pool) put(buf *Buffer) {\n\tp.p.Put(buf)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.77},"call_graph":{"callees":[{"symbol":"(*Buffer).Reset","path":"buffer/buffer.go"},{"symbol":"(*Pool).Get[*go.uber.org/zap/buffer.Buffer]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*Pool).Get","path":"buffer/pool.go"},{"symbol":"(*jsonEncoder).clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"},{"symbol":"newJSONEncoder","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"buffer/pool.go","symbol":"(Pool).put","signature":"func (p Pool) put(buf *Buffer)","start_line":51,"end_line":53,"code":"func (p Pool) put(buf *Buffer) {\n\n\tp.p.Put(buf)\n}\n","neighbors":[{"path":"buffer/pool.go","start_line":31,"end_line":50,"code":"\n// NewPool constructs a new Pool.\nfunc NewPool() Pool {\n\treturn Pool{\n\t\tp: pool.New(func() *Buffer {\n\t\t\treturn \u0026Buffer{\n\t\t\t\tbs: make([]byte, 0, _size),\n\t\t\t}\n\t\t}),\n\t}\n}\n\n// Get retrieves a Buffer from the pool, creating one if necessary.\nfunc (p Pool) Get() *Buffer {\n\tbuf := p.p.Get()\n\tbuf.Reset()\n\tbuf.pool = p\n\treturn buf\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"(*Pool).Put[*go.uber.org/zap/buffer.Buffer]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Pool).put","path":"buffer/pool.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"NewProductionEncoderConfig","signature":"func NewProductionEncoderConfig() zapcore.EncoderConfig","start_line":124,"end_line":139,"code":"func NewProductionEncoderConfig() zapcore.EncoderConfig {\n\n\treturn zapcore.EncoderConfig{\n\t\tTimeKey:        \"ts\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tCallerKey:      \"caller\",\n\t\tFunctionKey:    zapcore.OmitKey,\n\t\tMessageKey:     \"msg\",\n\t\tStacktraceKey:  \"stacktrace\",\n\t\tLineEnding:     zapcore.DefaultLineEnding,\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.EpochTimeEncoder,\n\t\tEncodeDuration: zapcore.SecondsDurationEncoder,\n\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n","neighbors":[{"path":"config.go","start_line":104,"end_line":123,"code":"//   - \"msg\": The message passed to the log statement.\n//   - \"caller\": If available, a short path to the file and line number\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//   - \"stacktrace\": If available, a stack trace from the line\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//\n// By default, the following formats are used for different types:\n//\n//   - Time is formatted as floating-point number of seconds since the Unix\n//     epoch.\n//   - Duration is formatted as floating-point number of seconds.\n//\n// You may change these by setting the appropriate fields in the returned\n// object.\n// For example, use the following to change the time encoding format:\n//\n//\tcfg := zap.NewProductionEncoderConfig()\n//\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder"},{"path":"config.go","start_line":140,"end_line":159,"code":"\n// NewProductionConfig builds a reasonable default production logging\n// configuration.\n// Logging is enabled at InfoLevel and above, and uses a JSON encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of ErrorLevel and above.\n// DPanicLevel logs will not panic, but will write a stacktrace.\n//\n// Sampling is enabled at 100:100 by default,\n// meaning that after the first 100 log entries\n// with the same level and message in the same second,\n// it will log every 100th entry\n// with the same level and message in the same second.\n// You may disable this behavior by setting Sampling to nil.\n//\n// See [NewProductionEncoderConfig] for information\n// on the default encoder configuration.\nfunc NewProductionConfig() Config {\n\treturn Config{\n\t\tLevel:       NewAtomicLevelAt(InfoLevel),"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"NewProductionConfig","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"NewProductionConfig","signature":"func NewProductionConfig() Config","start_line":157,"end_line":170,"code":"func NewProductionConfig() Config {\n\n\treturn Config{\n\t\tLevel:       NewAtomicLevelAt(InfoLevel),\n\t\tDevelopment: false,\n\t\tSampling: \u0026SamplingConfig{\n\t\t\tInitial:    100,\n\t\t\tThereafter: 100,\n\t\t},\n\t\tEncoding:         \"json\",\n\t\tEncoderConfig:    NewProductionEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}\n","neighbors":[{"path":"config.go","start_line":137,"end_line":156,"code":"\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n\n// NewProductionConfig builds a reasonable default production logging\n// configuration.\n// Logging is enabled at InfoLevel and above, and uses a JSON encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of ErrorLevel and above.\n// DPanicLevel logs will not panic, but will write a stacktrace.\n//\n// Sampling is enabled at 100:100 by default,\n// meaning that after the first 100 log entries\n// with the same level and message in the same second,\n// it will log every 100th entry\n// with the same level and message in the same second.\n// You may disable this behavior by setting Sampling to nil.\n//\n// See [NewProductionEncoderConfig] for information\n// on the default encoder configuration."},{"path":"config.go","start_line":171,"end_line":190,"code":"\n// NewDevelopmentEncoderConfig returns an opinionated EncoderConfig for\n// development environments.\n//\n// Messages encoded with this configuration will use Zap's console encoder\n// intended to print human-readable output.\n// It will print log messages with the following information:\n//\n//   - The log level (e.g. \"INFO\", \"ERROR\").\n//   - The time in ISO8601 format (e.g. \"2017-01-01T12:00:00Z\").\n//   - The message passed to the log statement.\n//   - If available, a short path to the file and line number\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//   - If available, a stacktrace from the line\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//\n// By default, the following formats are used for different types:\n//"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"NewAtomicLevelAt","path":"level.go"},{"symbol":"NewProductionEncoderConfig","path":"config.go"}],"callers":[{"symbol":"NewProduction","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"NewDevelopmentEncoderConfig","signature":"func NewDevelopmentEncoderConfig() zapcore.EncoderConfig","start_line":200,"end_line":216,"code":"func NewDevelopmentEncoderConfig() zapcore.EncoderConfig {\n\n\treturn zapcore.EncoderConfig{\n\t\t\n\t\tTimeKey:        \"T\",\n\t\tLevelKey:       \"L\",\n\t\tNameKey:        \"N\",\n\t\tCallerKey:      \"C\",\n\t\tFunctionKey:    zapcore.OmitKey,\n\t\tMessageKey:     \"M\",\n\t\tStacktraceKey:  \"S\",\n\t\tLineEnding:     zapcore.DefaultLineEnding,\n\t\tEncodeLevel:    zapcore.CapitalLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n","neighbors":[{"path":"config.go","start_line":180,"end_line":199,"code":"//   - The time in ISO8601 format (e.g. \"2017-01-01T12:00:00Z\").\n//   - The message passed to the log statement.\n//   - If available, a short path to the file and line number\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//   - If available, a stacktrace from the line\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//\n// By default, the following formats are used for different types:\n//\n//   - Time is formatted in ISO8601 format (e.g. \"2017-01-01T12:00:00Z\").\n//   - Duration is formatted as a string (e.g. \"1.234s\").\n//\n// You may change these by setting the appropriate fields in the returned\n// object.\n// For example, use the following to change the time encoding format:\n//\n//\tcfg := zap.NewDevelopmentEncoderConfig()\n//\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder"},{"path":"config.go","start_line":217,"end_line":236,"code":"\n// NewDevelopmentConfig builds a reasonable default development logging\n// configuration.\n// Logging is enabled at DebugLevel and above, and uses a console encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of WarnLevel and above.\n// DPanicLevel logs will panic.\n//\n// See [NewDevelopmentEncoderConfig] for information\n// on the default encoder configuration.\nfunc NewDevelopmentConfig() Config {\n\treturn Config{\n\t\tLevel:            NewAtomicLevelAt(DebugLevel),\n\t\tDevelopment:      true,\n\t\tEncoding:         \"console\",\n\t\tEncoderConfig:    NewDevelopmentEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":null,"callers":[{"symbol":"NewDevelopmentConfig","path":"config.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"NewDevelopmentConfig","signature":"func NewDevelopmentConfig() Config","start_line":227,"end_line":236,"code":"func NewDevelopmentConfig() Config {\n\n\treturn Config{\n\t\tLevel:            NewAtomicLevelAt(DebugLevel),\n\t\tDevelopment:      true,\n\t\tEncoding:         \"console\",\n\t\tEncoderConfig:    NewDevelopmentEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}\n","neighbors":[{"path":"config.go","start_line":207,"end_line":226,"code":"\t\tFunctionKey:    zapcore.OmitKey,\n\t\tMessageKey:     \"M\",\n\t\tStacktraceKey:  \"S\",\n\t\tLineEnding:     zapcore.DefaultLineEnding,\n\t\tEncodeLevel:    zapcore.CapitalLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n\n// NewDevelopmentConfig builds a reasonable default development logging\n// configuration.\n// Logging is enabled at DebugLevel and above, and uses a console encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of WarnLevel and above.\n// DPanicLevel logs will panic.\n//\n// See [NewDevelopmentEncoderConfig] for information\n// on the default encoder configuration."},{"path":"config.go","start_line":237,"end_line":256,"code":"\n// Build constructs a logger from the Config and Options.\nfunc (cfg Config) Build(opts ...Option) (*Logger, error) {\n\tenc, err := cfg.buildEncoder()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsink, errSink, err := cfg.openSinks()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Level == (AtomicLevel{}) {\n\t\treturn nil, errors.New(\"missing Level\")\n\t}\n\n\tlog := New(\n\t\tzapcore.NewCore(enc, sink, cfg.Level),\n\t\tcfg.buildOptions(errSink)...,"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"NewAtomicLevelAt","path":"level.go"},{"symbol":"NewDevelopmentEncoderConfig","path":"config.go"}],"callers":[{"symbol":"NewDevelopment","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"(Config).Build","signature":"func (cfg Config) Build(opts ...Option) (*Logger, error)","start_line":239,"end_line":262,"code":"func (cfg Config) Build(opts ...Option) (*Logger, error) {\n\n\tenc, err := cfg.buildEncoder()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsink, errSink, err := cfg.openSinks()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Level == (AtomicLevel{}) {\n\t\treturn nil, errors.New(\"missing Level\")\n\t}\n\n\tlog := New(\n\t\tzapcore.NewCore(enc, sink, cfg.Level),\n\t\tcfg.buildOptions(errSink)...,\n\t)\n\tif len(opts) \u003e 0 {\n\t\tlog = log.WithOptions(opts...)\n\t}\n\treturn log, nil\n}\n","neighbors":[{"path":"config.go","start_line":219,"end_line":238,"code":"// configuration.\n// Logging is enabled at DebugLevel and above, and uses a console encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of WarnLevel and above.\n// DPanicLevel logs will panic.\n//\n// See [NewDevelopmentEncoderConfig] for information\n// on the default encoder configuration.\nfunc NewDevelopmentConfig() Config {\n\treturn Config{\n\t\tLevel:            NewAtomicLevelAt(DebugLevel),\n\t\tDevelopment:      true,\n\t\tEncoding:         \"console\",\n\t\tEncoderConfig:    NewDevelopmentEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}\n\n// Build constructs a logger from the Config and Options."},{"path":"config.go","start_line":263,"end_line":282,"code":"\nfunc (cfg Config) buildOptions(errSink zapcore.WriteSyncer) []Option {\n\topts := []Option{ErrorOutput(errSink)}\n\n\tif cfg.Development {\n\t\topts = append(opts, Development())\n\t}\n\n\tif !cfg.DisableCaller {\n\t\topts = append(opts, AddCaller())\n\t}\n\n\tstackLevel := ErrorLevel\n\tif cfg.Development {\n\t\tstackLevel = WarnLevel\n\t}\n\tif !cfg.DisableStacktrace {\n\t\topts = append(opts, AddStacktrace(stackLevel))\n\t}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"(Config).buildEncoder","path":"config.go"},{"symbol":"(Config).buildOptions","path":"config.go"},{"symbol":"(Config).openSinks","path":"config.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"New","path":"logger.go"},{"symbol":"NewCore","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Config).Build","path":"config.go"},{"symbol":"NewDevelopment","path":"logger.go"},{"symbol":"NewProduction","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"(Config).buildOptions","signature":"func (cfg Config) buildOptions(errSink zapcore.WriteSyncer) []Option","start_line":264,"end_line":313,"code":"func (cfg Config) buildOptions(errSink zapcore.WriteSyncer) []Option {\n\n\topts := []Option{ErrorOutput(errSink)}\n\n\tif cfg.Development {\n\t\topts = append(opts, Development())\n\t}\n\n\tif !cfg.DisableCaller {\n\t\topts = append(opts, AddCaller())\n\t}\n\n\tstackLevel := ErrorLevel\n\tif cfg.Development {\n\t\tstackLevel = WarnLevel\n\t}\n\tif !cfg.DisableStacktrace {\n\t\topts = append(opts, AddStacktrace(stackLevel))\n\t}\n\n\tif scfg := cfg.Sampling; scfg != nil {\n\t\topts = append(opts, WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\t\tvar samplerOpts []zapcore.SamplerOption\n\t\t\tif scfg.Hook != nil {\n\t\t\t\tsamplerOpts = append(samplerOpts, zapcore.SamplerHook(scfg.Hook))\n\t\t\t}\n\t\t\treturn zapcore.NewSamplerWithOptions(\n\t\t\t\tcore,\n\t\t\t\ttime.Second,\n\t\t\t\tcfg.Sampling.Initial,\n\t\t\t\tcfg.Sampling.Thereafter,\n\t\t\t\tsamplerOpts...,\n\t\t\t)\n\t\t}))\n\t}\n\n\tif len(cfg.InitialFields) \u003e 0 {\n\t\tfs := make([]Field, 0, len(cfg.InitialFields))\n\t\tkeys := make([]string, 0, len(cfg.InitialFields))\n\t\tfor k := range cfg.InitialFields {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\t\tfor _, k := range keys {\n\t\t\tfs = append(fs, Any(k, cfg.InitialFields[k]))\n\t\t}\n\t\topts = append(opts, Fields(fs...))\n\t}\n\n\treturn opts\n}\n","neighbors":[{"path":"config.go","start_line":244,"end_line":263,"code":"\n\tsink, errSink, err := cfg.openSinks()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Level == (AtomicLevel{}) {\n\t\treturn nil, errors.New(\"missing Level\")\n\t}\n\n\tlog := New(\n\t\tzapcore.NewCore(enc, sink, cfg.Level),\n\t\tcfg.buildOptions(errSink)...,\n\t)\n\tif len(opts) \u003e 0 {\n\t\tlog = log.WithOptions(opts...)\n\t}\n\treturn log, nil\n}\n"},{"path":"config.go","start_line":314,"end_line":331,"code":"\nfunc (cfg Config) openSinks() (zapcore.WriteSyncer, zapcore.WriteSyncer, error) {\n\tsink, closeOut, err := Open(cfg.OutputPaths...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\terrSink, _, err := Open(cfg.ErrorOutputPaths...)\n\tif err != nil {\n\t\tcloseOut()\n\t\treturn nil, nil, err\n\t}\n\treturn sink, errSink, nil\n}\n\nfunc (cfg Config) buildEncoder() (zapcore.Encoder, error) {\n\treturn newEncoder(cfg.Encoding, cfg.EncoderConfig)\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"AddCaller","path":"options.go"},{"symbol":"AddStacktrace","path":"options.go"},{"symbol":"Any","path":"field.go"},{"symbol":"Development","path":"options.go"},{"symbol":"ErrorOutput","path":"options.go"},{"symbol":"Fields","path":"options.go"},{"symbol":"Strings","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"WrapCore","path":"options.go"}],"callers":[{"symbol":"(*Config).buildOptions","path":"config.go"},{"symbol":"(Config).Build","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"(Config).openSinks","signature":"func (cfg Config) openSinks() (zapcore.WriteSyncer, zapcore.WriteSyncer, error)","start_line":315,"end_line":326,"code":"func (cfg Config) openSinks() (zapcore.WriteSyncer, zapcore.WriteSyncer, error) {\n\n\tsink, closeOut, err := Open(cfg.OutputPaths...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\terrSink, _, err := Open(cfg.ErrorOutputPaths...)\n\tif err != nil {\n\t\tcloseOut()\n\t\treturn nil, nil, err\n\t}\n\treturn sink, errSink, nil\n}\n","neighbors":[{"path":"config.go","start_line":295,"end_line":314,"code":"\t\t\t)\n\t\t}))\n\t}\n\n\tif len(cfg.InitialFields) \u003e 0 {\n\t\tfs := make([]Field, 0, len(cfg.InitialFields))\n\t\tkeys := make([]string, 0, len(cfg.InitialFields))\n\t\tfor k := range cfg.InitialFields {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\t\tfor _, k := range keys {\n\t\t\tfs = append(fs, Any(k, cfg.InitialFields[k]))\n\t\t}\n\t\topts = append(opts, Fields(fs...))\n\t}\n\n\treturn opts\n}\n"},{"path":"config.go","start_line":327,"end_line":331,"code":"\nfunc (cfg Config) buildEncoder() (zapcore.Encoder, error) {\n\treturn newEncoder(cfg.Encoding, cfg.EncoderConfig)\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*http2serverConn).onShutdownTimer","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"Open","path":"writer.go"},{"symbol":"Start$1","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"alloc$1","path":"../../../../usr/local/go/src/runtime/mheap.go"},{"symbol":"debugCallV2","path":"../../../../usr/local/go/src/runtime/debugcall.go"},{"symbol":"entersyscall","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"gcStart$4","path":"../../../../usr/local/go/src/runtime/mgc.go"},{"symbol":"init#2","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512block_arm64.go"},{"symbol":"initMimeUnix","path":"../../../../usr/local/go/src/mime/type_unix.go"},{"symbol":"libc_accept_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_fchown_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_lchown_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_mkdirat_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/at_darwin.go"},{"symbol":"libc_munlockall_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_sysconf_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/user_darwin.go"},{"symbol":"maybeRunAsync$1","path":"../../../../usr/local/go/src/runtime/time.go"},{"symbol":"netpollBreak","path":"../../../../usr/local/go/src/runtime/netpoll_kqueue.go"},{"symbol":"panicunsafeslicelen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"panicunsafestringlen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"racegoend","path":"../../../../usr/local/go/src/runtime/race0.go"},{"symbol":"read_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"restoreSIGSYS","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"secure","path":"../../../../usr/local/go/src/runtime/security_unix.go"},{"symbol":"sigpanic","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"sigprocmask_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"startTheWorld$1","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"syscall_runtime_AfterFork","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"write$2","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"x509_CFDictionaryGetValueIfPresent_trampoline","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/corefoundation.go"},{"symbol":"x509_CFErrorGetCode_trampoline","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/corefoundation.go"}],"callers":[{"symbol":"(*Config).openSinks","path":"config.go"},{"symbol":"(Config).Build","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"config.go","symbol":"(Config).buildEncoder","signature":"func (cfg Config) buildEncoder() (zapcore.Encoder, error)","start_line":328,"end_line":330,"code":"func (cfg Config) buildEncoder() (zapcore.Encoder, error) {\n\n\treturn newEncoder(cfg.Encoding, cfg.EncoderConfig)\n}\n","neighbors":[{"path":"config.go","start_line":308,"end_line":327,"code":"\t\t}\n\t\topts = append(opts, Fields(fs...))\n\t}\n\n\treturn opts\n}\n\nfunc (cfg Config) openSinks() (zapcore.WriteSyncer, zapcore.WriteSyncer, error) {\n\tsink, closeOut, err := Open(cfg.OutputPaths...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\terrSink, _, err := Open(cfg.ErrorOutputPaths...)\n\tif err != nil {\n\t\tcloseOut()\n\t\treturn nil, nil, err\n\t}\n\treturn sink, errSink, nil\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"newEncoder","path":"encoder.go"}],"callers":[{"symbol":"(*Config).buildEncoder","path":"config.go"},{"symbol":"(Config).Build","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"encoder.go","symbol":"RegisterEncoder","signature":"func RegisterEncoder(name string, constructor func(zapcore.EncoderConfig) (zapcore.Encoder, error)) error","start_line":51,"end_line":62,"code":"func RegisterEncoder(name string, constructor func(zapcore.EncoderConfig) (zapcore.Encoder, error)) error {\n\n\t_encoderMutex.Lock()\n\tdefer _encoderMutex.Unlock()\n\tif name == \"\" {\n\t\treturn errNoEncoderNameSpecified\n\t}\n\tif _, ok := _encoderNameToConstructor[name]; ok {\n\t\treturn fmt.Errorf(\"encoder already registered for name %q\", name)\n\t}\n\t_encoderNameToConstructor[name] = constructor\n\treturn nil\n}\n","neighbors":[{"path":"encoder.go","start_line":31,"end_line":50,"code":"var (\n\terrNoEncoderNameSpecified = errors.New(\"no encoder name specified\")\n\n\t_encoderNameToConstructor = map[string]func(zapcore.EncoderConfig) (zapcore.Encoder, error){\n\t\t\"console\": func(encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\t\t\treturn zapcore.NewConsoleEncoder(encoderConfig), nil\n\t\t},\n\t\t\"json\": func(encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\t\t\treturn zapcore.NewJSONEncoder(encoderConfig), nil\n\t\t},\n\t}\n\t_encoderMutex sync.RWMutex\n)\n\n// RegisterEncoder registers an encoder constructor, which the Config struct\n// can then reference. By default, the \"json\" and \"console\" encoders are\n// registered.\n//\n// Attempting to register an encoder whose name is already taken returns an\n// error."},{"path":"encoder.go","start_line":63,"end_line":80,"code":"\nfunc newEncoder(name string, encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\tif encoderConfig.TimeKey != \"\" \u0026\u0026 encoderConfig.EncodeTime == nil {\n\t\treturn nil, errors.New(\"missing EncodeTime in EncoderConfig\")\n\t}\n\n\t_encoderMutex.RLock()\n\tdefer _encoderMutex.RUnlock()\n\tif name == \"\" {\n\t\treturn nil, errNoEncoderNameSpecified\n\t}\n\tconstructor, ok := _encoderNameToConstructor[name]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no encoder registered for name %q\", name)\n\t}\n\treturn constructor(encoderConfig)\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"encoder.go","symbol":"newEncoder","signature":"func newEncoder(name string, encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error)","start_line":64,"end_line":79,"code":"func newEncoder(name string, encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\n\tif encoderConfig.TimeKey != \"\" \u0026\u0026 encoderConfig.EncodeTime == nil {\n\t\treturn nil, errors.New(\"missing EncodeTime in EncoderConfig\")\n\t}\n\n\t_encoderMutex.RLock()\n\tdefer _encoderMutex.RUnlock()\n\tif name == \"\" {\n\t\treturn nil, errNoEncoderNameSpecified\n\t}\n\tconstructor, ok := _encoderNameToConstructor[name]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no encoder registered for name %q\", name)\n\t}\n\treturn constructor(encoderConfig)\n}\n","neighbors":[{"path":"encoder.go","start_line":44,"end_line":63,"code":"\n// RegisterEncoder registers an encoder constructor, which the Config struct\n// can then reference. By default, the \"json\" and \"console\" encoders are\n// registered.\n//\n// Attempting to register an encoder whose name is already taken returns an\n// error.\nfunc RegisterEncoder(name string, constructor func(zapcore.EncoderConfig) (zapcore.Encoder, error)) error {\n\t_encoderMutex.Lock()\n\tdefer _encoderMutex.Unlock()\n\tif name == \"\" {\n\t\treturn errNoEncoderNameSpecified\n\t}\n\tif _, ok := _encoderNameToConstructor[name]; ok {\n\t\treturn fmt.Errorf(\"encoder already registered for name %q\", name)\n\t}\n\t_encoderNameToConstructor[name] = constructor\n\treturn nil\n}\n"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.55},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"init$1","path":"encoder.go"},{"symbol":"init$2","path":"encoder.go"}],"callers":[{"symbol":"(Config).buildEncoder","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"error.go","symbol":"Error","signature":"func Error(err error) Field","start_line":33,"end_line":35,"code":"func Error(err error) Field {\n\n\treturn NamedError(\"error\", err)\n}\n","neighbors":[{"path":"error.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"go.uber.org/zap/internal/pool\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Error is shorthand for the common idiom NamedError(\"error\", err)."},{"path":"error.go","start_line":36,"end_line":55,"code":"\n// NamedError constructs a field that lazily stores err.Error() under the\n// provided key. Errors which also implement fmt.Formatter (like those produced\n// by github.com/pkg/errors) will also have their verbose representation stored\n// under key+\"Verbose\". If passed a nil error, the field is a no-op.\n//\n// For the common case in which the key is simply \"error\", the Error function\n// is shorter and less repetitive.\nfunc NamedError(key string, err error) Field {\n\tif err == nil {\n\t\treturn Skip()\n\t}\n\treturn Field{Key: key, Type: zapcore.ErrorType, Interface: err}\n}\n\ntype errArray []error\n\nfunc (errs errArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range errs {\n\t\tif errs[i] == nil {"}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"NamedError","path":"error.go"}],"callers":[{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"error.go","symbol":"NamedError","signature":"func NamedError(key string, err error) Field","start_line":44,"end_line":49,"code":"func NamedError(key string, err error) Field {\n\n\tif err == nil {\n\t\treturn Skip()\n\t}\n\treturn Field{Key: key, Type: zapcore.ErrorType, Interface: err}\n}\n","neighbors":[{"path":"error.go","start_line":24,"end_line":43,"code":"\t\"go.uber.org/zap/internal/pool\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Error is shorthand for the common idiom NamedError(\"error\", err).\nfunc Error(err error) Field {\n\treturn NamedError(\"error\", err)\n}\n\n// NamedError constructs a field that lazily stores err.Error() under the\n// provided key. Errors which also implement fmt.Formatter (like those produced\n// by github.com/pkg/errors) will also have their verbose representation stored\n// under key+\"Verbose\". If passed a nil error, the field is a no-op.\n//\n// For the common case in which the key is simply \"error\", the Error function\n// is shorter and less repetitive."},{"path":"error.go","start_line":50,"end_line":69,"code":"\ntype errArray []error\n\nfunc (errs errArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range errs {\n\t\tif errs[i] == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// To represent each error as an object with an \"error\" attribute and\n\t\t// potentially an \"errorVerbose\" attribute, we need to wrap it in a\n\t\t// type that implements LogObjectMarshaler. To prevent this from\n\t\t// allocating, pool the wrapper type.\n\t\telem := _errArrayElemPool.Get()\n\t\telem.error = errs[i]\n\t\terr := arr.AppendObject(elem)\n\t\telem.error = nil\n\t\t_errArrayElemPool.Put(elem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":[{"symbol":"Skip","path":"field.go"}],"callers":[{"symbol":"Error","path":"error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"error.go","symbol":"(errArray).MarshalLogArray","signature":"func (errs errArray) MarshalLogArray(arr zapcore.ArrayEncoder) error","start_line":53,"end_line":72,"code":"func (errs errArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\n\tfor i := range errs {\n\t\tif errs[i] == nil {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\telem := _errArrayElemPool.Get()\n\t\telem.error = errs[i]\n\t\terr := arr.AppendObject(elem)\n\t\telem.error = nil\n\t\t_errArrayElemPool.Put(elem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"error.go","start_line":33,"end_line":52,"code":"func Error(err error) Field {\n\treturn NamedError(\"error\", err)\n}\n\n// NamedError constructs a field that lazily stores err.Error() under the\n// provided key. Errors which also implement fmt.Formatter (like those produced\n// by github.com/pkg/errors) will also have their verbose representation stored\n// under key+\"Verbose\". If passed a nil error, the field is a no-op.\n//\n// For the common case in which the key is simply \"error\", the Error function\n// is shorter and less repetitive.\nfunc NamedError(key string, err error) Field {\n\tif err == nil {\n\t\treturn Skip()\n\t}\n\treturn Field{Key: key, Type: zapcore.ErrorType, Interface: err}\n}\n\ntype errArray []error\n"},{"path":"error.go","start_line":73,"end_line":83,"code":"\ntype errArrayElem struct {\n\terror\n}\n\nfunc (e *errArrayElem) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\t// Re-use the error field's logic, which supports non-standard error types.\n\tError(e.error).AddTo(enc)\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Pool).Get[*go.uber.org/zap.errArrayElem]","path":"internal/pool/pool.go"},{"symbol":"(*Pool).Put[*go.uber.org/zap.errArrayElem]","path":"internal/pool/pool.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*errArray).MarshalLogArray","path":"error.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"error.go","symbol":"(*errArrayElem).MarshalLogObject","signature":"func (e *errArrayElem) MarshalLogObject(enc zapcore.ObjectEncoder) error","start_line":78,"end_line":82,"code":"func (e *errArrayElem) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\n\t\n\tError(e.error).AddTo(enc)\n\treturn nil\n}\n","neighbors":[{"path":"error.go","start_line":58,"end_line":77,"code":"\t\t// To represent each error as an object with an \"error\" attribute and\n\t\t// potentially an \"errorVerbose\" attribute, we need to wrap it in a\n\t\t// type that implements LogObjectMarshaler. To prevent this from\n\t\t// allocating, pool the wrapper type.\n\t\telem := _errArrayElemPool.Get()\n\t\telem.error = errs[i]\n\t\terr := arr.AppendObject(elem)\n\t\telem.error = nil\n\t\t_errArrayElemPool.Put(elem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype errArrayElem struct {\n\terror\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"encodeError","path":"zapcore/error.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Skip","signature":"func Skip() Field","start_line":43,"end_line":45,"code":"func Skip() Field {\n\n\treturn Field{Type: zapcore.SkipType}\n}\n","neighbors":[{"path":"field.go","start_line":23,"end_line":42,"code":"import (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/stacktrace\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Field is an alias for Field. Aliasing this type dramatically\n// improves the navigability of this package's API documentation.\ntype Field = zapcore.Field\n\nvar (\n\t_minTimeInt64 = time.Unix(0, math.MinInt64)\n\t_maxTimeInt64 = time.Unix(0, math.MaxInt64)\n)\n\n// Skip constructs a no-op field, which is often useful when handling invalid\n// inputs in other Field constructors."},{"path":"field.go","start_line":46,"end_line":65,"code":"\n// nilField returns a field which will marshal explicitly as nil. See motivation\n// in https://github.com/uber-go/zap/issues/753 . If we ever make breaking\n// changes and add zapcore.NilType and zapcore.ObjectEncoder.AddNil, the\n// implementation here should be changed to reflect that.\nfunc nilField(key string) Field { return Reflect(key, nil) }\n\n// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString.\nfunc Binary(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n\n// Bool constructs a field that carries a bool.\nfunc Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"NamedError","path":"error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"nilField","signature":"func nilField(key string) Field","start_line":51,"end_line":51,"code":"func nilField(key string) Field {\n return Reflect(key, nil) }\n","neighbors":[{"path":"field.go","start_line":31,"end_line":50,"code":"\n// Field is an alias for Field. Aliasing this type dramatically\n// improves the navigability of this package's API documentation.\ntype Field = zapcore.Field\n\nvar (\n\t_minTimeInt64 = time.Unix(0, math.MinInt64)\n\t_maxTimeInt64 = time.Unix(0, math.MaxInt64)\n)\n\n// Skip constructs a no-op field, which is often useful when handling invalid\n// inputs in other Field constructors.\nfunc Skip() Field {\n\treturn Field{Type: zapcore.SkipType}\n}\n\n// nilField returns a field which will marshal explicitly as nil. See motivation\n// in https://github.com/uber-go/zap/issues/753 . If we ever make breaking\n// changes and add zapcore.NilType and zapcore.ObjectEncoder.AddNil, the\n// implementation here should be changed to reflect that."},{"path":"field.go","start_line":52,"end_line":71,"code":"\n// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString.\nfunc Binary(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n\n// Bool constructs a field that carries a bool.\nfunc Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n\n// Boolp constructs a field that carries a *bool. The returned Field will safely"}],"selection":{"visibility":"unexported","reason":"other","score":0.48},"call_graph":{"callees":[{"symbol":"Reflect","path":"field.go"}],"callers":[{"symbol":"Boolp","path":"field.go"},{"symbol":"Complex128p","path":"field.go"},{"symbol":"Complex64p","path":"field.go"},{"symbol":"Durationp","path":"field.go"},{"symbol":"Float32p","path":"field.go"},{"symbol":"Float64p","path":"field.go"},{"symbol":"Int16p","path":"field.go"},{"symbol":"Int32p","path":"field.go"},{"symbol":"Int64p","path":"field.go"},{"symbol":"Int8p","path":"field.go"},{"symbol":"Intp","path":"field.go"},{"symbol":"Object","path":"field.go"},{"symbol":"Stringp","path":"field.go"},{"symbol":"Timep","path":"field.go"},{"symbol":"Uint16p","path":"field.go"},{"symbol":"Uint32p","path":"field.go"},{"symbol":"Uint64p","path":"field.go"},{"symbol":"Uint8p","path":"field.go"},{"symbol":"Uintp","path":"field.go"},{"symbol":"Uintptrp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Binary","signature":"func Binary(key string, val []byte) Field","start_line":58,"end_line":60,"code":"func Binary(key string, val []byte) Field {\n\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":38,"end_line":57,"code":"\t_maxTimeInt64 = time.Unix(0, math.MaxInt64)\n)\n\n// Skip constructs a no-op field, which is often useful when handling invalid\n// inputs in other Field constructors.\nfunc Skip() Field {\n\treturn Field{Type: zapcore.SkipType}\n}\n\n// nilField returns a field which will marshal explicitly as nil. See motivation\n// in https://github.com/uber-go/zap/issues/753 . If we ever make breaking\n// changes and add zapcore.NilType and zapcore.ObjectEncoder.AddNil, the\n// implementation here should be changed to reflect that.\nfunc nilField(key string) Field { return Reflect(key, nil) }\n\n// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString."},{"path":"field.go","start_line":61,"end_line":80,"code":"\n// Bool constructs a field that carries a bool.\nfunc Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Boolp(key string, val *bool) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Bool","signature":"func Bool(key string, val bool) Field","start_line":63,"end_line":69,"code":"func Bool(key string, val bool) Field {\n\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n","neighbors":[{"path":"field.go","start_line":43,"end_line":62,"code":"func Skip() Field {\n\treturn Field{Type: zapcore.SkipType}\n}\n\n// nilField returns a field which will marshal explicitly as nil. See motivation\n// in https://github.com/uber-go/zap/issues/753 . If we ever make breaking\n// changes and add zapcore.NilType and zapcore.ObjectEncoder.AddNil, the\n// implementation here should be changed to reflect that.\nfunc nilField(key string) Field { return Reflect(key, nil) }\n\n// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString.\nfunc Binary(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n\n// Bool constructs a field that carries a bool."},{"path":"field.go","start_line":70,"end_line":89,"code":"\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Boolp(key string, val *bool) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary.\nfunc ByteString(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{})."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"Boolp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Boolp","signature":"func Boolp(key string, val *bool) Field","start_line":73,"end_line":78,"code":"func Boolp(key string, val *bool) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":53,"end_line":72,"code":"// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString.\nfunc Binary(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n\n// Bool constructs a field that carries a bool.\nfunc Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":79,"end_line":98,"code":"\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary.\nfunc ByteString(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{}).\nfunc Complex128(key string, val complex128) Field {\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Bool","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"ByteString","signature":"func ByteString(key string, val []byte) Field","start_line":83,"end_line":85,"code":"func ByteString(key string, val []byte) Field {\n\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":63,"end_line":82,"code":"func Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Boolp(key string, val *bool) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary."},{"path":"field.go","start_line":86,"end_line":105,"code":"\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{}).\nfunc Complex128(key string, val complex128) Field {\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{})."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Complex128","signature":"func Complex128(key string, val complex128) Field","start_line":90,"end_line":92,"code":"func Complex128(key string, val complex128) Field {\n\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":70,"end_line":89,"code":"\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Boolp(key string, val *bool) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary.\nfunc ByteString(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{})."},{"path":"field.go","start_line":93,"end_line":112,"code":"\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{}).\nfunc Complex64(key string, val complex64) Field {\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Complex128p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Complex128p","signature":"func Complex128p(key string, val *complex128) Field","start_line":96,"end_line":101,"code":"func Complex128p(key string, val *complex128) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":76,"end_line":95,"code":"\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary.\nfunc ByteString(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{}).\nfunc Complex128(key string, val complex128) Field {\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":102,"end_line":121,"code":"\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{}).\nfunc Complex64(key string, val complex64) Field {\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Complex128","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Complex64","signature":"func Complex64(key string, val complex64) Field","start_line":106,"end_line":108,"code":"func Complex64(key string, val complex64) Field {\n\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":86,"end_line":105,"code":"\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{}).\nfunc Complex128(key string, val complex128) Field {\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{})."},{"path":"field.go","start_line":109,"end_line":128,"code":"\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float64(key string, val float64) Field {\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Complex64p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Complex64p","signature":"func Complex64p(key string, val *complex64) Field","start_line":112,"end_line":117,"code":"func Complex64p(key string, val *complex64) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":92,"end_line":111,"code":"}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{}).\nfunc Complex64(key string, val complex64) Field {\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":118,"end_line":137,"code":"\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float64(key string, val float64) Field {\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Complex64","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Float64","signature":"func Float64(key string, val float64) Field","start_line":122,"end_line":124,"code":"func Float64(key string, val float64) Field {\n\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n","neighbors":[{"path":"field.go","start_line":102,"end_line":121,"code":"\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{}).\nfunc Complex64(key string, val complex64) Field {\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy."},{"path":"field.go","start_line":125,"end_line":144,"code":"\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Float64bits","path":"../../../../usr/local/go/src/math/unsafe.go"}],"callers":[{"symbol":"Float64p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Float64p","signature":"func Float64p(key string, val *float64) Field","start_line":128,"end_line":133,"code":"func Float64p(key string, val *float64) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":108,"end_line":127,"code":"}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float64(key string, val float64) Field {\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":134,"end_line":153,"code":"\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Float64","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Float32","signature":"func Float32(key string, val float32) Field","start_line":138,"end_line":140,"code":"func Float32(key string, val float32) Field {\n\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n","neighbors":[{"path":"field.go","start_line":118,"end_line":137,"code":"\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float64(key string, val float64) Field {\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy."},{"path":"field.go","start_line":141,"end_line":160,"code":"\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Float32bits","path":"../../../../usr/local/go/src/math/unsafe.go"}],"callers":[{"symbol":"Float32p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Float32p","signature":"func Float32p(key string, val *float32) Field","start_line":144,"end_line":149,"code":"func Float32p(key string, val *float32) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":124,"end_line":143,"code":"}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":150,"end_line":169,"code":"\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Float32","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int","signature":"func Int(key string, val int) Field","start_line":152,"end_line":154,"code":"func Int(key string, val int) Field {\n\n\treturn Int64(key, int64(val))\n}\n","neighbors":[{"path":"field.go","start_line":132,"end_line":151,"code":"\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value."},{"path":"field.go","start_line":155,"end_line":174,"code":"\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Int64","path":"field.go"}],"callers":[{"symbol":"Intp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Intp","signature":"func Intp(key string, val *int) Field","start_line":158,"end_line":163,"code":"func Intp(key string, val *int) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":138,"end_line":157,"code":"func Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":164,"end_line":183,"code":"\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Int","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int64","signature":"func Int64(key string, val int64) Field","start_line":166,"end_line":168,"code":"func Int64(key string, val int64) Field {\n\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n","neighbors":[{"path":"field.go","start_line":146,"end_line":165,"code":"\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value."},{"path":"field.go","start_line":169,"end_line":188,"code":"\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":null,"callers":[{"symbol":"Int","path":"field.go"},{"symbol":"Int64p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int64p","signature":"func Int64p(key string, val *int64) Field","start_line":172,"end_line":177,"code":"func Int64p(key string, val *int64) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":152,"end_line":171,"code":"func Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":178,"end_line":197,"code":"\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Int64","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int32","signature":"func Int32(key string, val int32) Field","start_line":180,"end_line":182,"code":"func Int32(key string, val int32) Field {\n\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":160,"end_line":179,"code":"\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value."},{"path":"field.go","start_line":183,"end_line":202,"code":"\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Int32p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int32p","signature":"func Int32p(key string, val *int32) Field","start_line":186,"end_line":191,"code":"func Int32p(key string, val *int32) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":166,"end_line":185,"code":"func Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":192,"end_line":211,"code":"\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Int32","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int16","signature":"func Int16(key string, val int16) Field","start_line":194,"end_line":196,"code":"func Int16(key string, val int16) Field {\n\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":174,"end_line":193,"code":"\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value."},{"path":"field.go","start_line":197,"end_line":216,"code":"\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Int16p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int16p","signature":"func Int16p(key string, val *int16) Field","start_line":200,"end_line":205,"code":"func Int16p(key string, val *int16) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":180,"end_line":199,"code":"func Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":206,"end_line":225,"code":"\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Int16","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int8","signature":"func Int8(key string, val int8) Field","start_line":208,"end_line":210,"code":"func Int8(key string, val int8) Field {\n\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":188,"end_line":207,"code":"\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value."},{"path":"field.go","start_line":211,"end_line":230,"code":"\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Int8p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Int8p","signature":"func Int8p(key string, val *int8) Field","start_line":214,"end_line":219,"code":"func Int8p(key string, val *int8) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":194,"end_line":213,"code":"func Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":220,"end_line":239,"code":"\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Int8","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"String","signature":"func String(key string, val string) Field","start_line":222,"end_line":224,"code":"func String(key string, val string) Field {\n\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n","neighbors":[{"path":"field.go","start_line":202,"end_line":221,"code":"\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value."},{"path":"field.go","start_line":225,"end_line":244,"code":"\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.68},"call_graph":{"callees":null,"callers":[{"symbol":"StackSkip","path":"field.go"},{"symbol":"Stringp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Stringp","signature":"func Stringp(key string, val *string) Field","start_line":228,"end_line":233,"code":"func Stringp(key string, val *string) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":208,"end_line":227,"code":"func Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":234,"end_line":253,"code":"\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"String","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint","signature":"func Uint(key string, val uint) Field","start_line":236,"end_line":238,"code":"func Uint(key string, val uint) Field {\n\n\treturn Uint64(key, uint64(val))\n}\n","neighbors":[{"path":"field.go","start_line":216,"end_line":235,"code":"\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value."},{"path":"field.go","start_line":239,"end_line":258,"code":"\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"Uint64","path":"field.go"}],"callers":[{"symbol":"Uintp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uintp","signature":"func Uintp(key string, val *uint) Field","start_line":242,"end_line":247,"code":"func Uintp(key string, val *uint) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":222,"end_line":241,"code":"func String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":248,"end_line":267,"code":"\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uint","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint64","signature":"func Uint64(key string, val uint64) Field","start_line":250,"end_line":252,"code":"func Uint64(key string, val uint64) Field {\n\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":230,"end_line":249,"code":"\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value."},{"path":"field.go","start_line":253,"end_line":272,"code":"\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":null,"callers":[{"symbol":"Uint","path":"field.go"},{"symbol":"Uint64p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint64p","signature":"func Uint64p(key string, val *uint64) Field","start_line":256,"end_line":261,"code":"func Uint64p(key string, val *uint64) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":236,"end_line":255,"code":"func Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":262,"end_line":281,"code":"\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uint64","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint32","signature":"func Uint32(key string, val uint32) Field","start_line":264,"end_line":266,"code":"func Uint32(key string, val uint32) Field {\n\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":244,"end_line":263,"code":"\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value."},{"path":"field.go","start_line":267,"end_line":286,"code":"\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Uint32p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint32p","signature":"func Uint32p(key string, val *uint32) Field","start_line":270,"end_line":275,"code":"func Uint32p(key string, val *uint32) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":250,"end_line":269,"code":"func Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":276,"end_line":295,"code":"\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uint32","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint16","signature":"func Uint16(key string, val uint16) Field","start_line":278,"end_line":280,"code":"func Uint16(key string, val uint16) Field {\n\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":258,"end_line":277,"code":"\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value."},{"path":"field.go","start_line":281,"end_line":300,"code":"\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Uint16p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint16p","signature":"func Uint16p(key string, val *uint16) Field","start_line":284,"end_line":289,"code":"func Uint16p(key string, val *uint16) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":264,"end_line":283,"code":"func Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":290,"end_line":309,"code":"\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n\n// Uintptr constructs a field with the given key and value.\nfunc Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uint16","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint8","signature":"func Uint8(key string, val uint8) Field","start_line":292,"end_line":294,"code":"func Uint8(key string, val uint8) Field {\n\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":272,"end_line":291,"code":"\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value."},{"path":"field.go","start_line":295,"end_line":314,"code":"\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n\n// Uintptr constructs a field with the given key and value.\nfunc Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintptrp(key string, val *uintptr) Field {\n\tif val == nil {\n\t\treturn nilField(key)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Uint8p","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uint8p","signature":"func Uint8p(key string, val *uint8) Field","start_line":298,"end_line":303,"code":"func Uint8p(key string, val *uint8) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":278,"end_line":297,"code":"func Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":304,"end_line":323,"code":"\n// Uintptr constructs a field with the given key and value.\nfunc Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintptrp(key string, val *uintptr) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uintptr(key, *val)\n}\n\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uint8","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uintptr","signature":"func Uintptr(key string, val uintptr) Field","start_line":306,"end_line":308,"code":"func Uintptr(key string, val uintptr) Field {\n\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":286,"end_line":305,"code":"\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n\n// Uintptr constructs a field with the given key and value."},{"path":"field.go","start_line":309,"end_line":328,"code":"\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintptrp(key string, val *uintptr) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uintptr(key, *val)\n}\n\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output.\nfunc Reflect(key string, val interface{}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"Uintptrp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Uintptrp","signature":"func Uintptrp(key string, val *uintptr) Field","start_line":312,"end_line":317,"code":"func Uintptrp(key string, val *uintptr) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uintptr(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":292,"end_line":311,"code":"func Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n\n// Uintptr constructs a field with the given key and value.\nfunc Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":318,"end_line":337,"code":"\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output.\nfunc Reflect(key string, val interface{}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries.\nfunc Namespace(key string) Field {\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Uintptr","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Reflect","signature":"func Reflect(key string, val interface{}) Field","start_line":326,"end_line":328,"code":"func Reflect(key string, val interface{\n}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":306,"end_line":325,"code":"func Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintptrp(key string, val *uintptr) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uintptr(key, *val)\n}\n\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output."},{"path":"field.go","start_line":329,"end_line":348,"code":"\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries.\nfunc Namespace(key string) Field {\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily.\nfunc Stringer(key string, val fmt.Stringer) Field {\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized.\nfunc Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"nilField","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Namespace","signature":"func Namespace(key string) Field","start_line":335,"end_line":337,"code":"func Namespace(key string) Field {\n\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n","neighbors":[{"path":"field.go","start_line":315,"end_line":334,"code":"\t}\n\treturn Uintptr(key, *val)\n}\n\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output.\nfunc Reflect(key string, val interface{}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries."},{"path":"field.go","start_line":338,"end_line":357,"code":"\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily.\nfunc Stringer(key string, val fmt.Stringer) Field {\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized.\nfunc Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Stringer","signature":"func Stringer(key string, val fmt.Stringer) Field","start_line":341,"end_line":343,"code":"func Stringer(key string, val fmt.Stringer) Field {\n\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":321,"end_line":340,"code":"// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output.\nfunc Reflect(key string, val interface{}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries.\nfunc Namespace(key string) Field {\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily."},{"path":"field.go","start_line":344,"end_line":363,"code":"\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized.\nfunc Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n\n// Stack constructs a field that stores a stacktrace of the current goroutine"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Time","signature":"func Time(key string, val time.Time) Field","start_line":347,"end_line":352,"code":"func Time(key string, val time.Time) Field {\n\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n","neighbors":[{"path":"field.go","start_line":327,"end_line":346,"code":"\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries.\nfunc Namespace(key string) Field {\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily.\nfunc Stringer(key string, val fmt.Stringer) Field {\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized."},{"path":"field.go","start_line":353,"end_line":372,"code":"\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n\n// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds.\nfunc Stack(key string) Field {\n\treturn StackSkip(key, 1) // skip Stack\n}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(Time).After","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Time).Before","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Time).Location","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"Timep","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Timep","signature":"func Timep(key string, val *time.Time) Field","start_line":356,"end_line":361,"code":"func Timep(key string, val *time.Time) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":336,"end_line":355,"code":"\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily.\nfunc Stringer(key string, val fmt.Stringer) Field {\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized.\nfunc Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":362,"end_line":381,"code":"\n// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds.\nfunc Stack(key string) Field {\n\treturn StackSkip(key, 1) // skip Stack\n}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace.\nfunc StackSkip(key string, skip int) Field {\n\t// Returning the stacktrace as a string costs an allocation, but saves us\n\t// from expanding the zapcore.Field union struct to include a byte slice. Since\n\t// taking a stacktrace is already so expensive (~10us), the extra allocation\n\t// is okay.\n\treturn String(key, stacktrace.Take(skip+1)) // skip StackSkip\n}\n\n// Duration constructs a field with the given key and value. The encoder"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Time","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Stack","signature":"func Stack(key string) Field","start_line":367,"end_line":369,"code":"func Stack(key string) Field {\n\n\treturn StackSkip(key, 1) \n}\n","neighbors":[{"path":"field.go","start_line":347,"end_line":366,"code":"func Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n\n// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds."},{"path":"field.go","start_line":370,"end_line":389,"code":"\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace.\nfunc StackSkip(key string, skip int) Field {\n\t// Returning the stacktrace as a string costs an allocation, but saves us\n\t// from expanding the zapcore.Field union struct to include a byte slice. Since\n\t// taking a stacktrace is already so expensive (~10us), the extra allocation\n\t// is okay.\n\treturn String(key, stacktrace.Take(skip+1)) // skip StackSkip\n}\n\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized.\nfunc Duration(key string, val time.Duration) Field {\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Durationp(key string, val *time.Duration) Field {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"StackSkip","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"StackSkip","signature":"func StackSkip(key string, skip int) Field","start_line":373,"end_line":379,"code":"func StackSkip(key string, skip int) Field {\n\n\t\n\t\n\t\n\t\n\treturn String(key, stacktrace.Take(skip+1)) \n}\n","neighbors":[{"path":"field.go","start_line":353,"end_line":372,"code":"\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n\n// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds.\nfunc Stack(key string) Field {\n\treturn StackSkip(key, 1) // skip Stack\n}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace."},{"path":"field.go","start_line":380,"end_line":399,"code":"\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized.\nfunc Duration(key string, val time.Duration) Field {\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Durationp(key string, val *time.Duration) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"String","path":"field.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"}],"callers":[{"symbol":"Stack","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Duration","signature":"func Duration(key string, val time.Duration) Field","start_line":383,"end_line":385,"code":"func Duration(key string, val time.Duration) Field {\n\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n","neighbors":[{"path":"field.go","start_line":363,"end_line":382,"code":"// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds.\nfunc Stack(key string) Field {\n\treturn StackSkip(key, 1) // skip Stack\n}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace.\nfunc StackSkip(key string, skip int) Field {\n\t// Returning the stacktrace as a string costs an allocation, but saves us\n\t// from expanding the zapcore.Field union struct to include a byte slice. Since\n\t// taking a stacktrace is already so expensive (~10us), the extra allocation\n\t// is okay.\n\treturn String(key, stacktrace.Take(skip+1)) // skip StackSkip\n}\n\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized."},{"path":"field.go","start_line":386,"end_line":405,"code":"\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Durationp(key string, val *time.Duration) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily.\nfunc Object(key string, val zapcore.ObjectMarshaler) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":null,"callers":[{"symbol":"Durationp","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Durationp","signature":"func Durationp(key string, val *time.Duration) Field","start_line":389,"end_line":394,"code":"func Durationp(key string, val *time.Duration) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n","neighbors":[{"path":"field.go","start_line":369,"end_line":388,"code":"}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace.\nfunc StackSkip(key string, skip int) Field {\n\t// Returning the stacktrace as a string costs an allocation, but saves us\n\t// from expanding the zapcore.Field union struct to include a byte slice. Since\n\t// taking a stacktrace is already so expensive (~10us), the extra allocation\n\t// is okay.\n\treturn String(key, stacktrace.Take(skip+1)) // skip StackSkip\n}\n\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized.\nfunc Duration(key string, val time.Duration) Field {\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate."},{"path":"field.go","start_line":395,"end_line":414,"code":"\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily.\nfunc Object(key string, val zapcore.ObjectMarshaler) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace.\nfunc Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Duration","path":"field.go"},{"symbol":"nilField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Object","signature":"func Object(key string, val zapcore.ObjectMarshaler) Field","start_line":400,"end_line":405,"code":"func Object(key string, val zapcore.ObjectMarshaler) Field {\n\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n","neighbors":[{"path":"field.go","start_line":380,"end_line":399,"code":"\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized.\nfunc Duration(key string, val time.Duration) Field {\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Durationp(key string, val *time.Duration) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily."},{"path":"field.go","start_line":406,"end_line":425,"code":"\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace.\nfunc Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments.\nfunc Dict(key string, val ...Field) Field {\n\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"nilField","path":"field.go"}],"callers":[{"symbol":"dictField","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Inline","signature":"func Inline(val zapcore.ObjectMarshaler) Field","start_line":410,"end_line":415,"code":"func Inline(val zapcore.ObjectMarshaler) Field {\n\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n","neighbors":[{"path":"field.go","start_line":390,"end_line":409,"code":"\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily.\nfunc Object(key string, val zapcore.ObjectMarshaler) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace."},{"path":"field.go","start_line":416,"end_line":435,"code":"\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments.\nfunc Dict(key string, val ...Field) Field {\n\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))\n}\n\ntype dictObject []Field\n\nfunc (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Dict","signature":"func Dict(key string, val ...Field) Field","start_line":419,"end_line":421,"code":"func Dict(key string, val ...Field) Field {\n\n\treturn dictField(key, val)\n}\n","neighbors":[{"path":"field.go","start_line":399,"end_line":418,"code":"// MarshalLogObject method is called lazily.\nfunc Object(key string, val zapcore.ObjectMarshaler) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace.\nfunc Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments."},{"path":"field.go","start_line":422,"end_line":441,"code":"\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))\n}\n\ntype dictObject []Field\n\nfunc (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}\n\n// DictObject constructs a [zapcore.ObjectMarshaler] with the given list of fields.\n// The resulting object marshaler can be used as input to [Object], [Objects], or\n// any other functions that expect an object marshaler.\nfunc DictObject(val ...Field) zapcore.ObjectMarshaler {\n\treturn dictObject(val)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"dictField","path":"field.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"dictField","signature":"func dictField(key string, val []Field) Field","start_line":424,"end_line":426,"code":"func dictField(key string, val []Field) Field {\n\n\treturn Object(key, dictObject(val))\n}\n","neighbors":[{"path":"field.go","start_line":404,"end_line":423,"code":"\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace.\nfunc Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments.\nfunc Dict(key string, val ...Field) Field {\n\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any."},{"path":"field.go","start_line":427,"end_line":446,"code":"\ntype dictObject []Field\n\nfunc (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}\n\n// DictObject constructs a [zapcore.ObjectMarshaler] with the given list of fields.\n// The resulting object marshaler can be used as input to [Object], [Objects], or\n// any other functions that expect an object marshaler.\nfunc DictObject(val ...Field) zapcore.ObjectMarshaler {\n\treturn dictObject(val)\n}\n\n// We discovered an issue where zap.Any can cause a performance degradation\n// when used in new goroutines.\n//"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"Object","path":"field.go"}],"callers":[{"symbol":"Dict","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"(dictObject).MarshalLogObject","signature":"func (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error","start_line":430,"end_line":435,"code":"func (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"field.go","start_line":410,"end_line":429,"code":"func Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments.\nfunc Dict(key string, val ...Field) Field {\n\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))\n}\n\ntype dictObject []Field\n"},{"path":"field.go","start_line":436,"end_line":455,"code":"\n// DictObject constructs a [zapcore.ObjectMarshaler] with the given list of fields.\n// The resulting object marshaler can be used as input to [Object], [Objects], or\n// any other functions that expect an object marshaler.\nfunc DictObject(val ...Field) zapcore.ObjectMarshaler {\n\treturn dictObject(val)\n}\n\n// We discovered an issue where zap.Any can cause a performance degradation\n// when used in new goroutines.\n//\n// This happens because the compiler assigns 4.8kb (one zap.Field per arm of\n// switch statement) of stack space for zap.Any when it takes the form:\n//\n//\tswitch v := v.(type) {\n//\tcase string:\n//\t\treturn String(key, v)\n//\tcase int:\n//\t\treturn Int(key, v)\n//\t\t// ..."}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"DictObject","signature":"func DictObject(val ...Field) zapcore.ObjectMarshaler","start_line":440,"end_line":442,"code":"func DictObject(val ...Field) zapcore.ObjectMarshaler {\n\n\treturn dictObject(val)\n}\n","neighbors":[{"path":"field.go","start_line":420,"end_line":439,"code":"\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))\n}\n\ntype dictObject []Field\n\nfunc (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}\n\n// DictObject constructs a [zapcore.ObjectMarshaler] with the given list of fields.\n// The resulting object marshaler can be used as input to [Object], [Objects], or\n// any other functions that expect an object marshaler."},{"path":"field.go","start_line":443,"end_line":462,"code":"\n// We discovered an issue where zap.Any can cause a performance degradation\n// when used in new goroutines.\n//\n// This happens because the compiler assigns 4.8kb (one zap.Field per arm of\n// switch statement) of stack space for zap.Any when it takes the form:\n//\n//\tswitch v := v.(type) {\n//\tcase string:\n//\t\treturn String(key, v)\n//\tcase int:\n//\t\treturn Int(key, v)\n//\t\t// ...\n//\tdefault:\n//\t\treturn Reflect(key, v)\n//\t}\n//\n// To avoid this, we use the type switch to assign a value to a single local variable\n// and then call a function on it.\n// The local variable is just a function reference so it doesn't allocate"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"(anyFieldC[T]).Any","signature":"func (f anyFieldC[T]) Any(key string, val any) Field","start_line":477,"end_line":481,"code":"func (f anyFieldC[T]) Any(key string, val any) Field {\n\n\tv, _ := val.(T)\n\t\n\treturn f(key, v)\n}\n","neighbors":[{"path":"field.go","start_line":457,"end_line":476,"code":"//\t\treturn Reflect(key, v)\n//\t}\n//\n// To avoid this, we use the type switch to assign a value to a single local variable\n// and then call a function on it.\n// The local variable is just a function reference so it doesn't allocate\n// when converted to an interface{}.\n//\n// A fair bit of experimentation went into this.\n// See also:\n//\n// - https://github.com/uber-go/zap/pull/1301\n// - https://github.com/uber-go/zap/pull/1303\n// - https://github.com/uber-go/zap/pull/1304\n// - https://github.com/uber-go/zap/pull/1305\n// - https://github.com/uber-go/zap/pull/1308\n//\n// See https://github.com/golang/go/issues/62077 for upstream issue.\ntype anyFieldC[T any] func(string, T) Field\n"},{"path":"field.go","start_line":482,"end_line":501,"code":"\n// Any takes a key and an arbitrary value and chooses the best way to represent\n// them as a field, falling back to a reflection-based approach only if\n// necessary.\n//\n// Since byte/uint8 and rune/int32 are aliases, Any can't differentiate between\n// them. To minimize surprises, []byte values are treated as binary blobs, byte\n// values are treated as uint8, and runes are always treated as integers.\nfunc Any(key string, value interface{}) Field {\n\tvar c interface{ Any(string, any) Field }\n\n\tswitch value.(type) {\n\tcase zapcore.ObjectMarshaler:\n\t\tc = anyFieldC[zapcore.ObjectMarshaler](Object)\n\tcase zapcore.ArrayMarshaler:\n\t\tc = anyFieldC[zapcore.ArrayMarshaler](Array)\n\tcase []Field:\n\t\tc = anyFieldC[[]Field](dictField)\n\tcase bool:\n\t\tc = anyFieldC[bool](Bool)"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"field.go","symbol":"Any","signature":"func Any(key string, value interface{}) Field","start_line":490,"end_line":625,"code":"func Any(key string, value interface{\n}) Field {\n\tvar c interface{ Any(string, any) Field }\n\n\tswitch value.(type) {\n\tcase zapcore.ObjectMarshaler:\n\t\tc = anyFieldC[zapcore.ObjectMarshaler](Object)\n\tcase zapcore.ArrayMarshaler:\n\t\tc = anyFieldC[zapcore.ArrayMarshaler](Array)\n\tcase []Field:\n\t\tc = anyFieldC[[]Field](dictField)\n\tcase bool:\n\t\tc = anyFieldC[bool](Bool)\n\tcase *bool:\n\t\tc = anyFieldC[*bool](Boolp)\n\tcase []bool:\n\t\tc = anyFieldC[[]bool](Bools)\n\tcase complex128:\n\t\tc = anyFieldC[complex128](Complex128)\n\tcase *complex128:\n\t\tc = anyFieldC[*complex128](Complex128p)\n\tcase []complex128:\n\t\tc = anyFieldC[[]complex128](Complex128s)\n\tcase complex64:\n\t\tc = anyFieldC[complex64](Complex64)\n\tcase *complex64:\n\t\tc = anyFieldC[*complex64](Complex64p)\n\tcase []complex64:\n\t\tc = anyFieldC[[]complex64](Complex64s)\n\tcase float64:\n\t\tc = anyFieldC[float64](Float64)\n\tcase *float64:\n\t\tc = anyFieldC[*float64](Float64p)\n\tcase []float64:\n\t\tc = anyFieldC[[]float64](Float64s)\n\tcase float32:\n\t\tc = anyFieldC[float32](Float32)\n\tcase *float32:\n\t\tc = anyFieldC[*float32](Float32p)\n\tcase []float32:\n\t\tc = anyFieldC[[]float32](Float32s)\n\tcase int:\n\t\tc = anyFieldC[int](Int)\n\tcase *int:\n\t\tc = anyFieldC[*int](Intp)\n\tcase []int:\n\t\tc = anyFieldC[[]int](Ints)\n\tcase int64:\n\t\tc = anyFieldC[int64](Int64)\n\tcase *int64:\n\t\tc = anyFieldC[*int64](Int64p)\n\tcase []int64:\n\t\tc = anyFieldC[[]int64](Int64s)\n\tcase int32:\n\t\tc = anyFieldC[int32](Int32)\n\tcase *int32:\n\t\tc = anyFieldC[*int32](Int32p)\n\tcase []int32:\n\t\tc = anyFieldC[[]int32](Int32s)\n\tcase int16:\n\t\tc = anyFieldC[int16](Int16)\n\tcase *int16:\n\t\tc = anyFieldC[*int16](Int16p)\n\tcase []int16:\n\t\tc = anyFieldC[[]int16](Int16s)\n\tcase int8:\n\t\tc = anyFieldC[int8](Int8)\n\tcase *int8:\n\t\tc = anyFieldC[*int8](Int8p)\n\tcase []int8:\n\t\tc = anyFieldC[[]int8](Int8s)\n\tcase string:\n\t\tc = anyFieldC[string](String)\n\tcase *string:\n\t\tc = anyFieldC[*string](Stringp)\n\tcase []string:\n\t\tc = anyFieldC[[]string](Strings)\n\tcase uint:\n\t\tc = anyFieldC[uint](Uint)\n\tcase *uint:\n\t\tc = anyFieldC[*uint](Uintp)\n\tcase []uint:\n\t\tc = anyFieldC[[]uint](Uints)\n\tcase uint64:\n\t\tc = anyFieldC[uint64](Uint64)\n\tcase *uint64:\n\t\tc = anyFieldC[*uint64](Uint64p)\n\tcase []uint64:\n\t\tc = anyFieldC[[]uint64](Uint64s)\n\tcase uint32:\n\t\tc = anyFieldC[uint32](Uint32)\n\tcase *uint32:\n\t\tc = anyFieldC[*uint32](Uint32p)\n\tcase []uint32:\n\t\tc = anyFieldC[[]uint32](Uint32s)\n\tcase uint16:\n\t\tc = anyFieldC[uint16](Uint16)\n\tcase *uint16:\n\t\tc = anyFieldC[*uint16](Uint16p)\n\tcase []uint16:\n\t\tc = anyFieldC[[]uint16](Uint16s)\n\tcase uint8:\n\t\tc = anyFieldC[uint8](Uint8)\n\tcase *uint8:\n\t\tc = anyFieldC[*uint8](Uint8p)\n\tcase []byte:\n\t\tc = anyFieldC[[]byte](Binary)\n\tcase uintptr:\n\t\tc = anyFieldC[uintptr](Uintptr)\n\tcase *uintptr:\n\t\tc = anyFieldC[*uintptr](Uintptrp)\n\tcase []uintptr:\n\t\tc = anyFieldC[[]uintptr](Uintptrs)\n\tcase time.Time:\n\t\tc = anyFieldC[time.Time](Time)\n\tcase *time.Time:\n\t\tc = anyFieldC[*time.Time](Timep)\n\tcase []time.Time:\n\t\tc = anyFieldC[[]time.Time](Times)\n\tcase time.Duration:\n// ... trimmed ...\n","neighbors":[{"path":"field.go","start_line":470,"end_line":489,"code":"// - https://github.com/uber-go/zap/pull/1304\n// - https://github.com/uber-go/zap/pull/1305\n// - https://github.com/uber-go/zap/pull/1308\n//\n// See https://github.com/golang/go/issues/62077 for upstream issue.\ntype anyFieldC[T any] func(string, T) Field\n\nfunc (f anyFieldC[T]) Any(key string, val any) Field {\n\tv, _ := val.(T)\n\t// val is guaranteed to be a T, except when it's nil.\n\treturn f(key, v)\n}\n\n// Any takes a key and an arbitrary value and chooses the best way to represent\n// them as a field, falling back to a reflection-based approach only if\n// necessary.\n//\n// Since byte/uint8 and rune/int32 are aliases, Any can't differentiate between\n// them. To minimize surprises, []byte values are treated as binary blobs, byte\n// values are treated as uint8, and runes are always treated as integers."}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"(anyFieldC).Any","path":"field.go"},{"symbol":"(anyFieldC).Any[*complex128]","path":"field.go"},{"symbol":"(anyFieldC).Any[*complex64]","path":"field.go"},{"symbol":"(anyFieldC).Any[*float64]","path":"field.go"},{"symbol":"(anyFieldC).Any[*int32]","path":"field.go"},{"symbol":"(anyFieldC).Any[*time.Duration]","path":"field.go"},{"symbol":"(anyFieldC).Any[*time.Time]","path":"field.go"},{"symbol":"(anyFieldC).Any[*uint64]","path":"field.go"},{"symbol":"(anyFieldC).Any[*uint]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]byte]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]complex128]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]complex64]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]error]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]go.uber.org/zap.Field]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]int16]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]int32]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]int64]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]int8]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]int]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]string]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]uint32]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]uint64]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]uint]","path":"field.go"},{"symbol":"(anyFieldC).Any[[]uintptr]","path":"field.go"},{"symbol":"(anyFieldC).Any[go.uber.org/zap/zapcore.ArrayMarshaler]","path":"field.go"},{"symbol":"(anyFieldC).Any[int8]","path":"field.go"},{"symbol":"(anyFieldC).Any[int]","path":"field.go"},{"symbol":"(anyFieldC).Any[string]","path":"field.go"},{"symbol":"(anyFieldC).Any[uint8]","path":"field.go"},{"symbol":"(anyFieldC).Any[uintptr]","path":"field.go"}],"callers":[{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"(Config).buildOptions","path":"config.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"flag.go","symbol":"LevelFlag","signature":"func LevelFlag(name string, defaultLevel zapcore.Level, usage string) *zapcore.Level","start_line":35,"end_line":39,"code":"func LevelFlag(name string, defaultLevel zapcore.Level, usage string) *zapcore.Level {\n\n\tlvl := defaultLevel\n\tflag.Var(\u0026lvl, name, usage)\n\treturn \u0026lvl\n}\n","neighbors":[{"path":"flag.go","start_line":15,"end_line":34,"code":"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"flag\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// LevelFlag uses the standard library's flag.Var to declare a global flag\n// with the specified name, default, and usage guidance. The returned value is\n// a pointer to the value of the flag.\n//\n// If you don't want to use the flag package's global state, you can use any\n// non-nil *Level as a flag.Value with your own *flag.FlagSet."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Var","path":"../../../../usr/local/go/src/flag/flag.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"L","signature":"func L() *Logger","start_line":48,"end_line":53,"code":"func L() *Logger {\n\n\t_globalMu.RLock()\n\tl := _globalL\n\t_globalMu.RUnlock()\n\treturn l\n}\n","neighbors":[{"path":"global.go","start_line":28,"end_line":47,"code":"\t\"sync\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nconst (\n\t_stdLogDefaultDepth      = 1\n\t_loggerWriterDepth       = 2\n\t_programmerErrorTemplate = \"You've found a bug in zap! Please file a bug at \" +\n\t\t\"https://github.com/uber-go/zap/issues/new and reference this error: %v\"\n)\n\nvar (\n\t_globalMu sync.RWMutex\n\t_globalL  = NewNop()\n\t_globalS  = _globalL.Sugar()\n)\n\n// L returns the global Logger, which can be reconfigured with ReplaceGlobals.\n// It's safe for concurrent use."},{"path":"global.go","start_line":54,"end_line":73,"code":"\n// S returns the global SugaredLogger, which can be reconfigured with\n// ReplaceGlobals. It's safe for concurrent use.\nfunc S() *SugaredLogger {\n\t_globalMu.RLock()\n\ts := _globalS\n\t_globalMu.RUnlock()\n\treturn s\n}\n\n// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a\n// function to restore the original values. It's safe for concurrent use.\nfunc ReplaceGlobals(logger *Logger) func() {\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"S","signature":"func S() *SugaredLogger","start_line":57,"end_line":62,"code":"func S() *SugaredLogger {\n\n\t_globalMu.RLock()\n\ts := _globalS\n\t_globalMu.RUnlock()\n\treturn s\n}\n","neighbors":[{"path":"global.go","start_line":37,"end_line":56,"code":"\t\t\"https://github.com/uber-go/zap/issues/new and reference this error: %v\"\n)\n\nvar (\n\t_globalMu sync.RWMutex\n\t_globalL  = NewNop()\n\t_globalS  = _globalL.Sugar()\n)\n\n// L returns the global Logger, which can be reconfigured with ReplaceGlobals.\n// It's safe for concurrent use.\nfunc L() *Logger {\n\t_globalMu.RLock()\n\tl := _globalL\n\t_globalMu.RUnlock()\n\treturn l\n}\n\n// S returns the global SugaredLogger, which can be reconfigured with\n// ReplaceGlobals. It's safe for concurrent use."},{"path":"global.go","start_line":63,"end_line":82,"code":"\n// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a\n// function to restore the original values. It's safe for concurrent use.\nfunc ReplaceGlobals(logger *Logger) func() {\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}\n\n// NewStdLog returns a *log.Logger which writes to the supplied zap Logger at\n// InfoLevel. To redirect the standard library's package-global logging\n// functions, use RedirectStdLog instead.\nfunc NewStdLog(l *Logger) *log.Logger {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tf := logger.Info\n\treturn log.New(\u0026loggerWriter{f}, \"\" /* prefix */, 0 /* flags */)\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"ReplaceGlobals","signature":"func ReplaceGlobals(logger *Logger) func()","start_line":66,"end_line":73,"code":"func ReplaceGlobals(logger *Logger) func() {\n\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}\n","neighbors":[{"path":"global.go","start_line":46,"end_line":65,"code":"// L returns the global Logger, which can be reconfigured with ReplaceGlobals.\n// It's safe for concurrent use.\nfunc L() *Logger {\n\t_globalMu.RLock()\n\tl := _globalL\n\t_globalMu.RUnlock()\n\treturn l\n}\n\n// S returns the global SugaredLogger, which can be reconfigured with\n// ReplaceGlobals. It's safe for concurrent use.\nfunc S() *SugaredLogger {\n\t_globalMu.RLock()\n\ts := _globalS\n\t_globalMu.RUnlock()\n\treturn s\n}\n\n// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a\n// function to restore the original values. It's safe for concurrent use."},{"path":"global.go","start_line":74,"end_line":93,"code":"\n// NewStdLog returns a *log.Logger which writes to the supplied zap Logger at\n// InfoLevel. To redirect the standard library's package-global logging\n// functions, use RedirectStdLog instead.\nfunc NewStdLog(l *Logger) *log.Logger {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tf := logger.Info\n\treturn log.New(\u0026loggerWriter{f}, \"\" /* prefix */, 0 /* flags */)\n}\n\n// NewStdLogAt returns *log.Logger which writes to supplied zap logger at\n// required level.\nfunc NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error) {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn log.New(\u0026loggerWriter{logFunc}, \"\" /* prefix */, 0 /* flags */), nil\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*Logger).Sugar","path":"logger.go"},{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":[{"symbol":"ReplaceGlobals$1","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"NewStdLog","signature":"func NewStdLog(l *Logger) *log.Logger","start_line":78,"end_line":82,"code":"func NewStdLog(l *Logger) *log.Logger {\n\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tf := logger.Info\n\treturn log.New(\u0026loggerWriter{f}, \"\" , 0 )\n}\n","neighbors":[{"path":"global.go","start_line":58,"end_line":77,"code":"\t_globalMu.RLock()\n\ts := _globalS\n\t_globalMu.RUnlock()\n\treturn s\n}\n\n// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a\n// function to restore the original values. It's safe for concurrent use.\nfunc ReplaceGlobals(logger *Logger) func() {\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}\n\n// NewStdLog returns a *log.Logger which writes to the supplied zap Logger at\n// InfoLevel. To redirect the standard library's package-global logging\n// functions, use RedirectStdLog instead."},{"path":"global.go","start_line":83,"end_line":102,"code":"\n// NewStdLogAt returns *log.Logger which writes to supplied zap logger at\n// required level.\nfunc NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error) {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn log.New(\u0026loggerWriter{logFunc}, \"\" /* prefix */, 0 /* flags */), nil\n}\n\n// RedirectStdLog redirects output from the standard library's package-global\n// logger to the supplied logger at InfoLevel. Since zap already handles caller\n// annotations, timestamps, etc., it automatically disables the standard\n// library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLog(l *Logger) func() {"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"AddCallerSkip","path":"options.go"},{"symbol":"New","path":"../../../../usr/local/go/src/log/log.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"NewStdLogAt","signature":"func NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error)","start_line":86,"end_line":93,"code":"func NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error) {\n\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn log.New(\u0026loggerWriter{logFunc}, \"\" , 0 ), nil\n}\n","neighbors":[{"path":"global.go","start_line":66,"end_line":85,"code":"func ReplaceGlobals(logger *Logger) func() {\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}\n\n// NewStdLog returns a *log.Logger which writes to the supplied zap Logger at\n// InfoLevel. To redirect the standard library's package-global logging\n// functions, use RedirectStdLog instead.\nfunc NewStdLog(l *Logger) *log.Logger {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tf := logger.Info\n\treturn log.New(\u0026loggerWriter{f}, \"\" /* prefix */, 0 /* flags */)\n}\n\n// NewStdLogAt returns *log.Logger which writes to supplied zap logger at\n// required level."},{"path":"global.go","start_line":94,"end_line":113,"code":"\n// RedirectStdLog redirects output from the standard library's package-global\n// logger to the supplied logger at InfoLevel. Since zap already handles caller\n// annotations, timestamps, etc., it automatically disables the standard\n// library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLog(l *Logger) func() {\n\tf, err := redirectStdLogAt(l, InfoLevel)\n\tif err != nil {\n\t\t// Can't get here, since passing InfoLevel to redirectStdLogAt always\n\t\t// works.\n\t\tpanic(fmt.Sprintf(_programmerErrorTemplate, err))\n\t}\n\treturn f\n}\n\n// RedirectStdLogAt redirects output from the standard library's package-global\n// logger to the supplied logger at the specified level. Since zap already"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"AddCallerSkip","path":"options.go"},{"symbol":"New","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"levelToFunc","path":"global.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"RedirectStdLog","signature":"func RedirectStdLog(l *Logger) func()","start_line":102,"end_line":110,"code":"func RedirectStdLog(l *Logger) func() {\n\n\tf, err := redirectStdLogAt(l, InfoLevel)\n\tif err != nil {\n\t\t\n\t\t\n\t\tpanic(fmt.Sprintf(_programmerErrorTemplate, err))\n\t}\n\treturn f\n}\n","neighbors":[{"path":"global.go","start_line":82,"end_line":101,"code":"}\n\n// NewStdLogAt returns *log.Logger which writes to supplied zap logger at\n// required level.\nfunc NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error) {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn log.New(\u0026loggerWriter{logFunc}, \"\" /* prefix */, 0 /* flags */), nil\n}\n\n// RedirectStdLog redirects output from the standard library's package-global\n// logger to the supplied logger at InfoLevel. Since zap already handles caller\n// annotations, timestamps, etc., it automatically disables the standard\n// library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr."},{"path":"global.go","start_line":111,"end_line":130,"code":"\n// RedirectStdLogAt redirects output from the standard library's package-global\n// logger to the supplied logger at the specified level. Since zap already\n// handles caller annotations, timestamps, etc., it automatically disables the\n// standard library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\treturn redirectStdLogAt(l, level)\n}\n\nfunc redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\tflags := log.Flags()\n\tprefix := log.Prefix()\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"redirectStdLogAt","path":"global.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"RedirectStdLogAt","signature":"func RedirectStdLogAt(l *Logger, level zapcore.Level) (func(), error)","start_line":119,"end_line":121,"code":"func RedirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\n\treturn redirectStdLogAt(l, level)\n}\n","neighbors":[{"path":"global.go","start_line":99,"end_line":118,"code":"//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLog(l *Logger) func() {\n\tf, err := redirectStdLogAt(l, InfoLevel)\n\tif err != nil {\n\t\t// Can't get here, since passing InfoLevel to redirectStdLogAt always\n\t\t// works.\n\t\tpanic(fmt.Sprintf(_programmerErrorTemplate, err))\n\t}\n\treturn f\n}\n\n// RedirectStdLogAt redirects output from the standard library's package-global\n// logger to the supplied logger at the specified level. Since zap already\n// handles caller annotations, timestamps, etc., it automatically disables the\n// standard library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr."},{"path":"global.go","start_line":122,"end_line":141,"code":"\nfunc redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\tflags := log.Flags()\n\tprefix := log.Prefix()\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.SetOutput(\u0026loggerWriter{logFunc})\n\treturn func() {\n\t\tlog.SetFlags(flags)\n\t\tlog.SetPrefix(prefix)\n\t\tlog.SetOutput(os.Stderr)\n\t}, nil\n}\n\nfunc levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"redirectStdLogAt","path":"global.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"redirectStdLogAt","signature":"func redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error)","start_line":123,"end_line":139,"code":"func redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\n\tflags := log.Flags()\n\tprefix := log.Prefix()\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.SetOutput(\u0026loggerWriter{logFunc})\n\treturn func() {\n\t\tlog.SetFlags(flags)\n\t\tlog.SetPrefix(prefix)\n\t\tlog.SetOutput(os.Stderr)\n\t}, nil\n}\n","neighbors":[{"path":"global.go","start_line":103,"end_line":122,"code":"\tf, err := redirectStdLogAt(l, InfoLevel)\n\tif err != nil {\n\t\t// Can't get here, since passing InfoLevel to redirectStdLogAt always\n\t\t// works.\n\t\tpanic(fmt.Sprintf(_programmerErrorTemplate, err))\n\t}\n\treturn f\n}\n\n// RedirectStdLogAt redirects output from the standard library's package-global\n// logger to the supplied logger at the specified level. Since zap already\n// handles caller annotations, timestamps, etc., it automatically disables the\n// standard library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\treturn redirectStdLogAt(l, level)\n}\n"},{"path":"global.go","start_line":140,"end_line":159,"code":"\nfunc levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error) {\n\tswitch lvl {\n\tcase DebugLevel:\n\t\treturn logger.Debug, nil\n\tcase InfoLevel:\n\t\treturn logger.Info, nil\n\tcase WarnLevel:\n\t\treturn logger.Warn, nil\n\tcase ErrorLevel:\n\t\treturn logger.Error, nil\n\tcase DPanicLevel:\n\t\treturn logger.DPanic, nil\n\tcase PanicLevel:\n\t\treturn logger.Panic, nil\n\tcase FatalLevel:\n\t\treturn logger.Fatal, nil\n\t}\n\treturn nil, fmt.Errorf(\"unrecognized level: %q\", lvl)\n}"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"AddCallerSkip","path":"options.go"},{"symbol":"Flags","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Prefix","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"SetFlags","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"SetOutput","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"SetPrefix","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"levelToFunc","path":"global.go"}],"callers":[{"symbol":"RedirectStdLog","path":"global.go"},{"symbol":"RedirectStdLogAt","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"levelToFunc","signature":"func levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error)","start_line":141,"end_line":159,"code":"func levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error) {\n\n\tswitch lvl {\n\tcase DebugLevel:\n\t\treturn logger.Debug, nil\n\tcase InfoLevel:\n\t\treturn logger.Info, nil\n\tcase WarnLevel:\n\t\treturn logger.Warn, nil\n\tcase ErrorLevel:\n\t\treturn logger.Error, nil\n\tcase DPanicLevel:\n\t\treturn logger.DPanic, nil\n\tcase PanicLevel:\n\t\treturn logger.Panic, nil\n\tcase FatalLevel:\n\t\treturn logger.Fatal, nil\n\t}\n\treturn nil, fmt.Errorf(\"unrecognized level: %q\", lvl)\n}\n","neighbors":[{"path":"global.go","start_line":121,"end_line":140,"code":"}\n\nfunc redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\tflags := log.Flags()\n\tprefix := log.Prefix()\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.SetOutput(\u0026loggerWriter{logFunc})\n\treturn func() {\n\t\tlog.SetFlags(flags)\n\t\tlog.SetPrefix(prefix)\n\t\tlog.SetOutput(os.Stderr)\n\t}, nil\n}\n"},{"path":"global.go","start_line":160,"end_line":170,"code":"\ntype loggerWriter struct {\n\tlogFunc func(msg string, fields ...Field)\n}\n\nfunc (l *loggerWriter) Write(p []byte) (int, error) {\n\tp = bytes.TrimSpace(p)\n\tl.logFunc(string(p))\n\treturn len(p), nil\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"}],"callers":[{"symbol":"NewStdLogAt","path":"global.go"},{"symbol":"redirectStdLogAt","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"global.go","symbol":"(*loggerWriter).Write","signature":"func (l *loggerWriter) Write(p []byte) (int, error)","start_line":165,"end_line":169,"code":"func (l *loggerWriter) Write(p []byte) (int, error) {\n\n\tp = bytes.TrimSpace(p)\n\tl.logFunc(string(p))\n\treturn len(p), nil\n}\n","neighbors":[{"path":"global.go","start_line":145,"end_line":164,"code":"\tcase InfoLevel:\n\t\treturn logger.Info, nil\n\tcase WarnLevel:\n\t\treturn logger.Warn, nil\n\tcase ErrorLevel:\n\t\treturn logger.Error, nil\n\tcase DPanicLevel:\n\t\treturn logger.DPanic, nil\n\tcase PanicLevel:\n\t\treturn logger.Panic, nil\n\tcase FatalLevel:\n\t\treturn logger.Fatal, nil\n\t}\n\treturn nil, fmt.Errorf(\"unrecognized level: %q\", lvl)\n}\n\ntype loggerWriter struct {\n\tlogFunc func(msg string, fields ...Field)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.8},"call_graph":{"callees":[{"symbol":"(*Logger).DPanic","path":"logger.go"},{"symbol":"(*Logger).Debug","path":"logger.go"},{"symbol":"(*Logger).Error","path":"logger.go"},{"symbol":"(*Logger).Fatal","path":"logger.go"},{"symbol":"(*Logger).Info","path":"logger.go"},{"symbol":"(*Logger).Panic","path":"logger.go"},{"symbol":"(*Logger).Warn","path":"logger.go"},{"symbol":"TrimSpace","path":"../../../../usr/local/go/src/bytes/bytes.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"http_handler.go","symbol":"(AtomicLevel).ServeHTTP","signature":"func (lvl AtomicLevel) ServeHTTP(w http.ResponseWriter, r *http.Request)","start_line":71,"end_line":76,"code":"func (lvl AtomicLevel) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\n\tif err := lvl.serveHTTP(w, r); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t_, _ = fmt.Fprintf(w, \"internal error: %v\", err)\n\t}\n}\n","neighbors":[{"path":"http_handler.go","start_line":51,"end_line":70,"code":"//\n//\tlevel=debug\n//\n// The request body takes precedence over the query parameter, if both are\n// specified.\n//\n// This content type is the default for a curl PUT request. Following are two\n// example curl requests that both set the logging level to debug.\n//\n//\tcurl -X PUT localhost:8080/log/level?level=debug\n//\tcurl -X PUT localhost:8080/log/level -d level=debug\n//\n// For any other content type, the payload is expected to be JSON encoded and\n// look like:\n//\n//\t{\"level\":\"info\"}\n//\n// An example curl request could look like this:\n//\n//\tcurl -X PUT localhost:8080/log/level -H \"Content-Type: application/json\" -d '{\"level\":\"debug\"}'"},{"path":"http_handler.go","start_line":77,"end_line":96,"code":"\nfunc (lvl AtomicLevel) serveHTTP(w http.ResponseWriter, r *http.Request) error {\n\ttype errorResponse struct {\n\t\tError string `json:\"error\"`\n\t}\n\ttype payload struct {\n\t\tLevel zapcore.Level `json:\"level\"`\n\t}\n\n\tenc := json.NewEncoder(w)\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tcase http.MethodPut:\n\t\trequestedLvl, err := decodePutRequest(r.Header.Get(\"Content-Type\"), r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn enc.Encode(errorResponse{Error: err.Error()})"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*http2responseWriter).WriteHeader","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*populateResponse).WriteHeader","path":"../../../../usr/local/go/src/net/http/filetransport.go"},{"symbol":"(*response).WriteHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*timeoutWriter).WriteHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(AtomicLevel).serveHTTP","path":"http_handler.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*AtomicLevel).ServeHTTP","path":"http_handler.go"},{"symbol":"(*ServeMux).ServeHTTP","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*http2serverConn).runHandler","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(HandlerFunc).ServeHTTP","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(serverHandler).ServeHTTP","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"AllowQuerySemicolons$1","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"Handler$1","path":"../../../../usr/local/go/src/net/http/csrf.go"},{"symbol":"MaxBytesHandler$1","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"ServeHTTP$1","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"StripPrefix$1","path":"../../../../usr/local/go/src/net/http/server.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"http_handler.go","symbol":"(AtomicLevel).serveHTTP","signature":"func (lvl AtomicLevel) serveHTTP(w http.ResponseWriter, r *http.Request) error","start_line":78,"end_line":107,"code":"func (lvl AtomicLevel) serveHTTP(w http.ResponseWriter, r *http.Request) error {\n\n\ttype errorResponse struct {\n\t\tError string `json:\"error\"`\n\t}\n\ttype payload struct {\n\t\tLevel zapcore.Level `json:\"level\"`\n\t}\n\n\tenc := json.NewEncoder(w)\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tcase http.MethodPut:\n\t\trequestedLvl, err := decodePutRequest(r.Header.Get(\"Content-Type\"), r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn enc.Encode(errorResponse{Error: err.Error()})\n\t\t}\n\t\tlvl.SetLevel(requestedLvl)\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn enc.Encode(errorResponse{\n\t\t\tError: \"Only GET and PUT are supported.\",\n\t\t})\n\t}\n}\n","neighbors":[{"path":"http_handler.go","start_line":58,"end_line":77,"code":"// example curl requests that both set the logging level to debug.\n//\n//\tcurl -X PUT localhost:8080/log/level?level=debug\n//\tcurl -X PUT localhost:8080/log/level -d level=debug\n//\n// For any other content type, the payload is expected to be JSON encoded and\n// look like:\n//\n//\t{\"level\":\"info\"}\n//\n// An example curl request could look like this:\n//\n//\tcurl -X PUT localhost:8080/log/level -H \"Content-Type: application/json\" -d '{\"level\":\"debug\"}'\nfunc (lvl AtomicLevel) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif err := lvl.serveHTTP(w, r); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t_, _ = fmt.Fprintf(w, \"internal error: %v\", err)\n\t}\n}\n"},{"path":"http_handler.go","start_line":108,"end_line":127,"code":"\n// Decodes incoming PUT requests and returns the requested logging level.\nfunc decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error) {\n\tif contentType == \"application/x-www-form-urlencoded\" {\n\t\treturn decodePutURL(r)\n\t}\n\treturn decodePutJSON(r.Body)\n}\n\nfunc decodePutURL(r *http.Request) (zapcore.Level, error) {\n\tlvl := r.FormValue(\"level\")\n\tif lvl == \"\" {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText([]byte(lvl)); err != nil {\n\t\treturn 0, err\n\t}\n\treturn l, nil\n}"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*DeadlineExceededError).Error","path":"../../../../usr/local/go/src/internal/poll/fd.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Error).Error","path":"../../../../usr/local/go/src/net/url/url.go"},{"symbol":"(*OpError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*ParseError).Error","path":"../../../../usr/local/go/src/time/format.go"},{"symbol":"(*ProtocolError).Error","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*ReadError).Error","path":"../../../../usr/local/go/src/compress/flate/inflate.go"},{"symbol":"(*SyntaxError).Error","path":"../../../../usr/local/go/src/encoding/json/scanner.go"},{"symbol":"(*UnmarshalTypeError).Error","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(*errUnmarshalChaCha8).Error","path":"../../../../usr/local/go/src/internal/chacha8rand/chacha8.go"},{"symbol":"(*http2responseWriter).WriteHeader","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*multiError).Error","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*populateResponse).WriteHeader","path":"../../../../usr/local/go/src/net/http/filetransport.go"},{"symbol":"(*response).WriteHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*temporaryError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*timeoutWriter).WriteHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(AtomicLevel).Level","path":"level.go"},{"symbol":"(AtomicLevel).SetLevel","path":"level.go"},{"symbol":"(ConstraintViolationError).Error","path":"../../../../usr/local/go/src/crypto/x509/x509.go"},{"symbol":"(Header).Get","path":"../../../../usr/local/go/src/net/http/header.go"},{"symbol":"(InvalidIndexError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/hpack.go"},{"symbol":"(UnknownNetworkError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(errNetClosing).Error","path":"../../../../usr/local/go/src/internal/poll/fd.go"},{"symbol":"(errSymlink).Error","path":"../../../../usr/local/go/src/os/root_openat.go"},{"symbol":"(http2GoAwayError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(http2goAwayFlowError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(labelError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/idna/idna10.0.0.go"},{"symbol":"(runeError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/idna/idna10.0.0.go"},{"symbol":"NewEncoder","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"decodePutRequest","path":"http_handler.go"}],"callers":[{"symbol":"(*AtomicLevel).serveHTTP","path":"http_handler.go"},{"symbol":"(AtomicLevel).ServeHTTP","path":"http_handler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"http_handler.go","symbol":"decodePutRequest","signature":"func decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error)","start_line":110,"end_line":115,"code":"func decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error) {\n\n\tif contentType == \"application/x-www-form-urlencoded\" {\n\t\treturn decodePutURL(r)\n\t}\n\treturn decodePutJSON(r.Body)\n}\n","neighbors":[{"path":"http_handler.go","start_line":90,"end_line":109,"code":"\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tcase http.MethodPut:\n\t\trequestedLvl, err := decodePutRequest(r.Header.Get(\"Content-Type\"), r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn enc.Encode(errorResponse{Error: err.Error()})\n\t\t}\n\t\tlvl.SetLevel(requestedLvl)\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn enc.Encode(errorResponse{\n\t\t\tError: \"Only GET and PUT are supported.\",\n\t\t})\n\t}\n}\n\n// Decodes incoming PUT requests and returns the requested logging level."},{"path":"http_handler.go","start_line":116,"end_line":135,"code":"\nfunc decodePutURL(r *http.Request) (zapcore.Level, error) {\n\tlvl := r.FormValue(\"level\")\n\tif lvl == \"\" {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText([]byte(lvl)); err != nil {\n\t\treturn 0, err\n\t}\n\treturn l, nil\n}\n\nfunc decodePutJSON(body io.Reader) (zapcore.Level, error) {\n\tvar pld struct {\n\t\tLevel *zapcore.Level `json:\"level\"`\n\t}\n\tif err := json.NewDecoder(body).Decode(\u0026pld); err != nil {\n\t\treturn 0, fmt.Errorf(\"malformed request body: %v\", err)\n\t}"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"decodePutJSON","path":"http_handler.go"},{"symbol":"decodePutURL","path":"http_handler.go"}],"callers":[{"symbol":"(AtomicLevel).serveHTTP","path":"http_handler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"http_handler.go","symbol":"decodePutURL","signature":"func decodePutURL(r *http.Request) (zapcore.Level, error)","start_line":117,"end_line":127,"code":"func decodePutURL(r *http.Request) (zapcore.Level, error) {\n\n\tlvl := r.FormValue(\"level\")\n\tif lvl == \"\" {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText([]byte(lvl)); err != nil {\n\t\treturn 0, err\n\t}\n\treturn l, nil\n}\n","neighbors":[{"path":"http_handler.go","start_line":97,"end_line":116,"code":"\t\t}\n\t\tlvl.SetLevel(requestedLvl)\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn enc.Encode(errorResponse{\n\t\t\tError: \"Only GET and PUT are supported.\",\n\t\t})\n\t}\n}\n\n// Decodes incoming PUT requests and returns the requested logging level.\nfunc decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error) {\n\tif contentType == \"application/x-www-form-urlencoded\" {\n\t\treturn decodePutURL(r)\n\t}\n\treturn decodePutJSON(r.Body)\n}\n"},{"path":"http_handler.go","start_line":128,"end_line":141,"code":"\nfunc decodePutJSON(body io.Reader) (zapcore.Level, error) {\n\tvar pld struct {\n\t\tLevel *zapcore.Level `json:\"level\"`\n\t}\n\tif err := json.NewDecoder(body).Decode(\u0026pld); err != nil {\n\t\treturn 0, fmt.Errorf(\"malformed request body: %v\", err)\n\t}\n\tif pld.Level == nil {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\treturn *pld.Level, nil\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Level).UnmarshalText","path":"zapcore/level.go"},{"symbol":"(*Request).FormValue","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"}],"callers":[{"symbol":"decodePutRequest","path":"http_handler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"http_handler.go","symbol":"decodePutJSON","signature":"func decodePutJSON(body io.Reader) (zapcore.Level, error)","start_line":129,"end_line":140,"code":"func decodePutJSON(body io.Reader) (zapcore.Level, error) {\n\n\tvar pld struct {\n\t\tLevel *zapcore.Level `json:\"level\"`\n\t}\n\tif err := json.NewDecoder(body).Decode(\u0026pld); err != nil {\n\t\treturn 0, fmt.Errorf(\"malformed request body: %v\", err)\n\t}\n\tif pld.Level == nil {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\treturn *pld.Level, nil\n}\n","neighbors":[{"path":"http_handler.go","start_line":109,"end_line":128,"code":"// Decodes incoming PUT requests and returns the requested logging level.\nfunc decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error) {\n\tif contentType == \"application/x-www-form-urlencoded\" {\n\t\treturn decodePutURL(r)\n\t}\n\treturn decodePutJSON(r.Body)\n}\n\nfunc decodePutURL(r *http.Request) (zapcore.Level, error) {\n\tlvl := r.FormValue(\"level\")\n\tif lvl == \"\" {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText([]byte(lvl)); err != nil {\n\t\treturn 0, err\n\t}\n\treturn l, nil\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Decoder).Decode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"NewDecoder","path":"../../../../usr/local/go/src/encoding/json/stream.go"}],"callers":[{"symbol":"decodePutRequest","path":"http_handler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/color/color.go","symbol":"(Color).Add","signature":"func (c Color) Add(s string) string","start_line":42,"end_line":44,"code":"func (c Color) Add(s string) string {\n\n\treturn fmt.Sprintf(\"\\x1b[%dm%s\\x1b[0m\", uint8(c), s)\n}\n","neighbors":[{"path":"internal/color/color.go","start_line":22,"end_line":41,"code":"package color\n\nimport \"fmt\"\n\n// Foreground colors.\nconst (\n\tBlack Color = iota + 30\n\tRed\n\tGreen\n\tYellow\n\tBlue\n\tMagenta\n\tCyan\n\tWhite\n)\n\n// Color represents a text color.\ntype Color uint8\n\n// Add adds the coloring to the given string."}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":[{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*Color).Add","path":"internal/color/color.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"init#1","path":"zapcore/level_strings.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/exit/exit.go","symbol":"With","signature":"func With(code int)","start_line":31,"end_line":33,"code":"func With(code int) {\n\n\t_exit(code)\n}\n","neighbors":[{"path":"internal/exit/exit.go","start_line":11,"end_line":30,"code":"// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package exit provides stubs so that unit tests can exercise code that calls\n// os.Exit(1).\npackage exit\n\nimport \"os\"\n\nvar _exit = os.Exit\n\n// With terminates the process by calling os.Exit(code). If the package is\n// stubbed, it instead records a call in the testing spy."},{"path":"internal/exit/exit.go","start_line":34,"end_line":53,"code":"\n// A StubbedExit is a testing fake for os.Exit.\ntype StubbedExit struct {\n\tExited bool\n\tCode   int\n\tprev   func(code int)\n}\n\n// Stub substitutes a fake for the call to os.Exit(1).\nfunc Stub() *StubbedExit {\n\ts := \u0026StubbedExit{prev: _exit}\n\t_exit = s.exit\n\treturn s\n}\n\n// WithStub runs the supplied function with Exit stubbed. It returns the stub\n// used, so that users can test whether the process would have crashed.\nfunc WithStub(f func()) *StubbedExit {\n\ts := Stub()\n\tdefer s.Unstub()"}],"selection":{"visibility":"exported","reason":"public_api","score":0.79},"call_graph":{"callees":[{"symbol":"(*StubbedExit).exit","path":"internal/exit/exit.go"},{"symbol":"CloseOnExec","path":"../../../../usr/local/go/src/syscall/exec_unix.go"},{"symbol":"Exit","path":"../../../../usr/local/go/src/os/proc.go"},{"symbol":"Exit","path":"../../../../usr/local/go/src/syscall/syscall.go"},{"symbol":"Run","path":"../../../../usr/local/go/src/internal/runtime/exithook/hooks.go"},{"symbol":"SetBlockProfileRate","path":"../../../../usr/local/go/src/runtime/mprof.go"},{"symbol":"SetCPUProfileRate","path":"../../../../usr/local/go/src/runtime/cpuprof.go"},{"symbol":"SetFlags","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"With","path":"internal/exit/exit.go"},{"symbol":"checkWriteHeaderCode","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"flushmcache","path":"../../../../usr/local/go/src/runtime/mstats.go"},{"symbol":"http2checkWriteHeaderCode","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"init$1","path":"../../../../usr/local/go/src/internal/poll/fd.go"},{"symbol":"os_beforeExit","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"panicrangestate","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"runExitHooks","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"runtime_beforeExit","path":"../../../../usr/local/go/src/os/proc.go"},{"symbol":"syscall_Exit","path":"../../../../usr/local/go/src/runtime/runtime.go"}],"callers":[{"symbol":"(*FD).Writev","path":"../../../../usr/local/go/src/internal/poll/writev.go"},{"symbol":"(*http2serverConn).serve","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(CheckWriteAction).OnWrite","path":"zapcore/entry.go"},{"symbol":"With","path":"internal/exit/exit.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/exit/exit.go","symbol":"Stub","signature":"func Stub() *StubbedExit","start_line":43,"end_line":47,"code":"func Stub() *StubbedExit {\n\n\ts := \u0026StubbedExit{prev: _exit}\n\t_exit = s.exit\n\treturn s\n}\n","neighbors":[{"path":"internal/exit/exit.go","start_line":23,"end_line":42,"code":"package exit\n\nimport \"os\"\n\nvar _exit = os.Exit\n\n// With terminates the process by calling os.Exit(code). If the package is\n// stubbed, it instead records a call in the testing spy.\nfunc With(code int) {\n\t_exit(code)\n}\n\n// A StubbedExit is a testing fake for os.Exit.\ntype StubbedExit struct {\n\tExited bool\n\tCode   int\n\tprev   func(code int)\n}\n\n// Stub substitutes a fake for the call to os.Exit(1)."},{"path":"internal/exit/exit.go","start_line":48,"end_line":67,"code":"\n// WithStub runs the supplied function with Exit stubbed. It returns the stub\n// used, so that users can test whether the process would have crashed.\nfunc WithStub(f func()) *StubbedExit {\n\ts := Stub()\n\tdefer s.Unstub()\n\tf()\n\treturn s\n}\n\n// Unstub restores the previous exit function.\nfunc (se *StubbedExit) Unstub() {\n\t_exit = se.prev\n}\n\nfunc (se *StubbedExit) exit(code int) {\n\tse.Exited = true\n\tse.Code = code\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"WithStub","path":"internal/exit/exit.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/exit/exit.go","symbol":"WithStub","signature":"func WithStub(f func()) *StubbedExit","start_line":51,"end_line":56,"code":"func WithStub(f func()) *StubbedExit {\n\n\ts := Stub()\n\tdefer s.Unstub()\n\tf()\n\treturn s\n}\n","neighbors":[{"path":"internal/exit/exit.go","start_line":31,"end_line":50,"code":"func With(code int) {\n\t_exit(code)\n}\n\n// A StubbedExit is a testing fake for os.Exit.\ntype StubbedExit struct {\n\tExited bool\n\tCode   int\n\tprev   func(code int)\n}\n\n// Stub substitutes a fake for the call to os.Exit(1).\nfunc Stub() *StubbedExit {\n\ts := \u0026StubbedExit{prev: _exit}\n\t_exit = s.exit\n\treturn s\n}\n\n// WithStub runs the supplied function with Exit stubbed. It returns the stub\n// used, so that users can test whether the process would have crashed."},{"path":"internal/exit/exit.go","start_line":57,"end_line":67,"code":"\n// Unstub restores the previous exit function.\nfunc (se *StubbedExit) Unstub() {\n\t_exit = se.prev\n}\n\nfunc (se *StubbedExit) exit(code int) {\n\tse.Exited = true\n\tse.Code = code\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":[{"symbol":"(*StubbedExit).Unstub","path":"internal/exit/exit.go"},{"symbol":"(*http2serverConn).onShutdownTimer","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"Start$1","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"Stub","path":"internal/exit/exit.go"},{"symbol":"alloc$1","path":"../../../../usr/local/go/src/runtime/mheap.go"},{"symbol":"debugCallV2","path":"../../../../usr/local/go/src/runtime/debugcall.go"},{"symbol":"entersyscall","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"gcStart$4","path":"../../../../usr/local/go/src/runtime/mgc.go"},{"symbol":"init#2","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512block_arm64.go"},{"symbol":"initMimeUnix","path":"../../../../usr/local/go/src/mime/type_unix.go"},{"symbol":"libc_accept_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_fchown_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_mkdirat_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/at_darwin.go"},{"symbol":"libc_munlockall_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_sysconf_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/user_darwin.go"},{"symbol":"maybeRunAsync$1","path":"../../../../usr/local/go/src/runtime/time.go"},{"symbol":"netpollBreak","path":"../../../../usr/local/go/src/runtime/netpoll_kqueue.go"},{"symbol":"panicunsafeslicelen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"panicunsafestringlen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"racegoend","path":"../../../../usr/local/go/src/runtime/race0.go"},{"symbol":"read_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"restoreSIGSYS","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"secure","path":"../../../../usr/local/go/src/runtime/security_unix.go"},{"symbol":"sigpanic","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"sigprocmask_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"startTheWorld$1","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"syscall_runtime_AfterFork","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"write$2","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"x509_CFDictionaryGetValueIfPresent_trampoline","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/corefoundation.go"},{"symbol":"x509_CFErrorGetCode_trampoline","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/corefoundation.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/exit/exit.go","symbol":"(*StubbedExit).Unstub","signature":"func (se *StubbedExit) Unstub()","start_line":59,"end_line":61,"code":"func (se *StubbedExit) Unstub() {\n\n\t_exit = se.prev\n}\n","neighbors":[{"path":"internal/exit/exit.go","start_line":39,"end_line":58,"code":"\tprev   func(code int)\n}\n\n// Stub substitutes a fake for the call to os.Exit(1).\nfunc Stub() *StubbedExit {\n\ts := \u0026StubbedExit{prev: _exit}\n\t_exit = s.exit\n\treturn s\n}\n\n// WithStub runs the supplied function with Exit stubbed. It returns the stub\n// used, so that users can test whether the process would have crashed.\nfunc WithStub(f func()) *StubbedExit {\n\ts := Stub()\n\tdefer s.Unstub()\n\tf()\n\treturn s\n}\n\n// Unstub restores the previous exit function."},{"path":"internal/exit/exit.go","start_line":62,"end_line":67,"code":"\nfunc (se *StubbedExit) exit(code int) {\n\tse.Exited = true\n\tse.Code = code\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"WithStub","path":"internal/exit/exit.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/exit/exit.go","symbol":"(*StubbedExit).exit","signature":"func (se *StubbedExit) exit(code int)","start_line":63,"end_line":66,"code":"func (se *StubbedExit) exit(code int) {\n\n\tse.Exited = true\n\tse.Code = code\n}\n","neighbors":[{"path":"internal/exit/exit.go","start_line":43,"end_line":62,"code":"func Stub() *StubbedExit {\n\ts := \u0026StubbedExit{prev: _exit}\n\t_exit = s.exit\n\treturn s\n}\n\n// WithStub runs the supplied function with Exit stubbed. It returns the stub\n// used, so that users can test whether the process would have crashed.\nfunc WithStub(f func()) *StubbedExit {\n\ts := Stub()\n\tdefer s.Unstub()\n\tf()\n\treturn s\n}\n\n// Unstub restores the previous exit function.\nfunc (se *StubbedExit) Unstub() {\n\t_exit = se.prev\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":null,"callers":[{"symbol":"(*FD).Writev","path":"../../../../usr/local/go/src/internal/poll/writev.go"},{"symbol":"(*http2serverConn).serve","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"With","path":"internal/exit/exit.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/pool/pool.go","symbol":"New","signature":"func New[T any](fn func() T) *Pool[T]","start_line":40,"end_line":48,"code":"func New[T any](fn func() T) *Pool[T] {\n\n\treturn \u0026Pool[T]{\n\t\tpool: sync.Pool{\n\t\t\tNew: func() any {\n\t\t\t\treturn fn()\n\t\t\t},\n\t\t},\n\t}\n}\n","neighbors":[{"path":"internal/pool/pool.go","start_line":20,"end_line":39,"code":"\n// Package pool provides internal pool utilities.\npackage pool\n\nimport (\n\t\"sync\"\n)\n\n// A Pool is a generic wrapper around [sync.Pool] to provide strongly-typed\n// object pooling.\n//\n// Note that SA6002 (ref: https://staticcheck.io/docs/checks/#SA6002) will\n// not be detected, so all internal pool use must take care to only store\n// pointer types.\ntype Pool[T any] struct {\n\tpool sync.Pool\n}\n\n// New returns a new [Pool] for T, and will use fn to construct new Ts when\n// the pool is empty."},{"path":"internal/pool/pool.go","start_line":49,"end_line":59,"code":"\n// Get gets a T from the pool, or creates a new one if the pool is empty.\nfunc (p *Pool[T]) Get() T {\n\treturn p.pool.Get().(T)\n}\n\n// Put returns x into the pool.\nfunc (p *Pool[T]) Put(x T) {\n\tp.pool.Put(x)\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"New[*go.uber.org/zap.errArrayElem]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/buffer.Buffer]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/internal/stacktrace.Stack]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/zapcore.CheckedEntry]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/zapcore.errArrayElem]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/zapcore.jsonEncoder]","path":"internal/pool/pool.go"},{"symbol":"New[*go.uber.org/zap/zapcore.sliceArrayEncoder]","path":"internal/pool/pool.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/pool/pool.go","symbol":"(*Pool[T]).Get","signature":"func (p *Pool[T]) Get() T","start_line":51,"end_line":53,"code":"func (p *Pool[T]) Get() T {\n\n\treturn p.pool.Get().(T)\n}\n","neighbors":[{"path":"internal/pool/pool.go","start_line":31,"end_line":50,"code":"// Note that SA6002 (ref: https://staticcheck.io/docs/checks/#SA6002) will\n// not be detected, so all internal pool use must take care to only store\n// pointer types.\ntype Pool[T any] struct {\n\tpool sync.Pool\n}\n\n// New returns a new [Pool] for T, and will use fn to construct new Ts when\n// the pool is empty.\nfunc New[T any](fn func() T) *Pool[T] {\n\treturn \u0026Pool[T]{\n\t\tpool: sync.Pool{\n\t\t\tNew: func() any {\n\t\t\t\treturn fn()\n\t\t\t},\n\t\t},\n\t}\n}\n\n// Get gets a T from the pool, or creates a new one if the pool is empty."},{"path":"internal/pool/pool.go","start_line":54,"end_line":59,"code":"\n// Put returns x into the pool.\nfunc (p *Pool[T]) Put(x T) {\n\tp.pool.Put(x)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.67},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/pool/pool.go","symbol":"(*Pool[T]).Put","signature":"func (p *Pool[T]) Put(x T)","start_line":56,"end_line":58,"code":"func (p *Pool[T]) Put(x T) {\n\n\tp.pool.Put(x)\n}\n","neighbors":[{"path":"internal/pool/pool.go","start_line":36,"end_line":55,"code":"}\n\n// New returns a new [Pool] for T, and will use fn to construct new Ts when\n// the pool is empty.\nfunc New[T any](fn func() T) *Pool[T] {\n\treturn \u0026Pool[T]{\n\t\tpool: sync.Pool{\n\t\t\tNew: func() any {\n\t\t\t\treturn fn()\n\t\t\t},\n\t\t},\n\t}\n}\n\n// Get gets a T from the pool, or creates a new one if the pool is empty.\nfunc (p *Pool[T]) Get() T {\n\treturn p.pool.Get().(T)\n}\n\n// Put returns x into the pool."}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"main","signature":"func main()","start_line":51,"end_line":56,"code":"func main() {\n\n\tflag.Parse()\n\tif err := do(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":31,"end_line":50,"code":"\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/template\"\n\t\"time\"\n)\n\nvar libraryNameToMarkdownName = map[string]string{\n\t\"Zap\":                   \":zap: zap\",\n\t\"Zap.Sugar\":             \":zap: zap (sugared)\",\n\t\"stdlib.Println\":        \"standard library\",\n\t\"sirupsen/logrus\":       \"logrus\",\n\t\"go-kit/kit/log\":        \"go-kit\",\n\t\"inconshreveable/log15\": \"log15\",\n\t\"apex/log\":              \"apex/log\",\n\t\"rs/zerolog\":            \"zerolog\",\n\t\"slog\":                  \"slog\",\n\t\"slog.LogAttrs\":         \"slog (LogAttrs)\",\n}\n"},{"path":"internal/readme/readme.go","start_line":57,"end_line":76,"code":"\nfunc do() error {\n\ttmplData, err := getTmplData()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata, err := io.ReadAll(os.Stdin)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt, err := template.New(\"tmpl\").Parse(string(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.Execute(os.Stdout, tmplData)\n}\n\nfunc getTmplData() (*tmplData, error) {\n\ttmplData := \u0026tmplData{}\n\trows, err := getBenchmarkRows(\"BenchmarkAddingFields\")"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"Fatal","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Parse","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"do","path":"internal/readme/readme.go"}],"callers":[{"symbol":"(*Once).doSlow","path":"../../../../usr/local/go/src/sync/once.go"},{"symbol":"(*Resolver).exchange","path":"../../../../usr/local/go/src/net/dnsclient_unix.go"},{"symbol":"(*Resolver).lookupIPAddr","path":"../../../../usr/local/go/src/net/lookup.go"},{"symbol":"(*body).readLocked","path":"../../../../usr/local/go/src/net/http/transfer.go"},{"symbol":"(*cancelTimerBody).Close","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*http2ClientConn).Shutdown","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2pipe).Read","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2serverConn).serve","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*persistConn).readLoop","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*persistConn).roundTrip","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"CloseIdleConnections$1","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"DecryptOAEP","path":"../../../../usr/local/go/src/crypto/internal/fips140/rsa/pkcs1v22.go"},{"symbol":"ECDH","path":"../../../../usr/local/go/src/crypto/internal/fips140/ecdh/ecdh.go"},{"symbol":"Getenv","path":"../../../../usr/local/go/src/syscall/env_unix.go"},{"symbol":"Go$1","path":"../../../../usr/local/go/src/sync/waitgroup.go"},{"symbol":"Goexit","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"Pin$1","path":"../../../../usr/local/go/src/runtime/pinner.go"},{"symbol":"Run","path":"../../../../usr/local/go/src/internal/runtime/exithook/hooks.go"},{"symbol":"VerifyPH","path":"../../../../usr/local/go/src/crypto/internal/fips140/ed25519/ed25519.go"},{"symbol":"VerifyPKCS1v15","path":"../../../../usr/local/go/src/crypto/internal/fips140/rsa/pkcs1v15.go"},{"symbol":"addTLS$2","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"connect$2","path":"../../../../usr/local/go/src/net/fd_unix.go"},{"symbol":"http2ConfigureServer$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"http2traceGot100Continue","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"lookupIPAddr$2","path":"../../../../usr/local/go/src/net/lookup.go"},{"symbol":"lookupProtocol","path":"../../../../usr/local/go/src/net/lookup_unix.go"},{"symbol":"mstart1","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"runHandler$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"signCtx","path":"../../../../usr/local/go/src/crypto/internal/fips140/ed25519/ed25519.go"},{"symbol":"tryRecordGoroutineProfile","path":"../../../../usr/local/go/src/runtime/mprof.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"do","signature":"func do() error","start_line":58,"end_line":72,"code":"func do() error {\n\n\ttmplData, err := getTmplData()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata, err := io.ReadAll(os.Stdin)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt, err := template.New(\"tmpl\").Parse(string(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.Execute(os.Stdout, tmplData)\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":38,"end_line":57,"code":"var libraryNameToMarkdownName = map[string]string{\n\t\"Zap\":                   \":zap: zap\",\n\t\"Zap.Sugar\":             \":zap: zap (sugared)\",\n\t\"stdlib.Println\":        \"standard library\",\n\t\"sirupsen/logrus\":       \"logrus\",\n\t\"go-kit/kit/log\":        \"go-kit\",\n\t\"inconshreveable/log15\": \"log15\",\n\t\"apex/log\":              \"apex/log\",\n\t\"rs/zerolog\":            \"zerolog\",\n\t\"slog\":                  \"slog\",\n\t\"slog.LogAttrs\":         \"slog (LogAttrs)\",\n}\n\nfunc main() {\n\tflag.Parse()\n\tif err := do(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"},{"path":"internal/readme/readme.go","start_line":73,"end_line":92,"code":"\nfunc getTmplData() (*tmplData, error) {\n\ttmplData := \u0026tmplData{}\n\trows, err := getBenchmarkRows(\"BenchmarkAddingFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAddingFields = rows\n\trows, err = getBenchmarkRows(\"BenchmarkAccumulatedContext\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAccumulatedContext = rows\n\trows, err = getBenchmarkRows(\"BenchmarkWithoutFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkWithoutFields = rows\n\treturn tmplData, nil\n}"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Template).Execute","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(*Template).Parse","path":"../../../../usr/local/go/src/text/template/template.go"},{"symbol":"New","path":"../../../../usr/local/go/src/text/template/template.go"},{"symbol":"ReadAll","path":"../../../../usr/local/go/src/io/io.go"},{"symbol":"getTmplData","path":"internal/readme/readme.go"}],"callers":[{"symbol":"(*Cmd).watchCtx","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*bodyEOFSignal).Close","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*http2ClientConn).roundTrip","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(Invoke).Invoke","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"CAST","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"PCT","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"Start$2","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"afterResolvingSymlink","path":"../../../../usr/local/go/src/os/root_unix.go"},{"symbol":"ignoringEINTR","path":"../../../../usr/local/go/src/internal/poll/fd_posix.go"},{"symbol":"ignoringEINTR","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"main","path":"internal/readme/readme.go"},{"symbol":"roundTrip$2","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"getTmplData","signature":"func getTmplData() (*tmplData, error)","start_line":74,"end_line":92,"code":"func getTmplData() (*tmplData, error) {\n\n\ttmplData := \u0026tmplData{}\n\trows, err := getBenchmarkRows(\"BenchmarkAddingFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAddingFields = rows\n\trows, err = getBenchmarkRows(\"BenchmarkAccumulatedContext\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAccumulatedContext = rows\n\trows, err = getBenchmarkRows(\"BenchmarkWithoutFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkWithoutFields = rows\n\treturn tmplData, nil\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":54,"end_line":73,"code":"\t\tlog.Fatal(err)\n\t}\n}\n\nfunc do() error {\n\ttmplData, err := getTmplData()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdata, err := io.ReadAll(os.Stdin)\n\tif err != nil {\n\t\treturn err\n\t}\n\tt, err := template.New(\"tmpl\").Parse(string(data))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.Execute(os.Stdout, tmplData)\n}\n"},{"path":"internal/readme/readme.go","start_line":93,"end_line":112,"code":"\nfunc getBenchmarkRows(benchmarkName string) (string, error) {\n\tbenchmarkOutput, err := getBenchmarkOutput(benchmarkName)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// get the Zap time (unsugared) as baseline to compare with other loggers\n\tbaseline, err := getBenchmarkRow(benchmarkOutput, benchmarkName, \"Zap\", nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar benchmarkRows []*benchmarkRow\n\tfor libraryName := range libraryNameToMarkdownName {\n\t\tbenchmarkRow, err := getBenchmarkRow(\n\t\t\tbenchmarkOutput, benchmarkName, libraryName, baseline,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn \"\", err"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"getBenchmarkRows","path":"internal/readme/readme.go"}],"callers":[{"symbol":"do","path":"internal/readme/readme.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"getBenchmarkRows","signature":"func getBenchmarkRows(benchmarkName string) (string, error)","start_line":94,"end_line":128,"code":"func getBenchmarkRows(benchmarkName string) (string, error) {\n\n\tbenchmarkOutput, err := getBenchmarkOutput(benchmarkName)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t\n\tbaseline, err := getBenchmarkRow(benchmarkOutput, benchmarkName, \"Zap\", nil)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar benchmarkRows []*benchmarkRow\n\tfor libraryName := range libraryNameToMarkdownName {\n\t\tbenchmarkRow, err := getBenchmarkRow(\n\t\t\tbenchmarkOutput, benchmarkName, libraryName, baseline,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif benchmarkRow == nil {\n\t\t\tcontinue\n\t\t}\n\t\tbenchmarkRows = append(benchmarkRows, benchmarkRow)\n\t}\n\tsort.Sort(benchmarkRowsByTime(benchmarkRows))\n\trows := []string{\n\t\t\"| Package | Time | Time % to zap | Objects Allocated |\",\n\t\t\"| :------ | :--: | :-----------: | :---------------: |\",\n\t}\n\tfor _, benchmarkRow := range benchmarkRows {\n\t\trows = append(rows, benchmarkRow.String())\n\t}\n\treturn strings.Join(rows, \"\\n\"), nil\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":74,"end_line":93,"code":"func getTmplData() (*tmplData, error) {\n\ttmplData := \u0026tmplData{}\n\trows, err := getBenchmarkRows(\"BenchmarkAddingFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAddingFields = rows\n\trows, err = getBenchmarkRows(\"BenchmarkAccumulatedContext\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkAccumulatedContext = rows\n\trows, err = getBenchmarkRows(\"BenchmarkWithoutFields\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttmplData.BenchmarkWithoutFields = rows\n\treturn tmplData, nil\n}\n"},{"path":"internal/readme/readme.go","start_line":129,"end_line":148,"code":"\nfunc getBenchmarkRow(\n\tinput []string, benchmarkName string, libraryName string, baseline *benchmarkRow,\n) (*benchmarkRow, error) {\n\tline, err := findUniqueSubstring(input, fmt.Sprintf(\"%s/%s-\", benchmarkName, libraryName))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif line == \"\" {\n\t\treturn nil, nil\n\t}\n\tsplit := strings.Split(line, \"\\t\")\n\tif len(split) \u003c 5 {\n\t\treturn nil, fmt.Errorf(\"unknown benchmark line: %s\", line)\n\t}\n\tduration, err := time.ParseDuration(strings.ReplaceAll(strings.TrimSuffix(strings.TrimSpace(split[2]), \"/op\"), \" \", \"\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tallocatedBytes, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(split[3]), \" B/op\"))"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"(*benchmarkRow).String","path":"internal/readme/readme.go"},{"symbol":"Join","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"Sort","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"getBenchmarkOutput","path":"internal/readme/readme.go"},{"symbol":"getBenchmarkRow","path":"internal/readme/readme.go"}],"callers":[{"symbol":"getTmplData","path":"internal/readme/readme.go"},{"symbol":"loadLocation","path":"../../../../usr/local/go/src/time/zoneinfo_read.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"getBenchmarkRow","signature":"func getBenchmarkRow(\n\tinput []string, benchmarkName string, libraryName string, baseline *benchmarkRow,\n) (*benchmarkRow, error)","start_line":130,"end_line":170,"code":"func getBenchmarkRow(\n\tinput []string, benchmarkName string, libraryName string, baseline *benchmarkRow,\n) (*benchmarkRow, error) {\n\n\tline, err := findUniqueSubstring(input, fmt.Sprintf(\"%s/%s-\", benchmarkName, libraryName))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif line == \"\" {\n\t\treturn nil, nil\n\t}\n\tsplit := strings.Split(line, \"\\t\")\n\tif len(split) \u003c 5 {\n\t\treturn nil, fmt.Errorf(\"unknown benchmark line: %s\", line)\n\t}\n\tduration, err := time.ParseDuration(strings.ReplaceAll(strings.TrimSuffix(strings.TrimSpace(split[2]), \"/op\"), \" \", \"\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tallocatedBytes, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(split[3]), \" B/op\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tallocatedObjects, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(split[4]), \" allocs/op\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr := \u0026benchmarkRow{\n\t\tName:             libraryNameToMarkdownName[libraryName],\n\t\tTime:             duration,\n\t\tAllocatedBytes:   allocatedBytes,\n\t\tAllocatedObjects: allocatedObjects,\n\t}\n\n\tif baseline != nil {\n\t\tr.ZapTime = baseline.Time\n\t\tr.ZapAllocatedBytes = baseline.AllocatedBytes\n\t\tr.ZapAllocatedObjects = baseline.AllocatedObjects\n\t}\n\n\treturn r, nil\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":110,"end_line":129,"code":"\t\t)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif benchmarkRow == nil {\n\t\t\tcontinue\n\t\t}\n\t\tbenchmarkRows = append(benchmarkRows, benchmarkRow)\n\t}\n\tsort.Sort(benchmarkRowsByTime(benchmarkRows))\n\trows := []string{\n\t\t\"| Package | Time | Time % to zap | Objects Allocated |\",\n\t\t\"| :------ | :--: | :-----------: | :---------------: |\",\n\t}\n\tfor _, benchmarkRow := range benchmarkRows {\n\t\trows = append(rows, benchmarkRow.String())\n\t}\n\treturn strings.Join(rows, \"\\n\"), nil\n}\n"},{"path":"internal/readme/readme.go","start_line":171,"end_line":190,"code":"\nfunc findUniqueSubstring(input []string, substring string) (string, error) {\n\tvar output string\n\tfor _, line := range input {\n\t\tif strings.Contains(line, substring) {\n\t\t\tif output != \"\" {\n\t\t\t\treturn \"\", fmt.Errorf(\"input has duplicate substring %s\", substring)\n\t\t\t}\n\t\t\toutput = line\n\t\t}\n\t}\n\treturn output, nil\n}\n\nfunc getBenchmarkOutput(benchmarkName string) ([]string, error) {\n\tcmd := exec.Command(\"go\", \"test\", fmt.Sprintf(\"-bench=%s\", benchmarkName), \"-benchmem\")\n\tcmd.Dir = \"benchmarks\"\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error running 'go test -bench=%q': %v\\n%s\", benchmarkName, err, string(output))"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"Atoi","path":"../../../../usr/local/go/src/strconv/atoi.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"ParseDuration","path":"../../../../usr/local/go/src/time/format.go"},{"symbol":"ReplaceAll","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"Split","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"TrimSpace","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"TrimSuffix","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"findUniqueSubstring","path":"internal/readme/readme.go"}],"callers":[{"symbol":"getBenchmarkRows","path":"internal/readme/readme.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"findUniqueSubstring","signature":"func findUniqueSubstring(input []string, substring string) (string, error)","start_line":172,"end_line":183,"code":"func findUniqueSubstring(input []string, substring string) (string, error) {\n\n\tvar output string\n\tfor _, line := range input {\n\t\tif strings.Contains(line, substring) {\n\t\t\tif output != \"\" {\n\t\t\t\treturn \"\", fmt.Errorf(\"input has duplicate substring %s\", substring)\n\t\t\t}\n\t\t\toutput = line\n\t\t}\n\t}\n\treturn output, nil\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":152,"end_line":171,"code":"\tallocatedObjects, err := strconv.Atoi(strings.TrimSuffix(strings.TrimSpace(split[4]), \" allocs/op\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr := \u0026benchmarkRow{\n\t\tName:             libraryNameToMarkdownName[libraryName],\n\t\tTime:             duration,\n\t\tAllocatedBytes:   allocatedBytes,\n\t\tAllocatedObjects: allocatedObjects,\n\t}\n\n\tif baseline != nil {\n\t\tr.ZapTime = baseline.Time\n\t\tr.ZapAllocatedBytes = baseline.AllocatedBytes\n\t\tr.ZapAllocatedObjects = baseline.AllocatedObjects\n\t}\n\n\treturn r, nil\n}\n"},{"path":"internal/readme/readme.go","start_line":184,"end_line":203,"code":"\nfunc getBenchmarkOutput(benchmarkName string) ([]string, error) {\n\tcmd := exec.Command(\"go\", \"test\", fmt.Sprintf(\"-bench=%s\", benchmarkName), \"-benchmem\")\n\tcmd.Dir = \"benchmarks\"\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error running 'go test -bench=%q': %v\\n%s\", benchmarkName, err, string(output))\n\t}\n\treturn strings.Split(string(output), \"\\n\"), nil\n}\n\ntype tmplData struct {\n\tBenchmarkAddingFields       string\n\tBenchmarkAccumulatedContext string\n\tBenchmarkWithoutFields      string\n}\n\ntype benchmarkRow struct {\n\tName string\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"Contains","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"}],"callers":[{"symbol":"getBenchmarkRow","path":"internal/readme/readme.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"getBenchmarkOutput","signature":"func getBenchmarkOutput(benchmarkName string) ([]string, error)","start_line":185,"end_line":193,"code":"func getBenchmarkOutput(benchmarkName string) ([]string, error) {\n\n\tcmd := exec.Command(\"go\", \"test\", fmt.Sprintf(\"-bench=%s\", benchmarkName), \"-benchmem\")\n\tcmd.Dir = \"benchmarks\"\n\toutput, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error running 'go test -bench=%q': %v\\n%s\", benchmarkName, err, string(output))\n\t}\n\treturn strings.Split(string(output), \"\\n\"), nil\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":165,"end_line":184,"code":"\t\tr.ZapAllocatedBytes = baseline.AllocatedBytes\n\t\tr.ZapAllocatedObjects = baseline.AllocatedObjects\n\t}\n\n\treturn r, nil\n}\n\nfunc findUniqueSubstring(input []string, substring string) (string, error) {\n\tvar output string\n\tfor _, line := range input {\n\t\tif strings.Contains(line, substring) {\n\t\t\tif output != \"\" {\n\t\t\t\treturn \"\", fmt.Errorf(\"input has duplicate substring %s\", substring)\n\t\t\t}\n\t\t\toutput = line\n\t\t}\n\t}\n\treturn output, nil\n}\n"},{"path":"internal/readme/readme.go","start_line":194,"end_line":213,"code":"\ntype tmplData struct {\n\tBenchmarkAddingFields       string\n\tBenchmarkAccumulatedContext string\n\tBenchmarkWithoutFields      string\n}\n\ntype benchmarkRow struct {\n\tName string\n\n\tTime             time.Duration\n\tAllocatedBytes   int\n\tAllocatedObjects int\n\n\tZapTime             time.Duration\n\tZapAllocatedBytes   int\n\tZapAllocatedObjects int\n}\n\nfunc (b *benchmarkRow) String() string {"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Cmd).CombinedOutput","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"Command","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"Split","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"getBenchmarkRows","path":"internal/readme/readme.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"(*benchmarkRow).String","signature":"func (b *benchmarkRow) String() string","start_line":213,"end_line":227,"code":"func (b *benchmarkRow) String() string {\n\n\tpct := func(val, baseline int64) string {\n\t\treturn fmt.Sprintf(\n\t\t\t\"%+0.f%%\",\n\t\t\t((float64(val)/float64(baseline))*100)-100,\n\t\t)\n\t}\n\tt := b.Time.Nanoseconds()\n\ttp := pct(t, b.ZapTime.Nanoseconds())\n\n\treturn fmt.Sprintf(\n\t\t\"| %s | %d ns/op | %s | %d allocs/op\", b.Name,\n\t\tt, tp, b.AllocatedObjects,\n\t)\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":193,"end_line":212,"code":"}\n\ntype tmplData struct {\n\tBenchmarkAddingFields       string\n\tBenchmarkAccumulatedContext string\n\tBenchmarkWithoutFields      string\n}\n\ntype benchmarkRow struct {\n\tName string\n\n\tTime             time.Duration\n\tAllocatedBytes   int\n\tAllocatedObjects int\n\n\tZapTime             time.Duration\n\tZapAllocatedBytes   int\n\tZapAllocatedObjects int\n}\n"},{"path":"internal/readme/readme.go","start_line":228,"end_line":244,"code":"\ntype benchmarkRowsByTime []*benchmarkRow\n\nfunc (b benchmarkRowsByTime) Len() int      { return len(b) }\nfunc (b benchmarkRowsByTime) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\nfunc (b benchmarkRowsByTime) Less(i, j int) bool {\n\tleft, right := b[i], b[j]\n\tleftZap, rightZap := strings.Contains(left.Name, \"zap\"), strings.Contains(right.Name, \"zap\")\n\n\t// If neither benchmark is for zap or both are, sort by time.\n\tif leftZap == rightZap {\n\t\treturn left.Time.Nanoseconds() \u003c right.Time.Nanoseconds()\n\t}\n\t// Sort zap benchmark first.\n\treturn leftZap\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.78},"call_graph":{"callees":[{"symbol":"(Duration).Nanoseconds","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"String$1","path":"internal/readme/readme.go"}],"callers":[{"symbol":"(*pp).handleMethods","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"(http2FrameWriteRequest).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"contextName","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"getBenchmarkRows","path":"internal/readme/readme.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"stringify","path":"../../../../usr/local/go/src/context/context.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"(benchmarkRowsByTime).Len","signature":"func (b benchmarkRowsByTime) Len() int","start_line":231,"end_line":231,"code":"func (b benchmarkRowsByTime) Len() int      {\n return len(b) }\n","neighbors":[{"path":"internal/readme/readme.go","start_line":211,"end_line":230,"code":"}\n\nfunc (b *benchmarkRow) String() string {\n\tpct := func(val, baseline int64) string {\n\t\treturn fmt.Sprintf(\n\t\t\t\"%+0.f%%\",\n\t\t\t((float64(val)/float64(baseline))*100)-100,\n\t\t)\n\t}\n\tt := b.Time.Nanoseconds()\n\ttp := pct(t, b.ZapTime.Nanoseconds())\n\n\treturn fmt.Sprintf(\n\t\t\"| %s | %d ns/op | %s | %d allocs/op\", b.Name,\n\t\tt, tp, b.AllocatedObjects,\n\t)\n}\n\ntype benchmarkRowsByTime []*benchmarkRow\n"},{"path":"internal/readme/readme.go","start_line":232,"end_line":244,"code":"func (b benchmarkRowsByTime) Swap(i, j int) { b[i], b[j] = b[j], b[i] }\nfunc (b benchmarkRowsByTime) Less(i, j int) bool {\n\tleft, right := b[i], b[j]\n\tleftZap, rightZap := strings.Contains(left.Name, \"zap\"), strings.Contains(right.Name, \"zap\")\n\n\t// If neither benchmark is for zap or both are, sort by time.\n\tif leftZap == rightZap {\n\t\treturn left.Time.Nanoseconds() \u003c right.Time.Nanoseconds()\n\t}\n\t// Sort zap benchmark first.\n\treturn leftZap\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*benchmarkRowsByTime).Len","path":"internal/readme/readme.go"},{"symbol":"IsSorted","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"Sort","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"Stable","path":"../../../../usr/local/go/src/sort/sort.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"(benchmarkRowsByTime).Swap","signature":"func (b benchmarkRowsByTime) Swap(i, j int)","start_line":232,"end_line":232,"code":"func (b benchmarkRowsByTime) Swap(i, j int) {\n b[i], b[j] = b[j], b[i] }\n","neighbors":[{"path":"internal/readme/readme.go","start_line":212,"end_line":231,"code":"\nfunc (b *benchmarkRow) String() string {\n\tpct := func(val, baseline int64) string {\n\t\treturn fmt.Sprintf(\n\t\t\t\"%+0.f%%\",\n\t\t\t((float64(val)/float64(baseline))*100)-100,\n\t\t)\n\t}\n\tt := b.Time.Nanoseconds()\n\ttp := pct(t, b.ZapTime.Nanoseconds())\n\n\treturn fmt.Sprintf(\n\t\t\"| %s | %d ns/op | %s | %d allocs/op\", b.Name,\n\t\tt, tp, b.AllocatedObjects,\n\t)\n}\n\ntype benchmarkRowsByTime []*benchmarkRow\n\nfunc (b benchmarkRowsByTime) Len() int      { return len(b) }"},{"path":"internal/readme/readme.go","start_line":233,"end_line":244,"code":"func (b benchmarkRowsByTime) Less(i, j int) bool {\n\tleft, right := b[i], b[j]\n\tleftZap, rightZap := strings.Contains(left.Name, \"zap\"), strings.Contains(right.Name, \"zap\")\n\n\t// If neither benchmark is for zap or both are, sort by time.\n\tif leftZap == rightZap {\n\t\treturn left.Time.Nanoseconds() \u003c right.Time.Nanoseconds()\n\t}\n\t// Sort zap benchmark first.\n\treturn leftZap\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*benchmarkRowsByTime).Swap","path":"internal/readme/readme.go"},{"symbol":"breakPatterns","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"heapSort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"insertionSort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partialInsertionSort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partition","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partitionEqual","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"reverseRange","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"siftDown","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"swapRange","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"symMerge","path":"../../../../usr/local/go/src/sort/zsortinterface.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/readme/readme.go","symbol":"(benchmarkRowsByTime).Less","signature":"func (b benchmarkRowsByTime) Less(i, j int) bool","start_line":233,"end_line":243,"code":"func (b benchmarkRowsByTime) Less(i, j int) bool {\n\n\tleft, right := b[i], b[j]\n\tleftZap, rightZap := strings.Contains(left.Name, \"zap\"), strings.Contains(right.Name, \"zap\")\n\n\t\n\tif leftZap == rightZap {\n\t\treturn left.Time.Nanoseconds() \u003c right.Time.Nanoseconds()\n\t}\n\t\n\treturn leftZap\n}\n","neighbors":[{"path":"internal/readme/readme.go","start_line":213,"end_line":232,"code":"func (b *benchmarkRow) String() string {\n\tpct := func(val, baseline int64) string {\n\t\treturn fmt.Sprintf(\n\t\t\t\"%+0.f%%\",\n\t\t\t((float64(val)/float64(baseline))*100)-100,\n\t\t)\n\t}\n\tt := b.Time.Nanoseconds()\n\ttp := pct(t, b.ZapTime.Nanoseconds())\n\n\treturn fmt.Sprintf(\n\t\t\"| %s | %d ns/op | %s | %d allocs/op\", b.Name,\n\t\tt, tp, b.AllocatedObjects,\n\t)\n}\n\ntype benchmarkRowsByTime []*benchmarkRow\n\nfunc (b benchmarkRowsByTime) Len() int      { return len(b) }\nfunc (b benchmarkRowsByTime) Swap(i, j int) { b[i], b[j] = b[j], b[i] }"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(Duration).Nanoseconds","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"Contains","path":"../../../../usr/local/go/src/strings/strings.go"}],"callers":[{"symbol":"(*benchmarkRowsByTime).Less","path":"internal/readme/readme.go"},{"symbol":"(reverse).Less","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"IsSorted","path":"../../../../usr/local/go/src/sort/sort.go"},{"symbol":"insertionSort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"order2","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partialInsertionSort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partition","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"partitionEqual","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"pdqsort","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"siftDown","path":"../../../../usr/local/go/src/sort/zsortinterface.go"},{"symbol":"symMerge","path":"../../../../usr/local/go/src/sort/zsortinterface.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"Capture","signature":"func Capture(skip int, depth Depth) *Stack","start_line":71,"end_line":109,"code":"func Capture(skip int, depth Depth) *Stack {\n\n\tstack := _stackPool.Get()\n\n\tswitch depth {\n\tcase First:\n\t\tstack.pcs = stack.storage[:1]\n\tcase Full:\n\t\tstack.pcs = stack.storage\n\t}\n\n\t\n\t\n\tnumFrames := runtime.Callers(\n\t\tskip+2,\n\t\tstack.pcs,\n\t)\n\n\t\n\t\n\t\n\tif depth == Full {\n\t\tpcs := stack.pcs\n\t\tfor numFrames == len(pcs) {\n\t\t\tpcs = make([]uintptr, len(pcs)*2)\n\t\t\tnumFrames = runtime.Callers(skip+2, pcs)\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\tstack.storage = pcs\n\t\tstack.pcs = pcs[:numFrames]\n\t} else {\n\t\tstack.pcs = stack.pcs[:numFrames]\n\t}\n\n\tstack.frames = runtime.CallersFrames(stack.pcs)\n\treturn stack\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":51,"end_line":70,"code":"\tstorage []uintptr\n}\n\n// Depth specifies how deep of a stack trace should be captured.\ntype Depth int\n\nconst (\n\t// First captures only the first frame.\n\tFirst Depth = iota\n\n\t// Full captures the entire call stack, allocating more\n\t// storage for it if needed.\n\tFull\n)\n\n// Capture captures a stack trace of the specified depth, skipping\n// the provided number of frames. skip=0 identifies the caller of\n// Capture.\n//\n// The caller must call Free on the returned stacktrace after using it."},{"path":"internal/stacktrace/stack.go","start_line":110,"end_line":129,"code":"\n// Free releases resources associated with this stacktrace\n// and returns it back to the pool.\nfunc (st *Stack) Free() {\n\tst.frames = nil\n\tst.pcs = nil\n\t_stackPool.Put(st)\n}\n\n// Count reports the total number of frames in this stacktrace.\n// Count DOES NOT change as Next is called.\nfunc (st *Stack) Count() int {\n\treturn len(st.pcs)\n}\n\n// Next returns the next frame in the stack trace,\n// and a boolean indicating whether there are more after it.\nfunc (st *Stack) Next() (_ runtime.Frame, more bool) {\n\treturn st.frames.Next()\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Pool).Get[*go.uber.org/zap/internal/stacktrace.Stack]","path":"internal/pool/pool.go"},{"symbol":"Callers","path":"../../../../usr/local/go/src/runtime/extern.go"},{"symbol":"CallersFrames","path":"../../../../usr/local/go/src/runtime/symtab.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"(*Stack).Free","signature":"func (st *Stack) Free()","start_line":113,"end_line":117,"code":"func (st *Stack) Free() {\n\n\tst.frames = nil\n\tst.pcs = nil\n\t_stackPool.Put(st)\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":93,"end_line":112,"code":"\t\tfor numFrames == len(pcs) {\n\t\t\tpcs = make([]uintptr, len(pcs)*2)\n\t\t\tnumFrames = runtime.Callers(skip+2, pcs)\n\t\t}\n\n\t\t// Discard old storage instead of returning it to the pool.\n\t\t// This will adjust the pool size over time if stack traces are\n\t\t// consistently very deep.\n\t\tstack.storage = pcs\n\t\tstack.pcs = pcs[:numFrames]\n\t} else {\n\t\tstack.pcs = stack.pcs[:numFrames]\n\t}\n\n\tstack.frames = runtime.CallersFrames(stack.pcs)\n\treturn stack\n}\n\n// Free releases resources associated with this stacktrace\n// and returns it back to the pool."},{"path":"internal/stacktrace/stack.go","start_line":118,"end_line":137,"code":"\n// Count reports the total number of frames in this stacktrace.\n// Count DOES NOT change as Next is called.\nfunc (st *Stack) Count() int {\n\treturn len(st.pcs)\n}\n\n// Next returns the next frame in the stack trace,\n// and a boolean indicating whether there are more after it.\nfunc (st *Stack) Next() (_ runtime.Frame, more bool) {\n\treturn st.frames.Next()\n}\n\n// Take returns a string representation of the current stacktrace.\n//\n// skip is the number of frames to skip before recording the stack trace.\n// skip=0 identifies the caller of Take.\nfunc Take(skip int) string {\n\tstack := Capture(skip+1, Full)\n\tdefer stack.Free()"}],"selection":{"visibility":"exported","reason":"other","score":0.74},"call_graph":{"callees":[{"symbol":"(*Pool).Put[*go.uber.org/zap/internal/stacktrace.Stack]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"(*Stack).Count","signature":"func (st *Stack) Count() int","start_line":121,"end_line":123,"code":"func (st *Stack) Count() int {\n\n\treturn len(st.pcs)\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":101,"end_line":120,"code":"\t\tstack.storage = pcs\n\t\tstack.pcs = pcs[:numFrames]\n\t} else {\n\t\tstack.pcs = stack.pcs[:numFrames]\n\t}\n\n\tstack.frames = runtime.CallersFrames(stack.pcs)\n\treturn stack\n}\n\n// Free releases resources associated with this stacktrace\n// and returns it back to the pool.\nfunc (st *Stack) Free() {\n\tst.frames = nil\n\tst.pcs = nil\n\t_stackPool.Put(st)\n}\n\n// Count reports the total number of frames in this stacktrace.\n// Count DOES NOT change as Next is called."},{"path":"internal/stacktrace/stack.go","start_line":124,"end_line":143,"code":"\n// Next returns the next frame in the stack trace,\n// and a boolean indicating whether there are more after it.\nfunc (st *Stack) Next() (_ runtime.Frame, more bool) {\n\treturn st.frames.Next()\n}\n\n// Take returns a string representation of the current stacktrace.\n//\n// skip is the number of frames to skip before recording the stack trace.\n// skip=0 identifies the caller of Take.\nfunc Take(skip int) string {\n\tstack := Capture(skip+1, Full)\n\tdefer stack.Free()\n\n\tbuffer := bufferpool.Get()\n\tdefer buffer.Free()\n\n\tstackfmt := NewFormatter(buffer)\n\tstackfmt.FormatStack(stack)"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).check","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"(*Stack).Next","signature":"func (st *Stack) Next() (_ runtime.Frame, more bool)","start_line":127,"end_line":129,"code":"func (st *Stack) Next() (_ runtime.Frame, more bool) {\n\n\treturn st.frames.Next()\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":107,"end_line":126,"code":"\tstack.frames = runtime.CallersFrames(stack.pcs)\n\treturn stack\n}\n\n// Free releases resources associated with this stacktrace\n// and returns it back to the pool.\nfunc (st *Stack) Free() {\n\tst.frames = nil\n\tst.pcs = nil\n\t_stackPool.Put(st)\n}\n\n// Count reports the total number of frames in this stacktrace.\n// Count DOES NOT change as Next is called.\nfunc (st *Stack) Count() int {\n\treturn len(st.pcs)\n}\n\n// Next returns the next frame in the stack trace,\n// and a boolean indicating whether there are more after it."},{"path":"internal/stacktrace/stack.go","start_line":130,"end_line":149,"code":"\n// Take returns a string representation of the current stacktrace.\n//\n// skip is the number of frames to skip before recording the stack trace.\n// skip=0 identifies the caller of Take.\nfunc Take(skip int) string {\n\tstack := Capture(skip+1, Full)\n\tdefer stack.Free()\n\n\tbuffer := bufferpool.Get()\n\tdefer buffer.Free()\n\n\tstackfmt := NewFormatter(buffer)\n\tstackfmt.FormatStack(stack)\n\treturn buffer.String()\n}\n\n// Formatter formats a stack trace into a readable string representation.\ntype Formatter struct {\n\tb        *buffer.Buffer"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"(*Frames).Next","path":"../../../../usr/local/go/src/runtime/symtab.go"}],"callers":[{"symbol":"(*Formatter).FormatStack","path":"internal/stacktrace/stack.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"Take","signature":"func Take(skip int) string","start_line":135,"end_line":145,"code":"func Take(skip int) string {\n\n\tstack := Capture(skip+1, Full)\n\tdefer stack.Free()\n\n\tbuffer := bufferpool.Get()\n\tdefer buffer.Free()\n\n\tstackfmt := NewFormatter(buffer)\n\tstackfmt.FormatStack(stack)\n\treturn buffer.String()\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":115,"end_line":134,"code":"\tst.pcs = nil\n\t_stackPool.Put(st)\n}\n\n// Count reports the total number of frames in this stacktrace.\n// Count DOES NOT change as Next is called.\nfunc (st *Stack) Count() int {\n\treturn len(st.pcs)\n}\n\n// Next returns the next frame in the stack trace,\n// and a boolean indicating whether there are more after it.\nfunc (st *Stack) Next() (_ runtime.Frame, more bool) {\n\treturn st.frames.Next()\n}\n\n// Take returns a string representation of the current stacktrace.\n//\n// skip is the number of frames to skip before recording the stack trace.\n// skip=0 identifies the caller of Take."},{"path":"internal/stacktrace/stack.go","start_line":146,"end_line":165,"code":"\n// Formatter formats a stack trace into a readable string representation.\ntype Formatter struct {\n\tb        *buffer.Buffer\n\tnonEmpty bool // whehther we've written at least one frame already\n}\n\n// NewFormatter builds a new Formatter.\nfunc NewFormatter(b *buffer.Buffer) Formatter {\n\treturn Formatter{b: b}\n}\n\n// FormatStack formats all remaining frames in the provided stacktrace -- minus\n// the final runtime.main/runtime.goexit frame.\nfunc (sf *Formatter) FormatStack(stack *Stack) {\n\t// Note: On the last iteration, frames.Next() returns false, with a valid\n\t// frame, but we ignore this frame. The last frame is a runtime frame which\n\t// adds noise, since it's only either runtime.main or runtime.goexit.\n\tfor frame, more := stack.Next(); more; frame, more = stack.Next() {\n\t\tsf.FormatFrame(frame)"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Buffer).String","path":"buffer/buffer.go"},{"symbol":"(*Formatter).FormatStack","path":"internal/stacktrace/stack.go"},{"symbol":"(*Stack).Free","path":"internal/stacktrace/stack.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"Capture","path":"internal/stacktrace/stack.go"},{"symbol":"NewFormatter","path":"internal/stacktrace/stack.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"}],"callers":[{"symbol":"StackSkip","path":"field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"NewFormatter","signature":"func NewFormatter(b *buffer.Buffer) Formatter","start_line":154,"end_line":156,"code":"func NewFormatter(b *buffer.Buffer) Formatter {\n\n\treturn Formatter{b: b}\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":134,"end_line":153,"code":"// skip=0 identifies the caller of Take.\nfunc Take(skip int) string {\n\tstack := Capture(skip+1, Full)\n\tdefer stack.Free()\n\n\tbuffer := bufferpool.Get()\n\tdefer buffer.Free()\n\n\tstackfmt := NewFormatter(buffer)\n\tstackfmt.FormatStack(stack)\n\treturn buffer.String()\n}\n\n// Formatter formats a stack trace into a readable string representation.\ntype Formatter struct {\n\tb        *buffer.Buffer\n\tnonEmpty bool // whehther we've written at least one frame already\n}\n\n// NewFormatter builds a new Formatter."},{"path":"internal/stacktrace/stack.go","start_line":157,"end_line":176,"code":"\n// FormatStack formats all remaining frames in the provided stacktrace -- minus\n// the final runtime.main/runtime.goexit frame.\nfunc (sf *Formatter) FormatStack(stack *Stack) {\n\t// Note: On the last iteration, frames.Next() returns false, with a valid\n\t// frame, but we ignore this frame. The last frame is a runtime frame which\n\t// adds noise, since it's only either runtime.main or runtime.goexit.\n\tfor frame, more := stack.Next(); more; frame, more = stack.Next() {\n\t\tsf.FormatFrame(frame)\n\t}\n}\n\n// FormatFrame formats the given frame.\nfunc (sf *Formatter) FormatFrame(frame runtime.Frame) {\n\tif sf.nonEmpty {\n\t\tsf.b.AppendByte('\\n')\n\t}\n\tsf.nonEmpty = true\n\tsf.b.AppendString(frame.Function)\n\tsf.b.AppendByte('\\n')"}],"selection":{"visibility":"exported","reason":"constructor","score":0.76},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"(*Formatter).FormatStack","signature":"func (sf *Formatter) FormatStack(stack *Stack)","start_line":160,"end_line":167,"code":"func (sf *Formatter) FormatStack(stack *Stack) {\n\n\t\n\t\n\t\n\tfor frame, more := stack.Next(); more; frame, more = stack.Next() {\n\t\tsf.FormatFrame(frame)\n\t}\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":140,"end_line":159,"code":"\tdefer buffer.Free()\n\n\tstackfmt := NewFormatter(buffer)\n\tstackfmt.FormatStack(stack)\n\treturn buffer.String()\n}\n\n// Formatter formats a stack trace into a readable string representation.\ntype Formatter struct {\n\tb        *buffer.Buffer\n\tnonEmpty bool // whehther we've written at least one frame already\n}\n\n// NewFormatter builds a new Formatter.\nfunc NewFormatter(b *buffer.Buffer) Formatter {\n\treturn Formatter{b: b}\n}\n\n// FormatStack formats all remaining frames in the provided stacktrace -- minus\n// the final runtime.main/runtime.goexit frame."},{"path":"internal/stacktrace/stack.go","start_line":168,"end_line":182,"code":"\n// FormatFrame formats the given frame.\nfunc (sf *Formatter) FormatFrame(frame runtime.Frame) {\n\tif sf.nonEmpty {\n\t\tsf.b.AppendByte('\\n')\n\t}\n\tsf.nonEmpty = true\n\tsf.b.AppendString(frame.Function)\n\tsf.b.AppendByte('\\n')\n\tsf.b.AppendByte('\\t')\n\tsf.b.AppendString(frame.File)\n\tsf.b.AppendByte(':')\n\tsf.b.AppendInt(int64(frame.Line))\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Formatter).FormatFrame","path":"internal/stacktrace/stack.go"},{"symbol":"(*Stack).Next","path":"internal/stacktrace/stack.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"Take","path":"internal/stacktrace/stack.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/stacktrace/stack.go","symbol":"(*Formatter).FormatFrame","signature":"func (sf *Formatter) FormatFrame(frame runtime.Frame)","start_line":170,"end_line":181,"code":"func (sf *Formatter) FormatFrame(frame runtime.Frame) {\n\n\tif sf.nonEmpty {\n\t\tsf.b.AppendByte('\\n')\n\t}\n\tsf.nonEmpty = true\n\tsf.b.AppendString(frame.Function)\n\tsf.b.AppendByte('\\n')\n\tsf.b.AppendByte('\\t')\n\tsf.b.AppendString(frame.File)\n\tsf.b.AppendByte(':')\n\tsf.b.AppendInt(int64(frame.Line))\n}\n","neighbors":[{"path":"internal/stacktrace/stack.go","start_line":150,"end_line":169,"code":"\tnonEmpty bool // whehther we've written at least one frame already\n}\n\n// NewFormatter builds a new Formatter.\nfunc NewFormatter(b *buffer.Buffer) Formatter {\n\treturn Formatter{b: b}\n}\n\n// FormatStack formats all remaining frames in the provided stacktrace -- minus\n// the final runtime.main/runtime.goexit frame.\nfunc (sf *Formatter) FormatStack(stack *Stack) {\n\t// Note: On the last iteration, frames.Next() returns false, with a valid\n\t// frame, but we ignore this frame. The last frame is a runtime frame which\n\t// adds noise, since it's only either runtime.main or runtime.goexit.\n\tfor frame, more := stack.Next(); more; frame, more = stack.Next() {\n\t\tsf.FormatFrame(frame)\n\t}\n}\n\n// FormatFrame formats the given frame."}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendInt","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*Formatter).FormatStack","path":"internal/stacktrace/stack.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/clock.go","symbol":"NewMockClock","signature":"func NewMockClock() *MockClock","start_line":47,"end_line":51,"code":"func NewMockClock() *MockClock {\n\n\treturn \u0026MockClock{\n\t\tnow: time.Now(),\n\t}\n}\n","neighbors":[{"path":"internal/ztest/clock.go","start_line":27,"end_line":46,"code":")\n\n// MockClock is a fake source of time.\n// It implements standard time operations,\n// but allows the user to control the passage of time.\n//\n// Use the [Add] method to progress time.\ntype MockClock struct {\n\tmu  sync.RWMutex\n\tnow time.Time\n\n\t// The MockClock works by maintaining a list of waiters.\n\t// Each waiter knows the time at which it should be resolved.\n\t// When the clock advances, all waiters that are in range are resolved\n\t// in chronological order.\n\twaiters []waiter\n}\n\n// NewMockClock builds a new mock clock\n// using the current actual time as the initial time."},{"path":"internal/ztest/clock.go","start_line":52,"end_line":71,"code":"\n// Now reports the current time.\nfunc (c *MockClock) Now() time.Time {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.now\n}\n\n// NewTicker returns a time.Ticker that ticks at the specified frequency.\n//\n// As with [time.NewTicker],\n// the ticker will drop ticks if the receiver is slow,\n// and the channel is never closed.\n//\n// Calling Stop on the returned ticker is a no-op.\n// The ticker only runs when the clock is advanced.\nfunc (c *MockClock) NewTicker(d time.Duration) *time.Ticker {\n\tch := make(chan time.Time, 1)\n\n\tvar tick func(time.Time)"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"Now","path":"../../../../usr/local/go/src/time/time.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/clock.go","symbol":"(*MockClock).Now","signature":"func (c *MockClock) Now() time.Time","start_line":54,"end_line":58,"code":"func (c *MockClock) Now() time.Time {\n\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.now\n}\n","neighbors":[{"path":"internal/ztest/clock.go","start_line":34,"end_line":53,"code":"type MockClock struct {\n\tmu  sync.RWMutex\n\tnow time.Time\n\n\t// The MockClock works by maintaining a list of waiters.\n\t// Each waiter knows the time at which it should be resolved.\n\t// When the clock advances, all waiters that are in range are resolved\n\t// in chronological order.\n\twaiters []waiter\n}\n\n// NewMockClock builds a new mock clock\n// using the current actual time as the initial time.\nfunc NewMockClock() *MockClock {\n\treturn \u0026MockClock{\n\t\tnow: time.Now(),\n\t}\n}\n\n// Now reports the current time."},{"path":"internal/ztest/clock.go","start_line":59,"end_line":78,"code":"\n// NewTicker returns a time.Ticker that ticks at the specified frequency.\n//\n// As with [time.NewTicker],\n// the ticker will drop ticks if the receiver is slow,\n// and the channel is never closed.\n//\n// Calling Stop on the returned ticker is a no-op.\n// The ticker only runs when the clock is advanced.\nfunc (c *MockClock) NewTicker(d time.Duration) *time.Ticker {\n\tch := make(chan time.Time, 1)\n\n\tvar tick func(time.Time)\n\ttick = func(now time.Time) {\n\t\tnext := now.Add(d)\n\t\tc.runAt(next, func() {\n\t\t\tdefer tick(next)\n\n\t\t\tselect {\n\t\t\tcase ch \u003c- next:"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*MockClock).NewTicker","path":"internal/ztest/clock.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/clock.go","symbol":"(*MockClock).NewTicker","signature":"func (c *MockClock) NewTicker(d time.Duration) *time.Ticker","start_line":68,"end_line":89,"code":"func (c *MockClock) NewTicker(d time.Duration) *time.Ticker {\n\n\tch := make(chan time.Time, 1)\n\n\tvar tick func(time.Time)\n\ttick = func(now time.Time) {\n\t\tnext := now.Add(d)\n\t\tc.runAt(next, func() {\n\t\t\tdefer tick(next)\n\n\t\t\tselect {\n\t\t\tcase ch \u003c- next:\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t})\n\t}\n\ttick(c.Now())\n\n\treturn \u0026time.Ticker{C: ch}\n}\n","neighbors":[{"path":"internal/ztest/clock.go","start_line":48,"end_line":67,"code":"\treturn \u0026MockClock{\n\t\tnow: time.Now(),\n\t}\n}\n\n// Now reports the current time.\nfunc (c *MockClock) Now() time.Time {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\treturn c.now\n}\n\n// NewTicker returns a time.Ticker that ticks at the specified frequency.\n//\n// As with [time.NewTicker],\n// the ticker will drop ticks if the receiver is slow,\n// and the channel is never closed.\n//\n// Calling Stop on the returned ticker is a no-op.\n// The ticker only runs when the clock is advanced."},{"path":"internal/ztest/clock.go","start_line":90,"end_line":109,"code":"\n// runAt schedules the given function to be run at the given time.\n// The function runs without a lock held, so it may schedule more work.\nfunc (c *MockClock) runAt(t time.Time, fn func()) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.waiters = append(c.waiters, waiter{until: t, fn: fn})\n}\n\ntype waiter struct {\n\tuntil time.Time\n\tfn    func()\n}\n\n// Add progresses time by the given duration.\n// Other operations waiting for the time to advance\n// will be resolved if they are within range.\n//\n// Side effects of operations waiting for the time to advance\n// will take effect on a best-effort basis."}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":[{"symbol":"(*MockClock).Now","path":"internal/ztest/clock.go"},{"symbol":"NewTicker$1","path":"internal/ztest/clock.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).initialize","path":"zapcore/buffered_write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/clock.go","symbol":"(*MockClock).runAt","signature":"func (c *MockClock) runAt(t time.Time, fn func())","start_line":93,"end_line":97,"code":"func (c *MockClock) runAt(t time.Time, fn func()) {\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.waiters = append(c.waiters, waiter{until: t, fn: fn})\n}\n","neighbors":[{"path":"internal/ztest/clock.go","start_line":73,"end_line":92,"code":"\t\tnext := now.Add(d)\n\t\tc.runAt(next, func() {\n\t\t\tdefer tick(next)\n\n\t\t\tselect {\n\t\t\tcase ch \u003c- next:\n\t\t\t\t// ok\n\t\t\tdefault:\n\t\t\t\t// The receiver is slow.\n\t\t\t\t// Drop the tick and continue.\n\t\t\t}\n\t\t})\n\t}\n\ttick(c.Now())\n\n\treturn \u0026time.Ticker{C: ch}\n}\n\n// runAt schedules the given function to be run at the given time.\n// The function runs without a lock held, so it may schedule more work."},{"path":"internal/ztest/clock.go","start_line":98,"end_line":117,"code":"\ntype waiter struct {\n\tuntil time.Time\n\tfn    func()\n}\n\n// Add progresses time by the given duration.\n// Other operations waiting for the time to advance\n// will be resolved if they are within range.\n//\n// Side effects of operations waiting for the time to advance\n// will take effect on a best-effort basis.\n// Avoid racing with operations that have side effects.\n//\n// Panics if the duration is negative.\nfunc (c *MockClock) Add(d time.Duration) {\n\tif d \u003c 0 {\n\t\tpanic(\"cannot add negative duration\")\n\t}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":[{"symbol":"NewTicker$1","path":"internal/ztest/clock.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/clock.go","symbol":"(*MockClock).Add","signature":"func (c *MockClock) Add(d time.Duration)","start_line":113,"end_line":153,"code":"func (c *MockClock) Add(d time.Duration) {\n\n\tif d \u003c 0 {\n\t\tpanic(\"cannot add negative duration\")\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tsort.Slice(c.waiters, func(i, j int) bool {\n\t\treturn c.waiters[i].until.Before(c.waiters[j].until)\n\t})\n\n\tnewTime := c.now.Add(d)\n\t\n\t\n\t\n\n\tfor len(c.waiters) \u003e 0 {\n\t\tw := c.waiters[0]\n\t\tif w.until.After(newTime) {\n\t\t\tbreak\n\t\t}\n\t\tc.waiters[0] = waiter{} \n\t\tc.waiters = c.waiters[1:]\n\n\t\t\n\t\t\n\t\tc.now = w.until\n\n\t\t\n\t\t\n\t\tc.mu.Unlock()\n\t\tw.fn()\n\t\t\n\t\t\n\t\ttime.Sleep(1 * time.Millisecond)\n\t\tc.mu.Lock()\n\t}\n\n\tc.now = newTime\n}\n","neighbors":[{"path":"internal/ztest/clock.go","start_line":93,"end_line":112,"code":"func (c *MockClock) runAt(t time.Time, fn func()) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.waiters = append(c.waiters, waiter{until: t, fn: fn})\n}\n\ntype waiter struct {\n\tuntil time.Time\n\tfn    func()\n}\n\n// Add progresses time by the given duration.\n// Other operations waiting for the time to advance\n// will be resolved if they are within range.\n//\n// Side effects of operations waiting for the time to advance\n// will take effect on a best-effort basis.\n// Avoid racing with operations that have side effects.\n//\n// Panics if the duration is negative."}],"selection":{"visibility":"exported","reason":"other","score":0.73},"call_graph":{"callees":[{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*http2serverConn).onShutdownTimer","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(Time).Add","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Time).After","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"Sleep","path":"../../../../usr/local/go/src/time/sleep.go"},{"symbol":"Slice","path":"../../../../usr/local/go/src/sort/slice.go"},{"symbol":"Start$1","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"alloc$1","path":"../../../../usr/local/go/src/runtime/mheap.go"},{"symbol":"debugCallV2","path":"../../../../usr/local/go/src/runtime/debugcall.go"},{"symbol":"entersyscall","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"gcStart$4","path":"../../../../usr/local/go/src/runtime/mgc.go"},{"symbol":"init#2","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512block_arm64.go"},{"symbol":"initMimeUnix","path":"../../../../usr/local/go/src/mime/type_unix.go"},{"symbol":"libc_accept_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_fchown_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_mkdirat_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/at_darwin.go"},{"symbol":"libc_munlockall_trampoline","path":"../../../../usr/local/go/src/syscall/zsyscall_darwin_arm64.go"},{"symbol":"libc_sysconf_trampoline","path":"../../../../usr/local/go/src/internal/syscall/unix/user_darwin.go"},{"symbol":"maybeRunAsync$1","path":"../../../../usr/local/go/src/runtime/time.go"},{"symbol":"netpollBreak","path":"../../../../usr/local/go/src/runtime/netpoll_kqueue.go"},{"symbol":"panicunsafeslicelen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"panicunsafestringlen","path":"../../../../usr/local/go/src/runtime/unsafe.go"},{"symbol":"read_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"restoreSIGSYS","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"sigpanic","path":"../../../../usr/local/go/src/runtime/signal_unix.go"},{"symbol":"sigprocmask_trampoline","path":"../../../../usr/local/go/src/runtime/sys_darwin.go"},{"symbol":"startTheWorld$1","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"syscall_runtime_AfterFork","path":"../../../../usr/local/go/src/runtime/proc.go"},{"symbol":"x509_CFDictionaryGetValueIfPresent_trampoline","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/corefoundation.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/timeout.go","symbol":"Timeout","signature":"func Timeout(base time.Duration) time.Duration","start_line":33,"end_line":35,"code":"func Timeout(base time.Duration) time.Duration {\n\n\treturn time.Duration(float64(base) * _timeoutScale)\n}\n","neighbors":[{"path":"internal/ztest/timeout.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ztest\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar _timeoutScale = 1.0\n\n// Timeout scales the provided duration by $TEST_TIMEOUT_SCALE."},{"path":"internal/ztest/timeout.go","start_line":36,"end_line":55,"code":"\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE.\nfunc Sleep(base time.Duration) {\n\ttime.Sleep(Timeout(base))\n}\n\n// Initialize checks the environment and alters the timeout scale accordingly.\n// It returns a function to undo the scaling.\nfunc Initialize(factor string) func() {\n\tfv, err := strconv.ParseFloat(factor, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\toriginal := _timeoutScale\n\t_timeoutScale = fv\n\treturn func() { _timeoutScale = original }\n}\n\nfunc init() {\n\tif v := os.Getenv(\"TEST_TIMEOUT_SCALE\"); v != \"\" {"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":null,"callers":[{"symbol":"Sleep","path":"internal/ztest/timeout.go"},{"symbol":"Timeout","path":"zaptest/timeout.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/timeout.go","symbol":"Sleep","signature":"func Sleep(base time.Duration)","start_line":38,"end_line":40,"code":"func Sleep(base time.Duration) {\n\n\ttime.Sleep(Timeout(base))\n}\n","neighbors":[{"path":"internal/ztest/timeout.go","start_line":18,"end_line":37,"code":"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ztest\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar _timeoutScale = 1.0\n\n// Timeout scales the provided duration by $TEST_TIMEOUT_SCALE.\nfunc Timeout(base time.Duration) time.Duration {\n\treturn time.Duration(float64(base) * _timeoutScale)\n}\n\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE."},{"path":"internal/ztest/timeout.go","start_line":41,"end_line":60,"code":"\n// Initialize checks the environment and alters the timeout scale accordingly.\n// It returns a function to undo the scaling.\nfunc Initialize(factor string) func() {\n\tfv, err := strconv.ParseFloat(factor, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\toriginal := _timeoutScale\n\t_timeoutScale = fv\n\treturn func() { _timeoutScale = original }\n}\n\nfunc init() {\n\tif v := os.Getenv(\"TEST_TIMEOUT_SCALE\"); v != \"\" {\n\t\tInitialize(v)\n\t\tlog.Printf(\"Scaling timeouts by %vx.\\n\", _timeoutScale)\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"Sleep","path":"../../../../usr/local/go/src/time/sleep.go"},{"symbol":"Timeout","path":"internal/ztest/timeout.go"}],"callers":[{"symbol":"Sleep","path":"zaptest/timeout.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/timeout.go","symbol":"Initialize","signature":"func Initialize(factor string) func()","start_line":44,"end_line":52,"code":"func Initialize(factor string) func() {\n\n\tfv, err := strconv.ParseFloat(factor, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\toriginal := _timeoutScale\n\t_timeoutScale = fv\n\treturn func() { _timeoutScale = original }\n}\n","neighbors":[{"path":"internal/ztest/timeout.go","start_line":24,"end_line":43,"code":"\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar _timeoutScale = 1.0\n\n// Timeout scales the provided duration by $TEST_TIMEOUT_SCALE.\nfunc Timeout(base time.Duration) time.Duration {\n\treturn time.Duration(float64(base) * _timeoutScale)\n}\n\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE.\nfunc Sleep(base time.Duration) {\n\ttime.Sleep(Timeout(base))\n}\n\n// Initialize checks the environment and alters the timeout scale accordingly.\n// It returns a function to undo the scaling."},{"path":"internal/ztest/timeout.go","start_line":53,"end_line":60,"code":"\nfunc init() {\n\tif v := os.Getenv(\"TEST_TIMEOUT_SCALE\"); v != \"\" {\n\t\tInitialize(v)\n\t\tlog.Printf(\"Scaling timeouts by %vx.\\n\", _timeoutScale)\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"ParseFloat","path":"../../../../usr/local/go/src/strconv/atof.go"}],"callers":[{"symbol":"(*godebugInc).IncNonDefault","path":"../../../../usr/local/go/src/runtime/runtime.go"},{"symbol":"init#1","path":"internal/ztest/timeout.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/timeout.go","symbol":"init","signature":"func init()","start_line":54,"end_line":59,"code":"func init() {\n\n\tif v := os.Getenv(\"TEST_TIMEOUT_SCALE\"); v != \"\" {\n\t\tInitialize(v)\n\t\tlog.Printf(\"Scaling timeouts by %vx.\\n\", _timeoutScale)\n\t}\n}\n","neighbors":[{"path":"internal/ztest/timeout.go","start_line":34,"end_line":53,"code":"\treturn time.Duration(float64(base) * _timeoutScale)\n}\n\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE.\nfunc Sleep(base time.Duration) {\n\ttime.Sleep(Timeout(base))\n}\n\n// Initialize checks the environment and alters the timeout scale accordingly.\n// It returns a function to undo the scaling.\nfunc Initialize(factor string) func() {\n\tfv, err := strconv.ParseFloat(factor, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\toriginal := _timeoutScale\n\t_timeoutScale = fv\n\treturn func() { _timeoutScale = original }\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Syncer).SetError","signature":"func (s *Syncer) SetError(err error)","start_line":37,"end_line":39,"code":"func (s *Syncer) SetError(err error) {\n\n\ts.err = err\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":17,"end_line":36,"code":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ztest\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n)\n\n// A Syncer is a spy for the Sync portion of zapcore.WriteSyncer.\ntype Syncer struct {\n\terr    error\n\tcalled bool\n}\n\n// SetError sets the error that the Sync method will return."},{"path":"internal/ztest/writer.go","start_line":40,"end_line":59,"code":"\n// Sync records that it was called, then returns the user-supplied error (if\n// any).\nfunc (s *Syncer) Sync() error {\n\ts.called = true\n\treturn s.err\n}\n\n// Called reports whether the Sync method was called.\nfunc (s *Syncer) Called() bool {\n\treturn s.called\n}\n\n// A Discarder sends all writes to io.Discard.\ntype Discarder struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (d *Discarder) Write(b []byte) (int, error) {\n\treturn io.Discard.Write(b)\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffer).SetError","path":"internal/ztest/writer.go"},{"symbol":"(*Discarder).SetError","path":"internal/ztest/writer.go"},{"symbol":"(*FailWriter).SetError","path":"internal/ztest/writer.go"},{"symbol":"(*ShortWriter).SetError","path":"internal/ztest/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Syncer).Sync","signature":"func (s *Syncer) Sync() error","start_line":43,"end_line":46,"code":"func (s *Syncer) Sync() error {\n\n\ts.called = true\n\treturn s.err\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":23,"end_line":42,"code":"import (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n)\n\n// A Syncer is a spy for the Sync portion of zapcore.WriteSyncer.\ntype Syncer struct {\n\terr    error\n\tcalled bool\n}\n\n// SetError sets the error that the Sync method will return.\nfunc (s *Syncer) SetError(err error) {\n\ts.err = err\n}\n\n// Sync records that it was called, then returns the user-supplied error (if\n// any)."},{"path":"internal/ztest/writer.go","start_line":47,"end_line":66,"code":"\n// Called reports whether the Sync method was called.\nfunc (s *Syncer) Called() bool {\n\treturn s.called\n}\n\n// A Discarder sends all writes to io.Discard.\ntype Discarder struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (d *Discarder) Write(b []byte) (int, error) {\n\treturn io.Discard.Write(b)\n}\n\n// FailWriter is a WriteSyncer that always returns an error on writes.\ntype FailWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w FailWriter) Write(b []byte) (int, error) {\n\treturn len(b), errors.New(\"failed\")"}],"selection":{"visibility":"exported","reason":"other","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Discarder).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*FailWriter).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ShortWriter).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Syncer).Called","signature":"func (s *Syncer) Called() bool","start_line":49,"end_line":51,"code":"func (s *Syncer) Called() bool {\n\n\treturn s.called\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":29,"end_line":48,"code":"\n// A Syncer is a spy for the Sync portion of zapcore.WriteSyncer.\ntype Syncer struct {\n\terr    error\n\tcalled bool\n}\n\n// SetError sets the error that the Sync method will return.\nfunc (s *Syncer) SetError(err error) {\n\ts.err = err\n}\n\n// Sync records that it was called, then returns the user-supplied error (if\n// any).\nfunc (s *Syncer) Sync() error {\n\ts.called = true\n\treturn s.err\n}\n\n// Called reports whether the Sync method was called."},{"path":"internal/ztest/writer.go","start_line":52,"end_line":71,"code":"\n// A Discarder sends all writes to io.Discard.\ntype Discarder struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (d *Discarder) Write(b []byte) (int, error) {\n\treturn io.Discard.Write(b)\n}\n\n// FailWriter is a WriteSyncer that always returns an error on writes.\ntype FailWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w FailWriter) Write(b []byte) (int, error) {\n\treturn len(b), errors.New(\"failed\")\n}\n\n// ShortWriter is a WriteSyncer whose write method never fails, but\n// nevertheless fails to the last byte of the input.\ntype ShortWriter struct{ Syncer }"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffer).Called","path":"internal/ztest/writer.go"},{"symbol":"(*Discarder).Called","path":"internal/ztest/writer.go"},{"symbol":"(*FailWriter).Called","path":"internal/ztest/writer.go"},{"symbol":"(*ShortWriter).Called","path":"internal/ztest/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Discarder).Write","signature":"func (d *Discarder) Write(b []byte) (int, error)","start_line":57,"end_line":59,"code":"func (d *Discarder) Write(b []byte) (int, error) {\n\n\treturn io.Discard.Write(b)\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":37,"end_line":56,"code":"func (s *Syncer) SetError(err error) {\n\ts.err = err\n}\n\n// Sync records that it was called, then returns the user-supplied error (if\n// any).\nfunc (s *Syncer) Sync() error {\n\ts.called = true\n\treturn s.err\n}\n\n// Called reports whether the Sync method was called.\nfunc (s *Syncer) Called() bool {\n\treturn s.called\n}\n\n// A Discarder sends all writes to io.Discard.\ntype Discarder struct{ Syncer }\n\n// Write implements io.Writer."},{"path":"internal/ztest/writer.go","start_line":60,"end_line":79,"code":"\n// FailWriter is a WriteSyncer that always returns an error on writes.\ntype FailWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w FailWriter) Write(b []byte) (int, error) {\n\treturn len(b), errors.New(\"failed\")\n}\n\n// ShortWriter is a WriteSyncer whose write method never fails, but\n// nevertheless fails to the last byte of the input.\ntype ShortWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w ShortWriter) Write(b []byte) (int, error) {\n\treturn len(b) - 1, nil\n}\n\n// Buffer is an implementation of zapcore.WriteSyncer that sends all writes to\n// a bytes.Buffer. It has convenience methods to split the accumulated buffer"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512.go"},{"symbol":"(*Discarder).Write","path":"internal/ztest/writer.go"},{"symbol":"(*File).Write","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"(*HMAC).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/hmac/hmac.go"},{"symbol":"(*OffsetWriter).Write","path":"../../../../usr/local/go/src/io/io.go"},{"symbol":"(*PipeWriter).Write","path":"../../../../usr/local/go/src/io/pipe.go"},{"symbol":"(*SHAKE).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha3/shake.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*conn).Write","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*dictWriter).Write","path":"../../../../usr/local/go/src/compress/flate/deflate.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/crypto/sha1/sha1.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/hash/crc32/crc32.go"},{"symbol":"(*dotWriter).Write","path":"../../../../usr/local/go/src/net/textproto/writer.go"},{"symbol":"(*encoder).Write","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*finishedHash).Write","path":"../../../../usr/local/go/src/crypto/tls/prf.go"},{"symbol":"(*http2bufferedWriterTimeoutWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2dataBuffer).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2responseWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*lineBreaker).Write","path":"../../../../usr/local/go/src/encoding/pem/pem.go"},{"symbol":"(*lockedWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"(*macGeneric).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/crypto/internal/poly1305/sum_generic.go"},{"symbol":"(*part).Write","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*prefixSuffixSaver).Write","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*timeoutWriter).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(FailWriter).Write","path":"internal/ztest/writer.go"},{"symbol":"(ShortWriter).Write","path":"internal/ztest/writer.go"},{"symbol":"(checkConnErrorWriter).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(discard).Write","path":"../../../../usr/local/go/src/io/io.go"},{"symbol":"(http2stickyErrWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(multiWriteSyncer).Write","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(FailWriter).Write","signature":"func (w FailWriter) Write(b []byte) (int, error)","start_line":65,"end_line":67,"code":"func (w FailWriter) Write(b []byte) (int, error) {\n\n\treturn len(b), errors.New(\"failed\")\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":45,"end_line":64,"code":"\treturn s.err\n}\n\n// Called reports whether the Sync method was called.\nfunc (s *Syncer) Called() bool {\n\treturn s.called\n}\n\n// A Discarder sends all writes to io.Discard.\ntype Discarder struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (d *Discarder) Write(b []byte) (int, error) {\n\treturn io.Discard.Write(b)\n}\n\n// FailWriter is a WriteSyncer that always returns an error on writes.\ntype FailWriter struct{ Syncer }\n\n// Write implements io.Writer."},{"path":"internal/ztest/writer.go","start_line":68,"end_line":87,"code":"\n// ShortWriter is a WriteSyncer whose write method never fails, but\n// nevertheless fails to the last byte of the input.\ntype ShortWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w ShortWriter) Write(b []byte) (int, error) {\n\treturn len(b) - 1, nil\n}\n\n// Buffer is an implementation of zapcore.WriteSyncer that sends all writes to\n// a bytes.Buffer. It has convenience methods to split the accumulated buffer\n// on newlines.\ntype Buffer struct {\n\tbytes.Buffer\n\tSyncer\n}\n\n// Lines returns the current buffer contents, split on newlines.\nfunc (b *Buffer) Lines() []string {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*FailWriter).Write","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(ShortWriter).Write","signature":"func (w ShortWriter) Write(b []byte) (int, error)","start_line":74,"end_line":76,"code":"func (w ShortWriter) Write(b []byte) (int, error) {\n\n\treturn len(b) - 1, nil\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":54,"end_line":73,"code":"type Discarder struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (d *Discarder) Write(b []byte) (int, error) {\n\treturn io.Discard.Write(b)\n}\n\n// FailWriter is a WriteSyncer that always returns an error on writes.\ntype FailWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w FailWriter) Write(b []byte) (int, error) {\n\treturn len(b), errors.New(\"failed\")\n}\n\n// ShortWriter is a WriteSyncer whose write method never fails, but\n// nevertheless fails to the last byte of the input.\ntype ShortWriter struct{ Syncer }\n\n// Write implements io.Writer."},{"path":"internal/ztest/writer.go","start_line":77,"end_line":96,"code":"\n// Buffer is an implementation of zapcore.WriteSyncer that sends all writes to\n// a bytes.Buffer. It has convenience methods to split the accumulated buffer\n// on newlines.\ntype Buffer struct {\n\tbytes.Buffer\n\tSyncer\n}\n\n// Lines returns the current buffer contents, split on newlines.\nfunc (b *Buffer) Lines() []string {\n\toutput := strings.Split(b.String(), \"\\n\")\n\treturn output[:len(output)-1]\n}\n\n// Stripped returns the current buffer contents with the last trailing newline\n// stripped.\nfunc (b *Buffer) Stripped() string {\n\treturn strings.TrimRight(b.String(), \"\\n\")\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*ShortWriter).Write","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Encode","path":"../../../../usr/local/go/src/encoding/pem/pem.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Buffer).Lines","signature":"func (b *Buffer) Lines() []string","start_line":87,"end_line":90,"code":"func (b *Buffer) Lines() []string {\n\n\toutput := strings.Split(b.String(), \"\\n\")\n\treturn output[:len(output)-1]\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":67,"end_line":86,"code":"}\n\n// ShortWriter is a WriteSyncer whose write method never fails, but\n// nevertheless fails to the last byte of the input.\ntype ShortWriter struct{ Syncer }\n\n// Write implements io.Writer.\nfunc (w ShortWriter) Write(b []byte) (int, error) {\n\treturn len(b) - 1, nil\n}\n\n// Buffer is an implementation of zapcore.WriteSyncer that sends all writes to\n// a bytes.Buffer. It has convenience methods to split the accumulated buffer\n// on newlines.\ntype Buffer struct {\n\tbytes.Buffer\n\tSyncer\n}\n\n// Lines returns the current buffer contents, split on newlines."},{"path":"internal/ztest/writer.go","start_line":91,"end_line":97,"code":"\n// Stripped returns the current buffer contents with the last trailing newline\n// stripped.\nfunc (b *Buffer) Stripped() string {\n\treturn strings.TrimRight(b.String(), \"\\n\")\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*Buffer).String","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"Split","path":"../../../../usr/local/go/src/strings/strings.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"internal/ztest/writer.go","symbol":"(*Buffer).Stripped","signature":"func (b *Buffer) Stripped() string","start_line":94,"end_line":96,"code":"func (b *Buffer) Stripped() string {\n\n\treturn strings.TrimRight(b.String(), \"\\n\")\n}\n","neighbors":[{"path":"internal/ztest/writer.go","start_line":74,"end_line":93,"code":"func (w ShortWriter) Write(b []byte) (int, error) {\n\treturn len(b) - 1, nil\n}\n\n// Buffer is an implementation of zapcore.WriteSyncer that sends all writes to\n// a bytes.Buffer. It has convenience methods to split the accumulated buffer\n// on newlines.\ntype Buffer struct {\n\tbytes.Buffer\n\tSyncer\n}\n\n// Lines returns the current buffer contents, split on newlines.\nfunc (b *Buffer) Lines() []string {\n\toutput := strings.Split(b.String(), \"\\n\")\n\treturn output[:len(output)-1]\n}\n\n// Stripped returns the current buffer contents with the last trailing newline\n// stripped."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*Buffer).String","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"TrimRight","path":"../../../../usr/local/go/src/strings/strings.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(LevelEnablerFunc).Enabled","signature":"func (f LevelEnablerFunc) Enabled(lvl zapcore.Level) bool","start_line":60,"end_line":60,"code":"func (f LevelEnablerFunc) Enabled(lvl zapcore.Level) bool {\n return f(lvl) }\n","neighbors":[{"path":"level.go","start_line":40,"end_line":59,"code":"\t// it shouldn't generate any error-level logs.\n\tErrorLevel = zapcore.ErrorLevel\n\t// DPanicLevel logs are particularly important errors. In development the\n\t// logger panics after writing the message.\n\tDPanicLevel = zapcore.DPanicLevel\n\t// PanicLevel logs a message, then panics.\n\tPanicLevel = zapcore.PanicLevel\n\t// FatalLevel logs a message, then calls os.Exit(1).\n\tFatalLevel = zapcore.FatalLevel\n)\n\n// LevelEnablerFunc is a convenient way to implement zapcore.LevelEnabler with\n// an anonymous function.\n//\n// It's particularly useful when splitting log output between different\n// outputs (e.g., standard error and standard out). For sample code, see the\n// package-level AdvancedConfiguration example.\ntype LevelEnablerFunc func(zapcore.Level) bool\n\n// Enabled calls the wrapped function."},{"path":"level.go","start_line":61,"end_line":80,"code":"\n// An AtomicLevel is an atomically changeable, dynamic logging level. It lets\n// you safely change the log level of a tree of loggers (the root logger and\n// any children created by adding context) at runtime.\n//\n// The AtomicLevel itself is an http.Handler that serves a JSON endpoint to\n// alter its level.\n//\n// AtomicLevels must be created with the NewAtomicLevel constructor to allocate\n// their internal atomic pointer.\ntype AtomicLevel struct {\n\tl *atomic.Int32\n}\n\nvar _ internal.LeveledEnabler = AtomicLevel{}\n\n// NewAtomicLevel creates an AtomicLevel with InfoLevel and above logging\n// enabled.\nfunc NewAtomicLevel() AtomicLevel {\n\tlvl := AtomicLevel{l: new(atomic.Int32)}"}],"selection":{"visibility":"exported","reason":"other","score":0.68},"call_graph":{"callees":null,"callers":[{"symbol":"(*LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"NewAtomicLevel","signature":"func NewAtomicLevel() AtomicLevel","start_line":79,"end_line":83,"code":"func NewAtomicLevel() AtomicLevel {\n\n\tlvl := AtomicLevel{l: new(atomic.Int32)}\n\tlvl.l.Store(int32(InfoLevel))\n\treturn lvl\n}\n","neighbors":[{"path":"level.go","start_line":59,"end_line":78,"code":"// Enabled calls the wrapped function.\nfunc (f LevelEnablerFunc) Enabled(lvl zapcore.Level) bool { return f(lvl) }\n\n// An AtomicLevel is an atomically changeable, dynamic logging level. It lets\n// you safely change the log level of a tree of loggers (the root logger and\n// any children created by adding context) at runtime.\n//\n// The AtomicLevel itself is an http.Handler that serves a JSON endpoint to\n// alter its level.\n//\n// AtomicLevels must be created with the NewAtomicLevel constructor to allocate\n// their internal atomic pointer.\ntype AtomicLevel struct {\n\tl *atomic.Int32\n}\n\nvar _ internal.LeveledEnabler = AtomicLevel{}\n\n// NewAtomicLevel creates an AtomicLevel with InfoLevel and above logging\n// enabled."},{"path":"level.go","start_line":84,"end_line":103,"code":"\n// NewAtomicLevelAt is a convenience function that creates an AtomicLevel\n// and then calls SetLevel with the given level.\nfunc NewAtomicLevelAt(l zapcore.Level) AtomicLevel {\n\ta := NewAtomicLevel()\n\ta.SetLevel(l)\n\treturn a\n}\n\n// ParseAtomicLevel parses an AtomicLevel based on a lowercase or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels.\nfunc ParseAtomicLevel(text string) (AtomicLevel, error) {\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err"}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":[{"symbol":"(*Int32).Store","path":"../../../../usr/local/go/src/sync/atomic/type.go"}],"callers":[{"symbol":"NewAtomicLevelAt","path":"level.go"},{"symbol":"ParseAtomicLevel","path":"level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"NewAtomicLevelAt","signature":"func NewAtomicLevelAt(l zapcore.Level) AtomicLevel","start_line":87,"end_line":91,"code":"func NewAtomicLevelAt(l zapcore.Level) AtomicLevel {\n\n\ta := NewAtomicLevel()\n\ta.SetLevel(l)\n\treturn a\n}\n","neighbors":[{"path":"level.go","start_line":67,"end_line":86,"code":"// alter its level.\n//\n// AtomicLevels must be created with the NewAtomicLevel constructor to allocate\n// their internal atomic pointer.\ntype AtomicLevel struct {\n\tl *atomic.Int32\n}\n\nvar _ internal.LeveledEnabler = AtomicLevel{}\n\n// NewAtomicLevel creates an AtomicLevel with InfoLevel and above logging\n// enabled.\nfunc NewAtomicLevel() AtomicLevel {\n\tlvl := AtomicLevel{l: new(atomic.Int32)}\n\tlvl.l.Store(int32(InfoLevel))\n\treturn lvl\n}\n\n// NewAtomicLevelAt is a convenience function that creates an AtomicLevel\n// and then calls SetLevel with the given level."},{"path":"level.go","start_line":92,"end_line":111,"code":"\n// ParseAtomicLevel parses an AtomicLevel based on a lowercase or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels.\nfunc ParseAtomicLevel(text string) (AtomicLevel, error) {\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels."}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":[{"symbol":"(AtomicLevel).SetLevel","path":"level.go"},{"symbol":"NewAtomicLevel","path":"level.go"}],"callers":[{"symbol":"NewDevelopmentConfig","path":"config.go"},{"symbol":"NewProductionConfig","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"ParseAtomicLevel","signature":"func ParseAtomicLevel(text string) (AtomicLevel, error)","start_line":99,"end_line":108,"code":"func ParseAtomicLevel(text string) (AtomicLevel, error) {\n\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n","neighbors":[{"path":"level.go","start_line":79,"end_line":98,"code":"func NewAtomicLevel() AtomicLevel {\n\tlvl := AtomicLevel{l: new(atomic.Int32)}\n\tlvl.l.Store(int32(InfoLevel))\n\treturn lvl\n}\n\n// NewAtomicLevelAt is a convenience function that creates an AtomicLevel\n// and then calls SetLevel with the given level.\nfunc NewAtomicLevelAt(l zapcore.Level) AtomicLevel {\n\ta := NewAtomicLevel()\n\ta.SetLevel(l)\n\treturn a\n}\n\n// ParseAtomicLevel parses an AtomicLevel based on a lowercase or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels."},{"path":"level.go","start_line":109,"end_line":128,"code":"\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels.\nfunc (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\treturn lvl.Level().Enabled(l)\n}\n\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(AtomicLevel).SetLevel","path":"level.go"},{"symbol":"NewAtomicLevel","path":"level.go"},{"symbol":"ParseLevel","path":"zapcore/level.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(AtomicLevel).Enabled","signature":"func (lvl AtomicLevel) Enabled(l zapcore.Level) bool","start_line":112,"end_line":114,"code":"func (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\n\treturn lvl.Level().Enabled(l)\n}\n","neighbors":[{"path":"level.go","start_line":92,"end_line":111,"code":"\n// ParseAtomicLevel parses an AtomicLevel based on a lowercase or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels.\nfunc ParseAtomicLevel(text string) (AtomicLevel, error) {\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels."},{"path":"level.go","start_line":115,"end_line":134,"code":"\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()\n}\n\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {"}],"selection":{"visibility":"exported","reason":"other","score":0.68},"call_graph":{"callees":[{"symbol":"(AtomicLevel).Level","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"}],"callers":[{"symbol":"(*AtomicLevel).Enabled","path":"level.go"},{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(AtomicLevel).Level","signature":"func (lvl AtomicLevel) Level() zapcore.Level","start_line":117,"end_line":119,"code":"func (lvl AtomicLevel) Level() zapcore.Level {\n\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n","neighbors":[{"path":"level.go","start_line":97,"end_line":116,"code":"// This is particularly useful when dealing with text input to configure log\n// levels.\nfunc ParseAtomicLevel(text string) (AtomicLevel, error) {\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels.\nfunc (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\treturn lvl.Level().Enabled(l)\n}\n\n// Level returns the minimum enabled log level."},{"path":"level.go","start_line":120,"end_line":139,"code":"\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()\n}\n\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\tif lvl.l == nil {\n\t\tlvl.l = \u0026atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level"}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":[{"symbol":"(*Int32).Load","path":"../../../../usr/local/go/src/sync/atomic/type.go"}],"callers":[{"symbol":"(*AtomicLevel).Level","path":"level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(AtomicLevel).MarshalText","path":"level.go"},{"symbol":"(AtomicLevel).String","path":"level.go"},{"symbol":"(AtomicLevel).serveHTTP","path":"http_handler.go"},{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(AtomicLevel).SetLevel","signature":"func (lvl AtomicLevel) SetLevel(l zapcore.Level)","start_line":122,"end_line":124,"code":"func (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\n\tlvl.l.Store(int32(l))\n}\n","neighbors":[{"path":"level.go","start_line":102,"end_line":121,"code":"\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels.\nfunc (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\treturn lvl.Level().Enabled(l)\n}\n\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level."},{"path":"level.go","start_line":125,"end_line":144,"code":"\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()\n}\n\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\tif lvl.l == nil {\n\t\tlvl.l = \u0026atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText(text); err != nil {\n\t\treturn err\n\t}\n\n\tlvl.SetLevel(l)"}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":[{"symbol":"(*Int32).Store","path":"../../../../usr/local/go/src/sync/atomic/type.go"}],"callers":[{"symbol":"(*AtomicLevel).SetLevel","path":"level.go"},{"symbol":"(*AtomicLevel).UnmarshalText","path":"level.go"},{"symbol":"(AtomicLevel).serveHTTP","path":"http_handler.go"},{"symbol":"NewAtomicLevelAt","path":"level.go"},{"symbol":"ParseAtomicLevel","path":"level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(AtomicLevel).String","signature":"func (lvl AtomicLevel) String() string","start_line":127,"end_line":129,"code":"func (lvl AtomicLevel) String() string {\n\n\treturn lvl.Level().String()\n}\n","neighbors":[{"path":"level.go","start_line":107,"end_line":126,"code":"\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels.\nfunc (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\treturn lvl.Level().Enabled(l)\n}\n\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level."},{"path":"level.go","start_line":130,"end_line":149,"code":"\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\tif lvl.l == nil {\n\t\tlvl.l = \u0026atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText(text); err != nil {\n\t\treturn err\n\t}\n\n\tlvl.SetLevel(l)\n\treturn nil\n}\n\n// MarshalText marshals the AtomicLevel to a byte slice. It uses the same\n// text representation as the static zapcore.Levels (\"debug\", \"info\", \"warn\","}],"selection":{"visibility":"exported","reason":"other","score":0.68},"call_graph":{"callees":[{"symbol":"(AtomicLevel).Level","path":"level.go"},{"symbol":"(Level).String","path":"zapcore/level.go"}],"callers":[{"symbol":"(*AtomicLevel).String","path":"level.go"},{"symbol":"(*pp).handleMethods","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"(http2FrameWriteRequest).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"contextName","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"stringify","path":"../../../../usr/local/go/src/context/context.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(*AtomicLevel).UnmarshalText","signature":"func (lvl *AtomicLevel) UnmarshalText(text []byte) error","start_line":134,"end_line":146,"code":"func (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\n\tif lvl.l == nil {\n\t\tlvl.l = \u0026atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText(text); err != nil {\n\t\treturn err\n\t}\n\n\tlvl.SetLevel(l)\n\treturn nil\n}\n","neighbors":[{"path":"level.go","start_line":114,"end_line":133,"code":"}\n\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()\n}\n\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\")."},{"path":"level.go","start_line":147,"end_line":154,"code":"\n// MarshalText marshals the AtomicLevel to a byte slice. It uses the same\n// text representation as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl AtomicLevel) MarshalText() (text []byte, err error) {\n\treturn lvl.Level().MarshalText()\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"(*Level).UnmarshalText","path":"zapcore/level.go"},{"symbol":"(AtomicLevel).SetLevel","path":"level.go"}],"callers":[{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"level.go","symbol":"(AtomicLevel).MarshalText","signature":"func (lvl AtomicLevel) MarshalText() (text []byte, err error)","start_line":151,"end_line":153,"code":"func (lvl AtomicLevel) MarshalText() (text []byte, err error) {\n\n\treturn lvl.Level().MarshalText()\n}\n","neighbors":[{"path":"level.go","start_line":131,"end_line":150,"code":"// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\tif lvl.l == nil {\n\t\tlvl.l = \u0026atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText(text); err != nil {\n\t\treturn err\n\t}\n\n\tlvl.SetLevel(l)\n\treturn nil\n}\n\n// MarshalText marshals the AtomicLevel to a byte slice. It uses the same\n// text representation as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\")."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(AtomicLevel).Level","path":"level.go"},{"symbol":"(Level).MarshalText","path":"zapcore/level.go"}],"callers":[{"symbol":"(*AtomicLevel).MarshalText","path":"level.go"},{"symbol":"(textValue).String","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"addrTextMarshalerEncoder","path":"../../../../usr/local/go/src/encoding/json/encode.go"},{"symbol":"resolveKeyName","path":"../../../../usr/local/go/src/encoding/json/encode.go"},{"symbol":"textMarshalerEncoder","path":"../../../../usr/local/go/src/encoding/json/encode.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"New","signature":"func New(core zapcore.Core, options ...Option) *Logger","start_line":69,"end_line":80,"code":"func New(core zapcore.Core, options ...Option) *Logger {\n\n\tif core == nil {\n\t\treturn NewNop()\n\t}\n\tlog := \u0026Logger{\n\t\tcore:        core,\n\t\terrorOutput: zapcore.Lock(os.Stderr),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n\treturn log.WithOptions(options...)\n}\n","neighbors":[{"path":"logger.go","start_line":49,"end_line":68,"code":"\tname        string\n\terrorOutput zapcore.WriteSyncer\n\n\taddStack zapcore.LevelEnabler\n\n\tcallerSkip int\n\n\tclock zapcore.Clock\n}\n\n// New constructs a new Logger from the provided zapcore.Core and Options. If\n// the passed zapcore.Core is nil, it falls back to using a no-op\n// implementation.\n//\n// This is the most flexible way to construct a Logger, but also the most\n// verbose. For typical use cases, the highly-opinionated presets\n// (NewProduction, NewDevelopment, and NewExample) or the Config struct are\n// more convenient.\n//\n// For sample code, see the package-level AdvancedConfiguration example."},{"path":"logger.go","start_line":81,"end_line":100,"code":"\n// NewNop returns a no-op Logger. It never writes out logs or internal errors,\n// and it never runs user-defined hooks.\n//\n// Using WithOptions to replace the Core or error output of a no-op Logger can\n// re-enable logging.\nfunc NewNop() *Logger {\n\treturn \u0026Logger{\n\t\tcore:        zapcore.NewNopCore(),\n\t\terrorOutput: zapcore.AddSync(io.Discard),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n}\n\n// NewProduction builds a sensible production Logger that writes InfoLevel and\n// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option).\nfunc NewProduction(options ...Option) (*Logger, error) {"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"Lock","path":"zapcore/write_syncer.go"},{"symbol":"NewNop","path":"logger.go"}],"callers":[{"symbol":"(Config).Build","path":"config.go"},{"symbol":"NewExample","path":"logger.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"NewNop","signature":"func NewNop() *Logger","start_line":87,"end_line":94,"code":"func NewNop() *Logger {\n\n\treturn \u0026Logger{\n\t\tcore:        zapcore.NewNopCore(),\n\t\terrorOutput: zapcore.AddSync(io.Discard),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":67,"end_line":86,"code":"//\n// For sample code, see the package-level AdvancedConfiguration example.\nfunc New(core zapcore.Core, options ...Option) *Logger {\n\tif core == nil {\n\t\treturn NewNop()\n\t}\n\tlog := \u0026Logger{\n\t\tcore:        core,\n\t\terrorOutput: zapcore.Lock(os.Stderr),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n\treturn log.WithOptions(options...)\n}\n\n// NewNop returns a no-op Logger. It never writes out logs or internal errors,\n// and it never runs user-defined hooks.\n//\n// Using WithOptions to replace the Core or error output of a no-op Logger can\n// re-enable logging."},{"path":"logger.go","start_line":95,"end_line":114,"code":"\n// NewProduction builds a sensible production Logger that writes InfoLevel and\n// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option).\nfunc NewProduction(options ...Option) (*Logger, error) {\n\treturn NewProductionConfig().Build(options...)\n}\n\n// NewDevelopment builds a development Logger that writes DebugLevel and above\n// logs to standard error in a human-friendly format.\n//\n// It's a shortcut for NewDevelopmentConfig().Build(...Option).\nfunc NewDevelopment(options ...Option) (*Logger, error) {\n\treturn NewDevelopmentConfig().Build(options...)\n}\n\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:"}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":[{"symbol":"AddSync","path":"zapcore/write_syncer.go"},{"symbol":"NewNopCore","path":"zapcore/core.go"}],"callers":[{"symbol":"New","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"NewProduction","signature":"func NewProduction(options ...Option) (*Logger, error)","start_line":100,"end_line":102,"code":"func NewProduction(options ...Option) (*Logger, error) {\n\n\treturn NewProductionConfig().Build(options...)\n}\n","neighbors":[{"path":"logger.go","start_line":80,"end_line":99,"code":"}\n\n// NewNop returns a no-op Logger. It never writes out logs or internal errors,\n// and it never runs user-defined hooks.\n//\n// Using WithOptions to replace the Core or error output of a no-op Logger can\n// re-enable logging.\nfunc NewNop() *Logger {\n\treturn \u0026Logger{\n\t\tcore:        zapcore.NewNopCore(),\n\t\terrorOutput: zapcore.AddSync(io.Discard),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n}\n\n// NewProduction builds a sensible production Logger that writes InfoLevel and\n// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option)."},{"path":"logger.go","start_line":103,"end_line":122,"code":"\n// NewDevelopment builds a development Logger that writes DebugLevel and above\n// logs to standard error in a human-friendly format.\n//\n// It's a shortcut for NewDevelopmentConfig().Build(...Option).\nfunc NewDevelopment(options ...Option) (*Logger, error) {\n\treturn NewDevelopmentConfig().Build(options...)\n}\n\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:\n//\n//\tvar logger = zap.Must(zap.NewProduction())\nfunc Must(logger *Logger, err error) *Logger {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn logger"}],"selection":{"visibility":"exported","reason":"constructor","score":0.75},"call_graph":{"callees":[{"symbol":"(Config).Build","path":"config.go"},{"symbol":"NewProductionConfig","path":"config.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"NewDevelopment","signature":"func NewDevelopment(options ...Option) (*Logger, error)","start_line":108,"end_line":110,"code":"func NewDevelopment(options ...Option) (*Logger, error) {\n\n\treturn NewDevelopmentConfig().Build(options...)\n}\n","neighbors":[{"path":"logger.go","start_line":88,"end_line":107,"code":"\treturn \u0026Logger{\n\t\tcore:        zapcore.NewNopCore(),\n\t\terrorOutput: zapcore.AddSync(io.Discard),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n}\n\n// NewProduction builds a sensible production Logger that writes InfoLevel and\n// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option).\nfunc NewProduction(options ...Option) (*Logger, error) {\n\treturn NewProductionConfig().Build(options...)\n}\n\n// NewDevelopment builds a development Logger that writes DebugLevel and above\n// logs to standard error in a human-friendly format.\n//\n// It's a shortcut for NewDevelopmentConfig().Build(...Option)."},{"path":"logger.go","start_line":111,"end_line":130,"code":"\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:\n//\n//\tvar logger = zap.Must(zap.NewProduction())\nfunc Must(logger *Logger, err error) *Logger {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn logger\n}\n\n// NewExample builds a Logger that's designed for use in zap's testable\n// examples. It writes DebugLevel and above logs to standard out as JSON, but\n// omits the timestamp and calling function to keep example output\n// short and deterministic.\nfunc NewExample(options ...Option) *Logger {\n\tencoderCfg := zapcore.EncoderConfig{"}],"selection":{"visibility":"exported","reason":"constructor","score":0.75},"call_graph":{"callees":[{"symbol":"(Config).Build","path":"config.go"},{"symbol":"NewDevelopmentConfig","path":"config.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"Must","signature":"func Must(logger *Logger, err error) *Logger","start_line":117,"end_line":123,"code":"func Must(logger *Logger, err error) *Logger {\n\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn logger\n}\n","neighbors":[{"path":"logger.go","start_line":97,"end_line":116,"code":"// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option).\nfunc NewProduction(options ...Option) (*Logger, error) {\n\treturn NewProductionConfig().Build(options...)\n}\n\n// NewDevelopment builds a development Logger that writes DebugLevel and above\n// logs to standard error in a human-friendly format.\n//\n// It's a shortcut for NewDevelopmentConfig().Build(...Option).\nfunc NewDevelopment(options ...Option) (*Logger, error) {\n\treturn NewDevelopmentConfig().Build(options...)\n}\n\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:\n//\n//\tvar logger = zap.Must(zap.NewProduction())"},{"path":"logger.go","start_line":124,"end_line":143,"code":"\n// NewExample builds a Logger that's designed for use in zap's testable\n// examples. It writes DebugLevel and above logs to standard out as JSON, but\n// omits the timestamp and calling function to keep example output\n// short and deterministic.\nfunc NewExample(options ...Option) *Logger {\n\tencoderCfg := zapcore.EncoderConfig{\n\t\tMessageKey:     \"msg\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t}\n\tcore := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)\n\treturn New(core).WithOptions(options...)\n}\n\n// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,\n// API. Sugaring a Logger is quite inexpensive, so it's reasonable for a"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"NewExample","signature":"func NewExample(options ...Option) *Logger","start_line":129,"end_line":140,"code":"func NewExample(options ...Option) *Logger {\n\n\tencoderCfg := zapcore.EncoderConfig{\n\t\tMessageKey:     \"msg\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t}\n\tcore := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)\n\treturn New(core).WithOptions(options...)\n}\n","neighbors":[{"path":"logger.go","start_line":109,"end_line":128,"code":"\treturn NewDevelopmentConfig().Build(options...)\n}\n\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:\n//\n//\tvar logger = zap.Must(zap.NewProduction())\nfunc Must(logger *Logger, err error) *Logger {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn logger\n}\n\n// NewExample builds a Logger that's designed for use in zap's testable\n// examples. It writes DebugLevel and above logs to standard out as JSON, but\n// omits the timestamp and calling function to keep example output\n// short and deterministic."},{"path":"logger.go","start_line":141,"end_line":160,"code":"\n// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,\n// API. Sugaring a Logger is quite inexpensive, so it's reasonable for a\n// single application to use both Loggers and SugaredLoggers, converting\n// between them on the boundaries of performance-sensitive code.\nfunc (log *Logger) Sugar() *SugaredLogger {\n\tcore := log.clone()\n\tcore.callerSkip += 2\n\treturn \u0026SugaredLogger{core}\n}\n\n// Named adds a new path segment to the logger's name. Segments are joined by\n// periods. By default, Loggers are unnamed.\nfunc (log *Logger) Named(s string) *Logger {\n\tif s == \"\" {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tif log.name == \"\" {\n\t\tl.name = s"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"New","path":"logger.go"},{"symbol":"NewCore","path":"zapcore/core.go"},{"symbol":"NewJSONEncoder","path":"zapcore/json_encoder.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Sugar","signature":"func (log *Logger) Sugar() *SugaredLogger","start_line":146,"end_line":150,"code":"func (log *Logger) Sugar() *SugaredLogger {\n\n\tcore := log.clone()\n\tcore.callerSkip += 2\n\treturn \u0026SugaredLogger{core}\n}\n","neighbors":[{"path":"logger.go","start_line":126,"end_line":145,"code":"// examples. It writes DebugLevel and above logs to standard out as JSON, but\n// omits the timestamp and calling function to keep example output\n// short and deterministic.\nfunc NewExample(options ...Option) *Logger {\n\tencoderCfg := zapcore.EncoderConfig{\n\t\tMessageKey:     \"msg\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t}\n\tcore := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)\n\treturn New(core).WithOptions(options...)\n}\n\n// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,\n// API. Sugaring a Logger is quite inexpensive, so it's reasonable for a\n// single application to use both Loggers and SugaredLoggers, converting\n// between them on the boundaries of performance-sensitive code."},{"path":"logger.go","start_line":151,"end_line":170,"code":"\n// Named adds a new path segment to the logger's name. Segments are joined by\n// periods. By default, Loggers are unnamed.\nfunc (log *Logger) Named(s string) *Logger {\n\tif s == \"\" {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tif log.name == \"\" {\n\t\tl.name = s\n\t} else {\n\t\tl.name = strings.Join([]string{l.name, s}, \".\")\n\t}\n\treturn l\n}\n\n// WithOptions clones the current Logger, applies the supplied Options, and\n// returns the resulting Logger. It's safe to use concurrently.\nfunc (log *Logger) WithOptions(opts ...Option) *Logger {\n\tc := log.clone()"}],"selection":{"visibility":"exported","reason":"public_api","score":0.86},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"}],"callers":[{"symbol":"NewLogger","path":"zapgrpc/zapgrpc.go"},{"symbol":"ReplaceGlobals","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Named","signature":"func (log *Logger) Named(s string) *Logger","start_line":154,"end_line":165,"code":"func (log *Logger) Named(s string) *Logger {\n\n\tif s == \"\" {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tif log.name == \"\" {\n\t\tl.name = s\n\t} else {\n\t\tl.name = strings.Join([]string{l.name, s}, \".\")\n\t}\n\treturn l\n}\n","neighbors":[{"path":"logger.go","start_line":134,"end_line":153,"code":"\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t}\n\tcore := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)\n\treturn New(core).WithOptions(options...)\n}\n\n// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,\n// API. Sugaring a Logger is quite inexpensive, so it's reasonable for a\n// single application to use both Loggers and SugaredLoggers, converting\n// between them on the boundaries of performance-sensitive code.\nfunc (log *Logger) Sugar() *SugaredLogger {\n\tcore := log.clone()\n\tcore.callerSkip += 2\n\treturn \u0026SugaredLogger{core}\n}\n\n// Named adds a new path segment to the logger's name. Segments are joined by\n// periods. By default, Loggers are unnamed."},{"path":"logger.go","start_line":166,"end_line":185,"code":"\n// WithOptions clones the current Logger, applies the supplied Options, and\n// returns the resulting Logger. It's safe to use concurrently.\nfunc (log *Logger) WithOptions(opts ...Option) *Logger {\n\tc := log.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(c)\n\t}\n\treturn c\n}\n\n// With creates a child logger and adds structured context to it. Fields added\n// to the child don't affect the parent, and vice versa. Any fields that\n// require evaluation (such as Objects) are evaluated upon invocation of With.\nfunc (log *Logger) With(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tl.core = l.core.With(fields)"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"},{"symbol":"Join","path":"../../../../usr/local/go/src/strings/strings.go"}],"callers":[{"symbol":"(*SugaredLogger).Named","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).WithOptions","signature":"func (log *Logger) WithOptions(opts ...Option) *Logger","start_line":169,"end_line":175,"code":"func (log *Logger) WithOptions(opts ...Option) *Logger {\n\n\tc := log.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(c)\n\t}\n\treturn c\n}\n","neighbors":[{"path":"logger.go","start_line":149,"end_line":168,"code":"\treturn \u0026SugaredLogger{core}\n}\n\n// Named adds a new path segment to the logger's name. Segments are joined by\n// periods. By default, Loggers are unnamed.\nfunc (log *Logger) Named(s string) *Logger {\n\tif s == \"\" {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tif log.name == \"\" {\n\t\tl.name = s\n\t} else {\n\t\tl.name = strings.Join([]string{l.name, s}, \".\")\n\t}\n\treturn l\n}\n\n// WithOptions clones the current Logger, applies the supplied Options, and\n// returns the resulting Logger. It's safe to use concurrently."},{"path":"logger.go","start_line":176,"end_line":195,"code":"\n// With creates a child logger and adds structured context to it. Fields added\n// to the child don't affect the parent, and vice versa. Any fields that\n// require evaluation (such as Objects) are evaluated upon invocation of With.\nfunc (log *Logger) With(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tl.core = l.core.With(fields)\n\treturn l\n}\n\n// WithLazy creates a child logger and adds structured context to it lazily.\n//\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy()."}],"selection":{"visibility":"exported","reason":"public_api","score":0.88},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"},{"symbol":"(optionFunc).apply","path":"options.go"}],"callers":[{"symbol":"(*Logger).WithLazy","path":"logger.go"},{"symbol":"(Config).Build","path":"config.go"},{"symbol":"New","path":"logger.go"},{"symbol":"NewExample","path":"logger.go"},{"symbol":"NewStdLog","path":"global.go"},{"symbol":"NewStdLogAt","path":"global.go"},{"symbol":"redirectStdLogAt","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).With","signature":"func (log *Logger) With(fields ...Field) *Logger","start_line":180,"end_line":187,"code":"func (log *Logger) With(fields ...Field) *Logger {\n\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tl.core = l.core.With(fields)\n\treturn l\n}\n","neighbors":[{"path":"logger.go","start_line":160,"end_line":179,"code":"\t\tl.name = s\n\t} else {\n\t\tl.name = strings.Join([]string{l.name, s}, \".\")\n\t}\n\treturn l\n}\n\n// WithOptions clones the current Logger, applies the supplied Options, and\n// returns the resulting Logger. It's safe to use concurrently.\nfunc (log *Logger) WithOptions(opts ...Option) *Logger {\n\tc := log.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(c)\n\t}\n\treturn c\n}\n\n// With creates a child logger and adds structured context to it. Fields added\n// to the child don't affect the parent, and vice versa. Any fields that\n// require evaluation (such as Objects) are evaluated upon invocation of With."},{"path":"logger.go","start_line":188,"end_line":207,"code":"\n// WithLazy creates a child logger and adds structured context to it lazily.\n//\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// WithLazy provides a worthwhile performance optimization for contextual loggers\n// when the likelihood of using the child logger is low,\n// such as error paths and rarely taken branches.\n//\n// Similar to [With], fields added to the child don't affect the parent, and vice versa.\nfunc (log *Logger) WithLazy(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\treturn log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewLazyWith(core, fields)"}],"selection":{"visibility":"exported","reason":"public_api","score":0.89},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"},{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*SugaredLogger).With","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).WithLazy","signature":"func (log *Logger) WithLazy(fields ...Field) *Logger","start_line":202,"end_line":209,"code":"func (log *Logger) WithLazy(fields ...Field) *Logger {\n\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\treturn log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewLazyWith(core, fields)\n\t}))\n}\n","neighbors":[{"path":"logger.go","start_line":182,"end_line":201,"code":"\t\treturn log\n\t}\n\tl := log.clone()\n\tl.core = l.core.With(fields)\n\treturn l\n}\n\n// WithLazy creates a child logger and adds structured context to it lazily.\n//\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// WithLazy provides a worthwhile performance optimization for contextual loggers\n// when the likelihood of using the child logger is low,\n// such as error paths and rarely taken branches.\n//\n// Similar to [With], fields added to the child don't affect the parent, and vice versa."},{"path":"logger.go","start_line":210,"end_line":229,"code":"\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (log *Logger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(log.core)\n}\n\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields.\nfunc (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\treturn log.check(lvl, msg)\n}\n\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"WrapCore","path":"options.go"}],"callers":[{"symbol":"(*SugaredLogger).WithLazy","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Level","signature":"func (log *Logger) Level() zapcore.Level","start_line":214,"end_line":216,"code":"func (log *Logger) Level() zapcore.Level {\n\n\treturn zapcore.LevelOf(log.core)\n}\n","neighbors":[{"path":"logger.go","start_line":194,"end_line":213,"code":"// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// WithLazy provides a worthwhile performance optimization for contextual loggers\n// when the likelihood of using the child logger is low,\n// such as error paths and rarely taken branches.\n//\n// Similar to [With], fields added to the child don't affect the parent, and vice versa.\nfunc (log *Logger) WithLazy(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\treturn log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewLazyWith(core, fields)\n\t}))\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel]."},{"path":"logger.go","start_line":217,"end_line":236,"code":"\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields.\nfunc (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\treturn log.check(lvl, msg)\n}\n\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger."}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Check","signature":"func (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry","start_line":221,"end_line":223,"code":"func (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\n\treturn log.check(lvl, msg)\n}\n","neighbors":[{"path":"logger.go","start_line":201,"end_line":220,"code":"// Similar to [With], fields added to the child don't affect the parent, and vice versa.\nfunc (log *Logger) WithLazy(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\treturn log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewLazyWith(core, fields)\n\t}))\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (log *Logger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(log.core)\n}\n\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields."},{"path":"logger.go","start_line":224,"end_line":243,"code":"\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Debug(msg string, fields ...Field) {\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Info logs a message at InfoLevel. The message includes any fields passed"}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).log","path":"zapio/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Log","signature":"func (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field)","start_line":229,"end_line":233,"code":"func (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":209,"end_line":228,"code":"}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (log *Logger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(log.core)\n}\n\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields.\nfunc (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\treturn log.check(lvl, msg)\n}\n\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log."},{"path":"logger.go","start_line":234,"end_line":253,"code":"\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Debug(msg string, fields ...Field) {\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Info(msg string, fields ...Field) {\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Warn(msg string, fields ...Field) {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Debug","signature":"func (log *Logger) Debug(msg string, fields ...Field)","start_line":237,"end_line":241,"code":"func (log *Logger) Debug(msg string, fields ...Field) {\n\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":217,"end_line":236,"code":"\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields.\nfunc (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\treturn log.check(lvl, msg)\n}\n\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger."},{"path":"logger.go","start_line":242,"end_line":261,"code":"\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Info(msg string, fields ...Field) {\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Warn(msg string, fields ...Field) {\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Error(msg string, fields ...Field) {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Info","signature":"func (log *Logger) Info(msg string, fields ...Field)","start_line":245,"end_line":249,"code":"func (log *Logger) Info(msg string, fields ...Field) {\n\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":225,"end_line":244,"code":"// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Debug(msg string, fields ...Field) {\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger."},{"path":"logger.go","start_line":250,"end_line":269,"code":"\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Warn(msg string, fields ...Field) {\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Error(msg string, fields ...Field) {\n\tif ce := log.check(ErrorLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Warn","signature":"func (log *Logger) Warn(msg string, fields ...Field)","start_line":253,"end_line":257,"code":"func (log *Logger) Warn(msg string, fields ...Field) {\n\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":233,"end_line":252,"code":"}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Debug(msg string, fields ...Field) {\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Info(msg string, fields ...Field) {\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger."},{"path":"logger.go","start_line":258,"end_line":277,"code":"\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Error(msg string, fields ...Field) {\n\tif ce := log.check(ErrorLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//\n// If the logger is in development mode, it then panics (DPanic means\n// \"development panic\"). This is useful for catching errors that are\n// recoverable, but shouldn't ever happen.\nfunc (log *Logger) DPanic(msg string, fields ...Field) {\n\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Error","signature":"func (log *Logger) Error(msg string, fields ...Field)","start_line":261,"end_line":265,"code":"func (log *Logger) Error(msg string, fields ...Field) {\n\n\tif ce := log.check(ErrorLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":241,"end_line":260,"code":"}\n\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Info(msg string, fields ...Field) {\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Warn(msg string, fields ...Field) {\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger."},{"path":"logger.go","start_line":266,"end_line":285,"code":"\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//\n// If the logger is in development mode, it then panics (DPanic means\n// \"development panic\"). This is useful for catching errors that are\n// recoverable, but shouldn't ever happen.\nfunc (log *Logger) DPanic(msg string, fields ...Field) {\n\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Panic logs a message at PanicLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then panics, even if logging at PanicLevel is disabled.\nfunc (log *Logger) Panic(msg string, fields ...Field) {\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)"}],"selection":{"visibility":"exported","reason":"other","score":0.74},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).DPanic","signature":"func (log *Logger) DPanic(msg string, fields ...Field)","start_line":273,"end_line":277,"code":"func (log *Logger) DPanic(msg string, fields ...Field) {\n\n\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":253,"end_line":272,"code":"func (log *Logger) Warn(msg string, fields ...Field) {\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Error(msg string, fields ...Field) {\n\tif ce := log.check(ErrorLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//\n// If the logger is in development mode, it then panics (DPanic means\n// \"development panic\"). This is useful for catching errors that are\n// recoverable, but shouldn't ever happen."},{"path":"logger.go","start_line":278,"end_line":297,"code":"\n// Panic logs a message at PanicLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then panics, even if logging at PanicLevel is disabled.\nfunc (log *Logger) Panic(msg string, fields ...Field) {\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Panic","signature":"func (log *Logger) Panic(msg string, fields ...Field)","start_line":283,"end_line":287,"code":"func (log *Logger) Panic(msg string, fields ...Field) {\n\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":263,"end_line":282,"code":"\t\tce.Write(fields...)\n\t}\n}\n\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//\n// If the logger is in development mode, it then panics (DPanic means\n// \"development panic\"). This is useful for catching errors that are\n// recoverable, but shouldn't ever happen.\nfunc (log *Logger) DPanic(msg string, fields ...Field) {\n\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Panic logs a message at PanicLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then panics, even if logging at PanicLevel is disabled."},{"path":"logger.go","start_line":288,"end_line":307,"code":"\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Fatal","signature":"func (log *Logger) Fatal(msg string, fields ...Field)","start_line":294,"end_line":298,"code":"func (log *Logger) Fatal(msg string, fields ...Field) {\n\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n","neighbors":[{"path":"logger.go","start_line":274,"end_line":293,"code":"\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Panic logs a message at PanicLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then panics, even if logging at PanicLevel is disabled.\nfunc (log *Logger) Panic(msg string, fields ...Field) {\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled."},{"path":"logger.go","start_line":299,"end_line":318,"code":"\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n\nfunc (log *Logger) clone() *Logger {\n\tclone := *log"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"callers":[{"symbol":"(*loggerWriter).Write","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Sync","signature":"func (log *Logger) Sync() error","start_line":302,"end_line":304,"code":"func (log *Logger) Sync() error {\n\n\treturn log.core.Sync()\n}\n","neighbors":[{"path":"logger.go","start_line":282,"end_line":301,"code":"// The logger then panics, even if logging at PanicLevel is disabled.\nfunc (log *Logger) Panic(msg string, fields ...Field) {\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting."},{"path":"logger.go","start_line":305,"end_line":324,"code":"\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n\nfunc (log *Logger) clone() *Logger {\n\tclone := *log\n\treturn \u0026clone\n}\n\nfunc (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\t// Logger.check must always be called directly by a method in the\n\t// Logger interface (e.g., Check, Info, Fatal)."}],"selection":{"visibility":"exported","reason":"other","score":0.66},"call_graph":{"callees":[{"symbol":"(*contextObserver).Sync","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"},{"symbol":"(nopCore).Sync","path":"zapcore/core.go"}],"callers":[{"symbol":"(*SugaredLogger).Sync","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Core","signature":"func (log *Logger) Core() zapcore.Core","start_line":307,"end_line":309,"code":"func (log *Logger) Core() zapcore.Core {\n\n\treturn log.core\n}\n","neighbors":[{"path":"logger.go","start_line":287,"end_line":306,"code":"}\n\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core."},{"path":"logger.go","start_line":310,"end_line":329,"code":"\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n\nfunc (log *Logger) clone() *Logger {\n\tclone := *log\n\treturn \u0026clone\n}\n\nfunc (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\t// Logger.check must always be called directly by a method in the\n\t// Logger interface (e.g., Check, Info, Fatal).\n\t// This skips Logger.check and the Info/Fatal/Check/etc. method that\n\t// called it.\n\tconst callerSkipOffset = 2\n\n\t// Check the level first to reduce the cost of disabled log calls."}],"selection":{"visibility":"exported","reason":"other","score":0.62},"call_graph":{"callees":null,"callers":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"NewLogger","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).Name","signature":"func (log *Logger) Name() string","start_line":313,"end_line":315,"code":"func (log *Logger) Name() string {\n\n\treturn log.name\n}\n","neighbors":[{"path":"logger.go","start_line":293,"end_line":312,"code":"// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed."},{"path":"logger.go","start_line":316,"end_line":335,"code":"\nfunc (log *Logger) clone() *Logger {\n\tclone := *log\n\treturn \u0026clone\n}\n\nfunc (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\t// Logger.check must always be called directly by a method in the\n\t// Logger interface (e.g., Check, Info, Fatal).\n\t// This skips Logger.check and the Info/Fatal/Check/etc. method that\n\t// called it.\n\tconst callerSkipOffset = 2\n\n\t// Check the level first to reduce the cost of disabled log calls.\n\t// Since Panic and higher may exit, we skip the optimization for those levels.\n\tif lvl \u003c zapcore.DPanicLevel \u0026\u0026 !log.core.Enabled(lvl) {\n\t\treturn nil\n\t}\n\n\t// Create basic checked entry thru the core; this will be non-nil if the"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).clone","signature":"func (log *Logger) clone() *Logger","start_line":317,"end_line":320,"code":"func (log *Logger) clone() *Logger {\n\n\tclone := *log\n\treturn \u0026clone\n}\n","neighbors":[{"path":"logger.go","start_line":297,"end_line":316,"code":"\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n"},{"path":"logger.go","start_line":321,"end_line":340,"code":"\nfunc (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\t// Logger.check must always be called directly by a method in the\n\t// Logger interface (e.g., Check, Info, Fatal).\n\t// This skips Logger.check and the Info/Fatal/Check/etc. method that\n\t// called it.\n\tconst callerSkipOffset = 2\n\n\t// Check the level first to reduce the cost of disabled log calls.\n\t// Since Panic and higher may exit, we skip the optimization for those levels.\n\tif lvl \u003c zapcore.DPanicLevel \u0026\u0026 !log.core.Enabled(lvl) {\n\t\treturn nil\n\t}\n\n\t// Create basic checked entry thru the core; this will be non-nil if the\n\t// log message will actually be written somewhere.\n\tent := zapcore.Entry{\n\t\tLoggerName: log.name,\n\t\tTime:       log.clock.Now(),\n\t\tLevel:      lvl,"}],"selection":{"visibility":"unexported","reason":"other","score":0.44},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).Named","path":"logger.go"},{"symbol":"(*Logger).Sugar","path":"logger.go"},{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"(*SugaredLogger).Desugar","path":"sugar.go"},{"symbol":"(*SugaredLogger).WithOptions","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"(*Logger).check","signature":"func (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry","start_line":322,"end_line":422,"code":"func (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\n\t\n\t\n\t\n\t\n\tconst callerSkipOffset = 2\n\n\t\n\t\n\tif lvl \u003c zapcore.DPanicLevel \u0026\u0026 !log.core.Enabled(lvl) {\n\t\treturn nil\n\t}\n\n\t\n\t\n\tent := zapcore.Entry{\n\t\tLoggerName: log.name,\n\t\tTime:       log.clock.Now(),\n\t\tLevel:      lvl,\n\t\tMessage:    msg,\n\t}\n\tce := log.core.Check(ent, nil)\n\twillWrite := ce != nil\n\n\t\n\tswitch ent.Level {\n\tcase zapcore.PanicLevel:\n\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenPanic, log.onPanic))\n\tcase zapcore.FatalLevel:\n\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenFatal, log.onFatal))\n\tcase zapcore.DPanicLevel:\n\t\tif log.development {\n\t\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenPanic, log.onPanic))\n\t\t}\n\t}\n\n\t\n\t\n\t\n\tif !willWrite {\n\t\treturn ce\n\t}\n\n\t\n\tce.ErrorOutput = log.errorOutput\n\n\taddStack := log.addStack.Enabled(ce.Level)\n\tif !log.addCaller \u0026\u0026 !addStack {\n\t\treturn ce\n\t}\n\n\t\n\t\n\tstackDepth := stacktrace.First\n\tif addStack {\n\t\tstackDepth = stacktrace.Full\n\t}\n\tstack := stacktrace.Capture(log.callerSkip+callerSkipOffset, stackDepth)\n\tdefer stack.Free()\n\n\tif stack.Count() == 0 {\n\t\tif log.addCaller {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"%v Logger.check error: failed to get caller\\n\",\n\t\t\t\tent.Time.UTC(),\n\t\t\t)\n\t\t\t_ = log.errorOutput.Sync()\n\t\t}\n\t\treturn ce\n\t}\n\n\tframe, more := stack.Next()\n\n\tif log.addCaller {\n\t\tce.Caller = zapcore.EntryCaller{\n\t\t\tDefined:  frame.PC != 0,\n\t\t\tPC:       frame.PC,\n\t\t\tFile:     frame.File,\n\t\t\tLine:     frame.Line,\n\t\t\tFunction: frame.Function,\n\t\t}\n\t}\n\n\tif addStack {\n\t\tbuffer := bufferpool.Get()\n\t\tdefer buffer.Free()\n\n\t\tstackfmt := stacktrace.NewFormatter(buffer)\n\n\t\t\n\t\t\n\t\tstackfmt.FormatFrame(frame)\n\t\tif more {\n\t\t\tstackfmt.FormatStack(stack)\n\t\t}\n\t\tce.Stack = buffer.String()\n\t}\n\n\treturn ce\n}\n","neighbors":[{"path":"logger.go","start_line":302,"end_line":321,"code":"func (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n\nfunc (log *Logger) clone() *Logger {\n\tclone := *log\n\treturn \u0026clone\n}\n"},{"path":"logger.go","start_line":423,"end_line":440,"code":"\nfunc terminalHookOverride(defaultHook, override zapcore.CheckWriteHook) zapcore.CheckWriteHook {\n\t// A nil or WriteThenNoop hook will lead to continued execution after\n\t// a Panic or Fatal log entry, which is unexpected. For example,\n\t//\n\t//   f, err := os.Open(..)\n\t//   if err != nil {\n\t//     log.Fatal(\"cannot open\", zap.Error(err))\n\t//   }\n\t//   fmt.Println(f.Name())\n\t//\n\t// The f.Name() will panic if we continue execution after the log.Fatal.\n\tif override == nil || override == zapcore.WriteThenNoop {\n\t\treturn defaultHook\n\t}\n\treturn override\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.44},"call_graph":{"callees":[{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Buffer).String","path":"buffer/buffer.go"},{"symbol":"(*CheckedEntry).After","path":"zapcore/entry.go"},{"symbol":"(*Formatter).FormatFrame","path":"internal/stacktrace/stack.go"},{"symbol":"(*Formatter).FormatStack","path":"internal/stacktrace/stack.go"},{"symbol":"(*MockClock).Now","path":"internal/ztest/clock.go"},{"symbol":"(*Stack).Count","path":"internal/stacktrace/stack.go"},{"symbol":"(*Stack).Free","path":"internal/stacktrace/stack.go"},{"symbol":"(*Stack).Next","path":"internal/stacktrace/stack.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(Time).UTC","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"(systemClock).Now","path":"zapcore/clock.go"},{"symbol":"Capture","path":"internal/stacktrace/stack.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"NewFormatter","path":"internal/stacktrace/stack.go"},{"symbol":"terminalHookOverride","path":"logger.go"}],"callers":[{"symbol":"(*Logger).Check","path":"logger.go"},{"symbol":"(*Logger).DPanic","path":"logger.go"},{"symbol":"(*Logger).Debug","path":"logger.go"},{"symbol":"(*Logger).Error","path":"logger.go"},{"symbol":"(*Logger).Fatal","path":"logger.go"},{"symbol":"(*Logger).Info","path":"logger.go"},{"symbol":"(*Logger).Log","path":"logger.go"},{"symbol":"(*Logger).Panic","path":"logger.go"},{"symbol":"(*Logger).Warn","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"logger.go","symbol":"terminalHookOverride","signature":"func terminalHookOverride(defaultHook, override zapcore.CheckWriteHook) zapcore.CheckWriteHook","start_line":424,"end_line":439,"code":"func terminalHookOverride(defaultHook, override zapcore.CheckWriteHook) zapcore.CheckWriteHook {\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tif override == nil || override == zapcore.WriteThenNoop {\n\t\treturn defaultHook\n\t}\n\treturn override\n}\n","neighbors":[{"path":"logger.go","start_line":404,"end_line":423,"code":"\t}\n\n\tif addStack {\n\t\tbuffer := bufferpool.Get()\n\t\tdefer buffer.Free()\n\n\t\tstackfmt := stacktrace.NewFormatter(buffer)\n\n\t\t// We've already extracted the first frame, so format that\n\t\t// separately and defer to stackfmt for the rest.\n\t\tstackfmt.FormatFrame(frame)\n\t\tif more {\n\t\t\tstackfmt.FormatStack(stack)\n\t\t}\n\t\tce.Stack = buffer.String()\n\t}\n\n\treturn ce\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).check","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"(optionFunc).apply","signature":"func (f optionFunc) apply(log *Logger)","start_line":37,"end_line":39,"code":"func (f optionFunc) apply(log *Logger) {\n\n\tf(log)\n}\n","neighbors":[{"path":"options.go","start_line":17,"end_line":36,"code":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// An Option configures a Logger.\ntype Option interface {\n\tapply(*Logger)\n}\n\n// optionFunc wraps a func so it satisfies the Option interface.\ntype optionFunc func(*Logger)\n"},{"path":"options.go","start_line":40,"end_line":59,"code":"\n// WrapCore wraps or replaces the Logger's underlying zapcore.Core.\nfunc WrapCore(f func(zapcore.Core) zapcore.Core) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = f(log.core)\n\t})\n}\n\n// Hooks registers functions which will be called each time the Logger writes\n// out an Entry. Repeated use of Hooks is additive.\n//\n// Hooks are useful for simple side effects, like capturing metrics for the\n// number of emitted logs. More complex side effects, including anything that\n// requires access to the Entry's structured fields, should be implemented as\n// a zapcore.Core instead. See zapcore.RegisterHooks for details.\nfunc Hooks(hooks ...func(zapcore.Entry) error) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}"}],"selection":{"visibility":"unexported","reason":"other","score":0.42},"call_graph":{"callees":[{"symbol":"AddCallerSkip$1","path":"options.go"},{"symbol":"AddStacktrace$1","path":"options.go"},{"symbol":"Development$1","path":"options.go"},{"symbol":"ErrorOutput$1","path":"options.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"Hooks$1","path":"options.go"},{"symbol":"IncreaseLevel$1","path":"options.go"},{"symbol":"WithCaller$1","path":"options.go"},{"symbol":"WithClock$1","path":"options.go"},{"symbol":"WithFatalHook$1","path":"options.go"},{"symbol":"WithPanicHook$1","path":"options.go"},{"symbol":"WrapCore$1","path":"options.go"}],"callers":[{"symbol":"(*Logger).WithOptions","path":"logger.go"},{"symbol":"(*SugaredLogger).WithOptions","path":"sugar.go"},{"symbol":"(*optionFunc).apply","path":"options.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"WrapCore","signature":"func WrapCore(f func(zapcore.Core) zapcore.Core) Option","start_line":42,"end_line":46,"code":"func WrapCore(f func(zapcore.Core) zapcore.Core) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = f(log.core)\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":22,"end_line":41,"code":"\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// An Option configures a Logger.\ntype Option interface {\n\tapply(*Logger)\n}\n\n// optionFunc wraps a func so it satisfies the Option interface.\ntype optionFunc func(*Logger)\n\nfunc (f optionFunc) apply(log *Logger) {\n\tf(log)\n}\n\n// WrapCore wraps or replaces the Logger's underlying zapcore.Core."},{"path":"options.go","start_line":47,"end_line":66,"code":"\n// Hooks registers functions which will be called each time the Logger writes\n// out an Entry. Repeated use of Hooks is additive.\n//\n// Hooks are useful for simple side effects, like capturing metrics for the\n// number of emitted logs. More complex side effects, including anything that\n// requires access to the Entry's structured fields, should be implemented as\n// a zapcore.Core instead. See zapcore.RegisterHooks for details.\nfunc Hooks(hooks ...func(zapcore.Entry) error) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}\n\n// Fields adds fields to the Logger.\nfunc Fields(fs ...Field) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).WithLazy","path":"logger.go"},{"symbol":"(Config).buildOptions","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"Hooks","signature":"func Hooks(hooks ...func(zapcore.Entry) error) Option","start_line":55,"end_line":59,"code":"func Hooks(hooks ...func(zapcore.Entry) error) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":35,"end_line":54,"code":"type optionFunc func(*Logger)\n\nfunc (f optionFunc) apply(log *Logger) {\n\tf(log)\n}\n\n// WrapCore wraps or replaces the Logger's underlying zapcore.Core.\nfunc WrapCore(f func(zapcore.Core) zapcore.Core) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = f(log.core)\n\t})\n}\n\n// Hooks registers functions which will be called each time the Logger writes\n// out an Entry. Repeated use of Hooks is additive.\n//\n// Hooks are useful for simple side effects, like capturing metrics for the\n// number of emitted logs. More complex side effects, including anything that\n// requires access to the Entry's structured fields, should be implemented as\n// a zapcore.Core instead. See zapcore.RegisterHooks for details."},{"path":"options.go","start_line":60,"end_line":79,"code":"\n// Fields adds fields to the Logger.\nfunc Fields(fs ...Field) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}\n\n// ErrorOutput sets the destination for errors generated by the Logger. Note\n// that this option only affects internal errors; for sample code that sends\n// error-level logs to a different location from info- and debug-level logs,\n// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex.\nfunc ErrorOutput(w zapcore.WriteSyncer) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"Fields","signature":"func Fields(fs ...Field) Option","start_line":62,"end_line":66,"code":"func Fields(fs ...Field) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":42,"end_line":61,"code":"func WrapCore(f func(zapcore.Core) zapcore.Core) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = f(log.core)\n\t})\n}\n\n// Hooks registers functions which will be called each time the Logger writes\n// out an Entry. Repeated use of Hooks is additive.\n//\n// Hooks are useful for simple side effects, like capturing metrics for the\n// number of emitted logs. More complex side effects, including anything that\n// requires access to the Entry's structured fields, should be implemented as\n// a zapcore.Core instead. See zapcore.RegisterHooks for details.\nfunc Hooks(hooks ...func(zapcore.Entry) error) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}\n\n// Fields adds fields to the Logger."},{"path":"options.go","start_line":67,"end_line":86,"code":"\n// ErrorOutput sets the destination for errors generated by the Logger. Note\n// that this option only affects internal errors; for sample code that sends\n// error-level logs to a different location from info- and debug-level logs,\n// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex.\nfunc ErrorOutput(w zapcore.WriteSyncer) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}\n\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error.\nfunc Development() Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(Config).buildOptions","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"ErrorOutput","signature":"func ErrorOutput(w zapcore.WriteSyncer) Option","start_line":75,"end_line":79,"code":"func ErrorOutput(w zapcore.WriteSyncer) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":55,"end_line":74,"code":"func Hooks(hooks ...func(zapcore.Entry) error) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}\n\n// Fields adds fields to the Logger.\nfunc Fields(fs ...Field) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}\n\n// ErrorOutput sets the destination for errors generated by the Logger. Note\n// that this option only affects internal errors; for sample code that sends\n// error-level logs to a different location from info- and debug-level logs,\n// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex."},{"path":"options.go","start_line":80,"end_line":99,"code":"\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error.\nfunc Development() Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})\n}\n\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller.\nfunc AddCaller() Option {\n\treturn WithCaller(true)\n}\n\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":[{"symbol":"(Config).buildOptions","path":"config.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"Development","signature":"func Development() Option","start_line":83,"end_line":87,"code":"func Development() Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":63,"end_line":82,"code":"\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}\n\n// ErrorOutput sets the destination for errors generated by the Logger. Note\n// that this option only affects internal errors; for sample code that sends\n// error-level logs to a different location from info- and debug-level logs,\n// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex.\nfunc ErrorOutput(w zapcore.WriteSyncer) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}\n\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error."},{"path":"options.go","start_line":88,"end_line":107,"code":"\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller.\nfunc AddCaller() Option {\n\treturn WithCaller(true)\n}\n\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(Config).buildOptions","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"AddCaller","signature":"func AddCaller() Option","start_line":91,"end_line":93,"code":"func AddCaller() Option {\n\n\treturn WithCaller(true)\n}\n","neighbors":[{"path":"options.go","start_line":71,"end_line":90,"code":"// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex.\nfunc ErrorOutput(w zapcore.WriteSyncer) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}\n\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error.\nfunc Development() Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})\n}\n\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller."},{"path":"options.go","start_line":94,"end_line":113,"code":"\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller.\nfunc AddCallerSkip(skip int) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"WithCaller","path":"options.go"}],"callers":[{"symbol":"(Config).buildOptions","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"WithCaller","signature":"func WithCaller(enabled bool) Option","start_line":98,"end_line":102,"code":"func WithCaller(enabled bool) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":78,"end_line":97,"code":"\t})\n}\n\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error.\nfunc Development() Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})\n}\n\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller.\nfunc AddCaller() Option {\n\treturn WithCaller(true)\n}\n\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller."},{"path":"options.go","start_line":103,"end_line":122,"code":"\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller.\nfunc AddCallerSkip(skip int) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n\n// AddStacktrace configures the Logger to record a stack trace for all messages at\n// or above a given level.\nfunc AddStacktrace(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addStack = lvl\n\t})\n}\n\n// IncreaseLevel increase the level of the logger. It has no effect if"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"AddCaller","path":"options.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"AddCallerSkip","signature":"func AddCallerSkip(skip int) Option","start_line":108,"end_line":112,"code":"func AddCallerSkip(skip int) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":88,"end_line":107,"code":"\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller.\nfunc AddCaller() Option {\n\treturn WithCaller(true)\n}\n\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller."},{"path":"options.go","start_line":113,"end_line":132,"code":"\n// AddStacktrace configures the Logger to record a stack trace for all messages at\n// or above a given level.\nfunc AddStacktrace(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addStack = lvl\n\t})\n}\n\n// IncreaseLevel increase the level of the logger. It has no effect if\n// the passed in level tries to decrease the level of the logger.\nfunc IncreaseLevel(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tcore, err := zapcore.NewIncreaseLevelCore(log.core, lvl)\n\t\tif err != nil {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"failed to IncreaseLevel: %v\\n\",\n\t\t\t\terr,\n\t\t\t)"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":null,"callers":[{"symbol":"NewStdLog","path":"global.go"},{"symbol":"NewStdLogAt","path":"global.go"},{"symbol":"redirectStdLogAt","path":"global.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"AddStacktrace","signature":"func AddStacktrace(lvl zapcore.LevelEnabler) Option","start_line":116,"end_line":120,"code":"func AddStacktrace(lvl zapcore.LevelEnabler) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addStack = lvl\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":96,"end_line":115,"code":"// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller.\nfunc AddCallerSkip(skip int) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n\n// AddStacktrace configures the Logger to record a stack trace for all messages at\n// or above a given level."},{"path":"options.go","start_line":121,"end_line":140,"code":"\n// IncreaseLevel increase the level of the logger. It has no effect if\n// the passed in level tries to decrease the level of the logger.\nfunc IncreaseLevel(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tcore, err := zapcore.NewIncreaseLevelCore(log.core, lvl)\n\t\tif err != nil {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"failed to IncreaseLevel: %v\\n\",\n\t\t\t\terr,\n\t\t\t)\n\t\t} else {\n\t\t\tlog.core = core\n\t\t}\n\t})\n}\n\n// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.\n// Zap will call this hook after writing a log statement with a Panic/DPanic level."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"(Config).buildOptions","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"IncreaseLevel","signature":"func IncreaseLevel(lvl zapcore.LevelEnabler) Option","start_line":124,"end_line":137,"code":"func IncreaseLevel(lvl zapcore.LevelEnabler) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tcore, err := zapcore.NewIncreaseLevelCore(log.core, lvl)\n\t\tif err != nil {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"failed to IncreaseLevel: %v\\n\",\n\t\t\t\terr,\n\t\t\t)\n\t\t} else {\n\t\t\tlog.core = core\n\t\t}\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":104,"end_line":123,"code":"// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller.\nfunc AddCallerSkip(skip int) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n\n// AddStacktrace configures the Logger to record a stack trace for all messages at\n// or above a given level.\nfunc AddStacktrace(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addStack = lvl\n\t})\n}\n\n// IncreaseLevel increase the level of the logger. It has no effect if\n// the passed in level tries to decrease the level of the logger."},{"path":"options.go","start_line":138,"end_line":157,"code":"\n// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.\n// Zap will call this hook after writing a log statement with a Panic/DPanic level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a Panic/DPanic log message, but it will not start a panic.\n//\n//\tzap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))\n//\n// This is useful for testing Panic/DPanic log output.\nfunc WithPanicHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onPanic = hook\n\t})\n}\n\n// OnFatal sets the action to take on fatal logs.\n//\n// Deprecated: Use [WithFatalHook] instead.\nfunc OnFatal(action zapcore.CheckWriteAction) Option {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"WithPanicHook","signature":"func WithPanicHook(hook zapcore.CheckWriteHook) Option","start_line":148,"end_line":152,"code":"func WithPanicHook(hook zapcore.CheckWriteHook) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onPanic = hook\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":128,"end_line":147,"code":"\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"failed to IncreaseLevel: %v\\n\",\n\t\t\t\terr,\n\t\t\t)\n\t\t} else {\n\t\t\tlog.core = core\n\t\t}\n\t})\n}\n\n// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.\n// Zap will call this hook after writing a log statement with a Panic/DPanic level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a Panic/DPanic log message, but it will not start a panic.\n//\n//\tzap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))\n//\n// This is useful for testing Panic/DPanic log output."},{"path":"options.go","start_line":153,"end_line":172,"code":"\n// OnFatal sets the action to take on fatal logs.\n//\n// Deprecated: Use [WithFatalHook] instead.\nfunc OnFatal(action zapcore.CheckWriteAction) Option {\n\treturn WithFatalHook(action)\n}\n\n// WithFatalHook sets a CheckWriteHook to run on fatal logs.\n// Zap will call this hook after writing a log statement with a Fatal level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a fatal log message, but it will not exit the\n// program.\n//\n//\tzap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))\n//\n// It is important that the provided CheckWriteHook stops the control flow at\n// the current statement to meet expectations of callers of the logger.\n// We recommend calling os.Exit or runtime.Goexit inside custom hooks at"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"OnFatal","signature":"func OnFatal(action zapcore.CheckWriteAction) Option","start_line":157,"end_line":159,"code":"func OnFatal(action zapcore.CheckWriteAction) Option {\n\n\treturn WithFatalHook(action)\n}\n","neighbors":[{"path":"options.go","start_line":137,"end_line":156,"code":"}\n\n// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.\n// Zap will call this hook after writing a log statement with a Panic/DPanic level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a Panic/DPanic log message, but it will not start a panic.\n//\n//\tzap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))\n//\n// This is useful for testing Panic/DPanic log output.\nfunc WithPanicHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onPanic = hook\n\t})\n}\n\n// OnFatal sets the action to take on fatal logs.\n//\n// Deprecated: Use [WithFatalHook] instead."},{"path":"options.go","start_line":160,"end_line":179,"code":"\n// WithFatalHook sets a CheckWriteHook to run on fatal logs.\n// Zap will call this hook after writing a log statement with a Fatal level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a fatal log message, but it will not exit the\n// program.\n//\n//\tzap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))\n//\n// It is important that the provided CheckWriteHook stops the control flow at\n// the current statement to meet expectations of callers of the logger.\n// We recommend calling os.Exit or runtime.Goexit inside custom hooks at\n// minimum.\nfunc WithFatalHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onFatal = hook\n\t})\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"WithFatalHook","path":"options.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"WithFatalHook","signature":"func WithFatalHook(hook zapcore.CheckWriteHook) Option","start_line":174,"end_line":178,"code":"func WithFatalHook(hook zapcore.CheckWriteHook) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onFatal = hook\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":154,"end_line":173,"code":"// OnFatal sets the action to take on fatal logs.\n//\n// Deprecated: Use [WithFatalHook] instead.\nfunc OnFatal(action zapcore.CheckWriteAction) Option {\n\treturn WithFatalHook(action)\n}\n\n// WithFatalHook sets a CheckWriteHook to run on fatal logs.\n// Zap will call this hook after writing a log statement with a Fatal level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a fatal log message, but it will not exit the\n// program.\n//\n//\tzap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))\n//\n// It is important that the provided CheckWriteHook stops the control flow at\n// the current statement to meet expectations of callers of the logger.\n// We recommend calling os.Exit or runtime.Goexit inside custom hooks at\n// minimum."},{"path":"options.go","start_line":179,"end_line":187,"code":"\n// WithClock specifies the clock used by the logger to determine the current\n// time for logged entries. Defaults to the system clock with time.Now.\nfunc WithClock(clock zapcore.Clock) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.clock = clock\n\t})\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"OnFatal","path":"options.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"options.go","symbol":"WithClock","signature":"func WithClock(clock zapcore.Clock) Option","start_line":182,"end_line":186,"code":"func WithClock(clock zapcore.Clock) Option {\n\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.clock = clock\n\t})\n}\n","neighbors":[{"path":"options.go","start_line":162,"end_line":181,"code":"// Zap will call this hook after writing a log statement with a Fatal level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a fatal log message, but it will not exit the\n// program.\n//\n//\tzap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))\n//\n// It is important that the provided CheckWriteHook stops the control flow at\n// the current statement to meet expectations of callers of the logger.\n// We recommend calling os.Exit or runtime.Goexit inside custom hooks at\n// minimum.\nfunc WithFatalHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onFatal = hook\n\t})\n}\n\n// WithClock specifies the clock used by the logger to determine the current\n// time for logged entries. Defaults to the system clock with time.Now."}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(*errSinkNotFound).Error","signature":"func (e *errSinkNotFound) Error() string","start_line":50,"end_line":52,"code":"func (e *errSinkNotFound) Error() string {\n\n\treturn fmt.Sprintf(\"no sink found for scheme %q\", e.scheme)\n}\n","neighbors":[{"path":"sink.go","start_line":30,"end_line":49,"code":"\t\"strings\"\n\t\"sync\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nconst schemeFile = \"file\"\n\nvar _sinkRegistry = newSinkRegistry()\n\n// Sink defines the interface to write to and close logger destinations.\ntype Sink interface {\n\tzapcore.WriteSyncer\n\tio.Closer\n}\n\ntype errSinkNotFound struct {\n\tscheme string\n}\n"},{"path":"sink.go","start_line":53,"end_line":72,"code":"\ntype nopCloserSink struct{ zapcore.WriteSyncer }\n\nfunc (nopCloserSink) Close() error { return nil }\n\ntype sinkRegistry struct {\n\tmu        sync.Mutex\n\tfactories map[string]func(*url.URL) (Sink, error)          // keyed by scheme\n\topenFile  func(string, int, os.FileMode) (*os.File, error) // type matches os.OpenFile\n}\n\nfunc newSinkRegistry() *sinkRegistry {\n\tsr := \u0026sinkRegistry{\n\t\tfactories: make(map[string]func(*url.URL) (Sink, error)),\n\t\topenFile:  os.OpenFile,\n\t}\n\t// Infallible operation: the registry is empty, so we can't have a conflict.\n\t_ = sr.RegisterSink(schemeFile, sr.newFileSinkFromURL)\n\treturn sr\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*Certificate).checkNameConstraints","path":"../../../../usr/local/go/src/crypto/x509/verify.go"},{"symbol":"(*Conn).processCertsFromClient","path":"../../../../usr/local/go/src/crypto/tls/handshake_server.go"},{"symbol":"(*Conn).verifyServerCertificate","path":"../../../../usr/local/go/src/crypto/tls/handshake_client.go"},{"symbol":"(*DNSConfigError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Error).Error","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*LinkError).Error","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"(*NumError).Error","path":"../../../../usr/local/go/src/strconv/atoi.go"},{"symbol":"(*Part).populateHeaders","path":"../../../../usr/local/go/src/mime/multipart/multipart.go"},{"symbol":"(*Resolver).resolveAddrList","path":"../../../../usr/local/go/src/net/dial.go"},{"symbol":"(*Resolver).tryOneName","path":"../../../../usr/local/go/src/net/dnsclient_unix.go"},{"symbol":"(*cancelTimerBody).Read","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*clientHandshakeStateTLS13).readServerCertificate","path":"../../../../usr/local/go/src/crypto/tls/handshake_client_tls13.go"},{"symbol":"(*ecdheKeyAgreement).generateServerKeyExchange","path":"../../../../usr/local/go/src/crypto/tls/key_agreement.go"},{"symbol":"(*ecdheKeyAgreement).processServerKeyExchange","path":"../../../../usr/local/go/src/crypto/tls/key_agreement.go"},{"symbol":"(*joinError).Error","path":"../../../../usr/local/go/src/errors/join.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*nestedError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/dns/dnsmessage/message.go"},{"symbol":"(*serverHandshakeStateTLS13).readClientCertificate","path":"../../../../usr/local/go/src/crypto/tls/handshake_server_tls13.go"},{"symbol":"(SystemRootsError).Error","path":"../../../../usr/local/go/src/crypto/x509/verify.go"},{"symbol":"(Time).appendTo","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(wrappedError).Error","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"CAST","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"EncryptPEMBlock","path":"../../../../usr/local/go/src/crypto/x509/pem_decrypt.go"},{"symbol":"MustNewName","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/dns/dnsmessage/message.go"},{"symbol":"ParsePrefix","path":"../../../../usr/local/go/src/net/netip/netip.go"},{"symbol":"Read","path":"../../../../usr/local/go/src/crypto/internal/sysrand/rand.go"},{"symbol":"cgoLookupHostIP","path":"../../../../usr/local/go/src/net/cgo_unix.go"},{"symbol":"filterAddrList","path":"../../../../usr/local/go/src/net/ipsock.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"serveContent","path":"../../../../usr/local/go/src/net/http/fs.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(nopCloserSink).Close","signature":"func (nopCloserSink) Close() error","start_line":56,"end_line":56,"code":"func (nopCloserSink) Close() error {\n return nil }\n","neighbors":[{"path":"sink.go","start_line":36,"end_line":55,"code":"const schemeFile = \"file\"\n\nvar _sinkRegistry = newSinkRegistry()\n\n// Sink defines the interface to write to and close logger destinations.\ntype Sink interface {\n\tzapcore.WriteSyncer\n\tio.Closer\n}\n\ntype errSinkNotFound struct {\n\tscheme string\n}\n\nfunc (e *errSinkNotFound) Error() string {\n\treturn fmt.Sprintf(\"no sink found for scheme %q\", e.scheme)\n}\n\ntype nopCloserSink struct{ zapcore.WriteSyncer }\n"},{"path":"sink.go","start_line":57,"end_line":76,"code":"\ntype sinkRegistry struct {\n\tmu        sync.Mutex\n\tfactories map[string]func(*url.URL) (Sink, error)          // keyed by scheme\n\topenFile  func(string, int, os.FileMode) (*os.File, error) // type matches os.OpenFile\n}\n\nfunc newSinkRegistry() *sinkRegistry {\n\tsr := \u0026sinkRegistry{\n\t\tfactories: make(map[string]func(*url.URL) (Sink, error)),\n\t\topenFile:  os.OpenFile,\n\t}\n\t// Infallible operation: the registry is empty, so we can't have a conflict.\n\t_ = sr.RegisterSink(schemeFile, sr.newFileSinkFromURL)\n\treturn sr\n}\n\n// RegisterSink registers the given factory for the specific scheme.\nfunc (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\tsr.mu.Lock()"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":null,"callers":[{"symbol":"(*Client).do","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*Reader).Close","path":"../../../../usr/local/go/src/compress/gzip/gunzip.go"},{"symbol":"(*Request).closeBody","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*Response).closeBody","path":"../../../../usr/local/go/src/net/http/response.go"},{"symbol":"(*bodyEOFSignal).Close","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*cancelTimerBody).Close","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*chunkWriter).writeHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*expectContinueReader).Close","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*http2clientStream).cleanupWriteRequest","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2gzipReader).Close","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*maxBytesReader).Close","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*nopCloserSink).Close","path":"sink.go"},{"symbol":"(*readTrackingBody).Close","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*response).finishRequest","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*transferWriter).writeBody","path":"../../../../usr/local/go/src/net/http/transfer.go"},{"symbol":"(Invoke).Invoke","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(StreamWriter).Close","path":"../../../../usr/local/go/src/crypto/cipher/io.go"},{"symbol":"(WordEncoder).bEncode","path":"../../../../usr/local/go/src/mime/encodedword.go"},{"symbol":"(sectionReadCloser).Close","path":"../../../../usr/local/go/src/mime/multipart/formdata.go"},{"symbol":"CAST","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Encode","path":"../../../../usr/local/go/src/encoding/pem/pem.go"},{"symbol":"PCT","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"closeDescriptors","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"closeReqBodyLocked$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"ignoringEINTR","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"open$1","path":"writer.go"},{"symbol":"roundTrip$2","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"serve$1","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"writeBody$1","path":"../../../../usr/local/go/src/net/http/transfer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"newSinkRegistry","signature":"func newSinkRegistry() *sinkRegistry","start_line":64,"end_line":72,"code":"func newSinkRegistry() *sinkRegistry {\n\n\tsr := \u0026sinkRegistry{\n\t\tfactories: make(map[string]func(*url.URL) (Sink, error)),\n\t\topenFile:  os.OpenFile,\n\t}\n\t\n\t_ = sr.RegisterSink(schemeFile, sr.newFileSinkFromURL)\n\treturn sr\n}\n","neighbors":[{"path":"sink.go","start_line":44,"end_line":63,"code":"}\n\ntype errSinkNotFound struct {\n\tscheme string\n}\n\nfunc (e *errSinkNotFound) Error() string {\n\treturn fmt.Sprintf(\"no sink found for scheme %q\", e.scheme)\n}\n\ntype nopCloserSink struct{ zapcore.WriteSyncer }\n\nfunc (nopCloserSink) Close() error { return nil }\n\ntype sinkRegistry struct {\n\tmu        sync.Mutex\n\tfactories map[string]func(*url.URL) (Sink, error)          // keyed by scheme\n\topenFile  func(string, int, os.FileMode) (*os.File, error) // type matches os.OpenFile\n}\n"},{"path":"sink.go","start_line":73,"end_line":92,"code":"\n// RegisterSink registers the given factory for the specific scheme.\nfunc (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\n\tif scheme == \"\" {\n\t\treturn errors.New(\"can't register a sink factory for empty string\")\n\t}\n\tnormalized, err := normalizeScheme(scheme)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%q is not a valid scheme: %v\", scheme, err)\n\t}\n\tif _, ok := sr.factories[normalized]; ok {\n\t\treturn fmt.Errorf(\"sink factory already registered for scheme %q\", normalized)\n\t}\n\tsr.factories[normalized] = factory\n\treturn nil\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*sinkRegistry).RegisterSink","path":"sink.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(*sinkRegistry).RegisterSink","signature":"func (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error","start_line":75,"end_line":91,"code":"func (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\n\tif scheme == \"\" {\n\t\treturn errors.New(\"can't register a sink factory for empty string\")\n\t}\n\tnormalized, err := normalizeScheme(scheme)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%q is not a valid scheme: %v\", scheme, err)\n\t}\n\tif _, ok := sr.factories[normalized]; ok {\n\t\treturn fmt.Errorf(\"sink factory already registered for scheme %q\", normalized)\n\t}\n\tsr.factories[normalized] = factory\n\treturn nil\n}\n","neighbors":[{"path":"sink.go","start_line":55,"end_line":74,"code":"\nfunc (nopCloserSink) Close() error { return nil }\n\ntype sinkRegistry struct {\n\tmu        sync.Mutex\n\tfactories map[string]func(*url.URL) (Sink, error)          // keyed by scheme\n\topenFile  func(string, int, os.FileMode) (*os.File, error) // type matches os.OpenFile\n}\n\nfunc newSinkRegistry() *sinkRegistry {\n\tsr := \u0026sinkRegistry{\n\t\tfactories: make(map[string]func(*url.URL) (Sink, error)),\n\t\topenFile:  os.OpenFile,\n\t}\n\t// Infallible operation: the registry is empty, so we can't have a conflict.\n\t_ = sr.RegisterSink(schemeFile, sr.newFileSinkFromURL)\n\treturn sr\n}\n\n// RegisterSink registers the given factory for the specific scheme."},{"path":"sink.go","start_line":92,"end_line":111,"code":"\nfunc (sr *sinkRegistry) newSink(rawURL string) (Sink, error) {\n\t// URL parsing doesn't work well for Windows paths such as `c:\\log.txt`, as scheme is set to\n\t// the drive, and path is unset unless `c:/log.txt` is used.\n\t// To avoid Windows-specific URL handling, we instead check IsAbs to open as a file.\n\t// filepath.IsAbs is OS-specific, so IsAbs('c:/log.txt') is false outside of Windows.\n\tif filepath.IsAbs(rawURL) {\n\t\treturn sr.newFileSinkFromPath(rawURL)\n\t}\n\n\tu, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse %q as a URL: %v\", rawURL, err)\n\t}\n\tif u.Scheme == \"\" {\n\t\tu.Scheme = schemeFile\n\t}\n\n\tsr.mu.Lock()\n\tfactory, ok := sr.factories[u.Scheme]"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"normalizeScheme","path":"sink.go"}],"callers":[{"symbol":"RegisterSink","path":"sink.go"},{"symbol":"newSinkRegistry","path":"sink.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(*sinkRegistry).newSink","signature":"func (sr *sinkRegistry) newSink(rawURL string) (Sink, error)","start_line":93,"end_line":117,"code":"func (sr *sinkRegistry) newSink(rawURL string) (Sink, error) {\n\n\t\n\t\n\t\n\t\n\tif filepath.IsAbs(rawURL) {\n\t\treturn sr.newFileSinkFromPath(rawURL)\n\t}\n\n\tu, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse %q as a URL: %v\", rawURL, err)\n\t}\n\tif u.Scheme == \"\" {\n\t\tu.Scheme = schemeFile\n\t}\n\n\tsr.mu.Lock()\n\tfactory, ok := sr.factories[u.Scheme]\n\tsr.mu.Unlock()\n\tif !ok {\n\t\treturn nil, \u0026errSinkNotFound{u.Scheme}\n\t}\n\treturn factory(u)\n}\n","neighbors":[{"path":"sink.go","start_line":73,"end_line":92,"code":"\n// RegisterSink registers the given factory for the specific scheme.\nfunc (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\n\tif scheme == \"\" {\n\t\treturn errors.New(\"can't register a sink factory for empty string\")\n\t}\n\tnormalized, err := normalizeScheme(scheme)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%q is not a valid scheme: %v\", scheme, err)\n\t}\n\tif _, ok := sr.factories[normalized]; ok {\n\t\treturn fmt.Errorf(\"sink factory already registered for scheme %q\", normalized)\n\t}\n\tsr.factories[normalized] = factory\n\treturn nil\n}\n"},{"path":"sink.go","start_line":118,"end_line":137,"code":"\n// RegisterSink registers a user-supplied factory for all sinks with a\n// particular scheme.\n//\n// All schemes must be ASCII, valid under section 0.1 of RFC 3986\n// (https://tools.ietf.org/html/rfc3983#section-3.1), and must not already\n// have a factory registered. Zap automatically registers a factory for the\n// \"file\" scheme.\nfunc RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\treturn _sinkRegistry.RegisterSink(scheme, factory)\n}\n\nfunc (sr *sinkRegistry) newFileSinkFromURL(u *url.URL) (Sink, error) {\n\tif u.User != nil {\n\t\treturn nil, fmt.Errorf(\"user and password not allowed with file URLs: got %v\", u)\n\t}\n\tif u.Fragment != \"\" {\n\t\treturn nil, fmt.Errorf(\"fragments not allowed with file URLs: got %v\", u)\n\t}\n\tif u.RawQuery != \"\" {"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*sinkRegistry).newFileSinkFromPath","path":"sink.go"},{"symbol":"(*sinkRegistry).newFileSinkFromURL","path":"sink.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"IsAbs","path":"../../../../usr/local/go/src/path/filepath/path.go"},{"symbol":"Parse","path":"../../../../usr/local/go/src/net/url/url.go"}],"callers":[{"symbol":"open","path":"writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"RegisterSink","signature":"func RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error","start_line":126,"end_line":128,"code":"func RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\n\treturn _sinkRegistry.RegisterSink(scheme, factory)\n}\n","neighbors":[{"path":"sink.go","start_line":106,"end_line":125,"code":"\tif u.Scheme == \"\" {\n\t\tu.Scheme = schemeFile\n\t}\n\n\tsr.mu.Lock()\n\tfactory, ok := sr.factories[u.Scheme]\n\tsr.mu.Unlock()\n\tif !ok {\n\t\treturn nil, \u0026errSinkNotFound{u.Scheme}\n\t}\n\treturn factory(u)\n}\n\n// RegisterSink registers a user-supplied factory for all sinks with a\n// particular scheme.\n//\n// All schemes must be ASCII, valid under section 0.1 of RFC 3986\n// (https://tools.ietf.org/html/rfc3983#section-3.1), and must not already\n// have a factory registered. Zap automatically registers a factory for the\n// \"file\" scheme."},{"path":"sink.go","start_line":129,"end_line":148,"code":"\nfunc (sr *sinkRegistry) newFileSinkFromURL(u *url.URL) (Sink, error) {\n\tif u.User != nil {\n\t\treturn nil, fmt.Errorf(\"user and password not allowed with file URLs: got %v\", u)\n\t}\n\tif u.Fragment != \"\" {\n\t\treturn nil, fmt.Errorf(\"fragments not allowed with file URLs: got %v\", u)\n\t}\n\tif u.RawQuery != \"\" {\n\t\treturn nil, fmt.Errorf(\"query parameters not allowed with file URLs: got %v\", u)\n\t}\n\t// Error messages are better if we check hostname and port separately.\n\tif u.Port() != \"\" {\n\t\treturn nil, fmt.Errorf(\"ports not allowed with file URLs: got %v\", u)\n\t}\n\tif hn := u.Hostname(); hn != \"\" \u0026\u0026 hn != \"localhost\" {\n\t\treturn nil, fmt.Errorf(\"file URLs must leave host empty or use localhost: got %v\", u)\n\t}\n\n\treturn sr.newFileSinkFromPath(u.Path)"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*sinkRegistry).RegisterSink","path":"sink.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(*sinkRegistry).newFileSinkFromURL","signature":"func (sr *sinkRegistry) newFileSinkFromURL(u *url.URL) (Sink, error)","start_line":130,"end_line":149,"code":"func (sr *sinkRegistry) newFileSinkFromURL(u *url.URL) (Sink, error) {\n\n\tif u.User != nil {\n\t\treturn nil, fmt.Errorf(\"user and password not allowed with file URLs: got %v\", u)\n\t}\n\tif u.Fragment != \"\" {\n\t\treturn nil, fmt.Errorf(\"fragments not allowed with file URLs: got %v\", u)\n\t}\n\tif u.RawQuery != \"\" {\n\t\treturn nil, fmt.Errorf(\"query parameters not allowed with file URLs: got %v\", u)\n\t}\n\t\n\tif u.Port() != \"\" {\n\t\treturn nil, fmt.Errorf(\"ports not allowed with file URLs: got %v\", u)\n\t}\n\tif hn := u.Hostname(); hn != \"\" \u0026\u0026 hn != \"localhost\" {\n\t\treturn nil, fmt.Errorf(\"file URLs must leave host empty or use localhost: got %v\", u)\n\t}\n\n\treturn sr.newFileSinkFromPath(u.Path)\n}\n","neighbors":[{"path":"sink.go","start_line":110,"end_line":129,"code":"\tsr.mu.Lock()\n\tfactory, ok := sr.factories[u.Scheme]\n\tsr.mu.Unlock()\n\tif !ok {\n\t\treturn nil, \u0026errSinkNotFound{u.Scheme}\n\t}\n\treturn factory(u)\n}\n\n// RegisterSink registers a user-supplied factory for all sinks with a\n// particular scheme.\n//\n// All schemes must be ASCII, valid under section 0.1 of RFC 3986\n// (https://tools.ietf.org/html/rfc3983#section-3.1), and must not already\n// have a factory registered. Zap automatically registers a factory for the\n// \"file\" scheme.\nfunc RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\treturn _sinkRegistry.RegisterSink(scheme, factory)\n}\n"},{"path":"sink.go","start_line":150,"end_line":169,"code":"\nfunc (sr *sinkRegistry) newFileSinkFromPath(path string) (Sink, error) {\n\tswitch path {\n\tcase \"stdout\":\n\t\treturn nopCloserSink{os.Stdout}, nil\n\tcase \"stderr\":\n\t\treturn nopCloserSink{os.Stderr}, nil\n\t}\n\treturn sr.openFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o666)\n}\n\nfunc normalizeScheme(s string) (string, error) {\n\t// https://tools.ietf.org/html/rfc3986#section-3.1\n\ts = strings.ToLower(s)\n\tif first := s[0]; 'a' \u003e first || 'z' \u003c first {\n\t\treturn \"\", errors.New(\"must start with a letter\")\n\t}\n\tfor i := 1; i \u003c len(s); i++ { // iterate over bytes, not runes\n\t\tc := s[i]\n\t\tswitch {"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*URL).Hostname","path":"../../../../usr/local/go/src/net/url/url.go"},{"symbol":"(*URL).Port","path":"../../../../usr/local/go/src/net/url/url.go"},{"symbol":"(*sinkRegistry).newFileSinkFromPath","path":"sink.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"}],"callers":[{"symbol":"(*sinkRegistry).newSink","path":"sink.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"(*sinkRegistry).newFileSinkFromPath","signature":"func (sr *sinkRegistry) newFileSinkFromPath(path string) (Sink, error)","start_line":151,"end_line":159,"code":"func (sr *sinkRegistry) newFileSinkFromPath(path string) (Sink, error) {\n\n\tswitch path {\n\tcase \"stdout\":\n\t\treturn nopCloserSink{os.Stdout}, nil\n\tcase \"stderr\":\n\t\treturn nopCloserSink{os.Stderr}, nil\n\t}\n\treturn sr.openFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o666)\n}\n","neighbors":[{"path":"sink.go","start_line":131,"end_line":150,"code":"\tif u.User != nil {\n\t\treturn nil, fmt.Errorf(\"user and password not allowed with file URLs: got %v\", u)\n\t}\n\tif u.Fragment != \"\" {\n\t\treturn nil, fmt.Errorf(\"fragments not allowed with file URLs: got %v\", u)\n\t}\n\tif u.RawQuery != \"\" {\n\t\treturn nil, fmt.Errorf(\"query parameters not allowed with file URLs: got %v\", u)\n\t}\n\t// Error messages are better if we check hostname and port separately.\n\tif u.Port() != \"\" {\n\t\treturn nil, fmt.Errorf(\"ports not allowed with file URLs: got %v\", u)\n\t}\n\tif hn := u.Hostname(); hn != \"\" \u0026\u0026 hn != \"localhost\" {\n\t\treturn nil, fmt.Errorf(\"file URLs must leave host empty or use localhost: got %v\", u)\n\t}\n\n\treturn sr.newFileSinkFromPath(u.Path)\n}\n"},{"path":"sink.go","start_line":160,"end_line":179,"code":"\nfunc normalizeScheme(s string) (string, error) {\n\t// https://tools.ietf.org/html/rfc3986#section-3.1\n\ts = strings.ToLower(s)\n\tif first := s[0]; 'a' \u003e first || 'z' \u003c first {\n\t\treturn \"\", errors.New(\"must start with a letter\")\n\t}\n\tfor i := 1; i \u003c len(s); i++ { // iterate over bytes, not runes\n\t\tc := s[i]\n\t\tswitch {\n\t\tcase 'a' \u003c= c \u0026\u0026 c \u003c= 'z':\n\t\t\tcontinue\n\t\tcase '0' \u003c= c \u0026\u0026 c \u003c= '9':\n\t\t\tcontinue\n\t\tcase c == '.' || c == '+' || c == '-':\n\t\t\tcontinue\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"may not contain %q\", c)\n\t}\n\treturn s, nil"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"OpenFile","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"openFileNolog","path":"../../../../usr/local/go/src/os/file_unix.go"}],"callers":[{"symbol":"(*sinkRegistry).newFileSinkFromURL","path":"sink.go"},{"symbol":"(*sinkRegistry).newSink","path":"sink.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sink.go","symbol":"normalizeScheme","signature":"func normalizeScheme(s string) (string, error)","start_line":161,"end_line":180,"code":"func normalizeScheme(s string) (string, error) {\n\n\t\n\ts = strings.ToLower(s)\n\tif first := s[0]; 'a' \u003e first || 'z' \u003c first {\n\t\treturn \"\", errors.New(\"must start with a letter\")\n\t}\n\tfor i := 1; i \u003c len(s); i++ { \n\t\tc := s[i]\n\t\tswitch {\n\t\tcase 'a' \u003c= c \u0026\u0026 c \u003c= 'z':\n\t\t\tcontinue\n\t\tcase '0' \u003c= c \u0026\u0026 c \u003c= '9':\n\t\t\tcontinue\n\t\tcase c == '.' || c == '+' || c == '-':\n\t\t\tcontinue\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"may not contain %q\", c)\n\t}\n\treturn s, nil\n}\n","neighbors":[{"path":"sink.go","start_line":141,"end_line":160,"code":"\tif u.Port() != \"\" {\n\t\treturn nil, fmt.Errorf(\"ports not allowed with file URLs: got %v\", u)\n\t}\n\tif hn := u.Hostname(); hn != \"\" \u0026\u0026 hn != \"localhost\" {\n\t\treturn nil, fmt.Errorf(\"file URLs must leave host empty or use localhost: got %v\", u)\n\t}\n\n\treturn sr.newFileSinkFromPath(u.Path)\n}\n\nfunc (sr *sinkRegistry) newFileSinkFromPath(path string) (Sink, error) {\n\tswitch path {\n\tcase \"stdout\":\n\t\treturn nopCloserSink{os.Stdout}, nil\n\tcase \"stderr\":\n\t\treturn nopCloserSink{os.Stderr}, nil\n\t}\n\treturn sr.openFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o666)\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"New","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"ToLower","path":"../../../../usr/local/go/src/strings/strings.go"}],"callers":[{"symbol":"(*sinkRegistry).RegisterSink","path":"sink.go"},{"symbol":"loadLocation","path":"../../../../usr/local/go/src/time/zoneinfo_read.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Desugar","signature":"func (s *SugaredLogger) Desugar() *Logger","start_line":63,"end_line":67,"code":"func (s *SugaredLogger) Desugar() *Logger {\n\n\tbase := s.base.clone()\n\tbase.callerSkip -= 2\n\treturn base\n}\n","neighbors":[{"path":"sugar.go","start_line":43,"end_line":62,"code":"//\n//   - methods named after the log level for log.Print-style logging\n//   - methods ending in \"w\" for loosely-typed structured logging\n//   - methods ending in \"f\" for log.Printf-style logging\n//   - methods ending in \"ln\" for log.Println-style logging\n//\n// For example, the methods for InfoLevel are:\n//\n//\tInfo(...any)           Print-style logging\n//\tInfow(...any)          Structured logging (read as \"info with\")\n//\tInfof(string, ...any)  Printf-style logging\n//\tInfoln(...any)         Println-style logging\ntype SugaredLogger struct {\n\tbase *Logger\n}\n\n// Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring\n// is quite inexpensive, so it's reasonable for a single application to use\n// both Loggers and SugaredLoggers, converting between them on the boundaries\n// of performance-sensitive code."},{"path":"sugar.go","start_line":68,"end_line":87,"code":"\n// Named adds a sub-scope to the logger's name. See Logger.Named for details.\nfunc (s *SugaredLogger) Named(name string) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.Named(name)}\n}\n\n// WithOptions clones the current SugaredLogger, applies the supplied Options,\n// and returns the result. It's safe to use concurrently.\nfunc (s *SugaredLogger) WithOptions(opts ...Option) *SugaredLogger {\n\tbase := s.base.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(base)\n\t}\n\treturn \u0026SugaredLogger{base: base}\n}\n\n// With adds a variadic number of fields to the logging context. It accepts a\n// mix of strongly-typed Field objects and loosely-typed key-value pairs. When\n// processing pairs, the first element of the pair is used as the field key\n// and the second as the field value."}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Named","signature":"func (s *SugaredLogger) Named(name string) *SugaredLogger","start_line":70,"end_line":72,"code":"func (s *SugaredLogger) Named(name string) *SugaredLogger {\n\n\treturn \u0026SugaredLogger{base: s.base.Named(name)}\n}\n","neighbors":[{"path":"sugar.go","start_line":50,"end_line":69,"code":"//\n//\tInfo(...any)           Print-style logging\n//\tInfow(...any)          Structured logging (read as \"info with\")\n//\tInfof(string, ...any)  Printf-style logging\n//\tInfoln(...any)         Println-style logging\ntype SugaredLogger struct {\n\tbase *Logger\n}\n\n// Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring\n// is quite inexpensive, so it's reasonable for a single application to use\n// both Loggers and SugaredLoggers, converting between them on the boundaries\n// of performance-sensitive code.\nfunc (s *SugaredLogger) Desugar() *Logger {\n\tbase := s.base.clone()\n\tbase.callerSkip -= 2\n\treturn base\n}\n\n// Named adds a sub-scope to the logger's name. See Logger.Named for details."},{"path":"sugar.go","start_line":73,"end_line":92,"code":"\n// WithOptions clones the current SugaredLogger, applies the supplied Options,\n// and returns the result. It's safe to use concurrently.\nfunc (s *SugaredLogger) WithOptions(opts ...Option) *SugaredLogger {\n\tbase := s.base.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(base)\n\t}\n\treturn \u0026SugaredLogger{base: base}\n}\n\n// With adds a variadic number of fields to the logging context. It accepts a\n// mix of strongly-typed Field objects and loosely-typed key-value pairs. When\n// processing pairs, the first element of the pair is used as the field key\n// and the second as the field value.\n//\n// For example,\n//\n//\t sugaredLogger.With(\n//\t   \"hello\", \"world\","}],"selection":{"visibility":"exported","reason":"public_api","score":0.75},"call_graph":{"callees":[{"symbol":"(*Logger).Named","path":"logger.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).WithOptions","signature":"func (s *SugaredLogger) WithOptions(opts ...Option) *SugaredLogger","start_line":76,"end_line":82,"code":"func (s *SugaredLogger) WithOptions(opts ...Option) *SugaredLogger {\n\n\tbase := s.base.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(base)\n\t}\n\treturn \u0026SugaredLogger{base: base}\n}\n","neighbors":[{"path":"sugar.go","start_line":56,"end_line":75,"code":"\tbase *Logger\n}\n\n// Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring\n// is quite inexpensive, so it's reasonable for a single application to use\n// both Loggers and SugaredLoggers, converting between them on the boundaries\n// of performance-sensitive code.\nfunc (s *SugaredLogger) Desugar() *Logger {\n\tbase := s.base.clone()\n\tbase.callerSkip -= 2\n\treturn base\n}\n\n// Named adds a sub-scope to the logger's name. See Logger.Named for details.\nfunc (s *SugaredLogger) Named(name string) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.Named(name)}\n}\n\n// WithOptions clones the current SugaredLogger, applies the supplied Options,\n// and returns the result. It's safe to use concurrently."},{"path":"sugar.go","start_line":83,"end_line":102,"code":"\n// With adds a variadic number of fields to the logging context. It accepts a\n// mix of strongly-typed Field objects and loosely-typed key-value pairs. When\n// processing pairs, the first element of the pair is used as the field key\n// and the second as the field value.\n//\n// For example,\n//\n//\t sugaredLogger.With(\n//\t   \"hello\", \"world\",\n//\t   \"failure\", errors.New(\"oh no\"),\n//\t   Stack(),\n//\t   \"count\", 42,\n//\t   \"user\", User{Name: \"alice\"},\n//\t)\n//\n// is the equivalent of\n//\n//\tunsugared.With(\n//\t  String(\"hello\", \"world\"),"}],"selection":{"visibility":"exported","reason":"public_api","score":0.88},"call_graph":{"callees":[{"symbol":"(*Logger).clone","path":"logger.go"},{"symbol":"(optionFunc).apply","path":"options.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).With","signature":"func (s *SugaredLogger) With(args ...interface{}) *SugaredLogger","start_line":114,"end_line":116,"code":"func (s *SugaredLogger) With(args ...interface{\n}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.With(s.sweetenFields(args)...)}\n}\n","neighbors":[{"path":"sugar.go","start_line":94,"end_line":113,"code":"//\t   Stack(),\n//\t   \"count\", 42,\n//\t   \"user\", User{Name: \"alice\"},\n//\t)\n//\n// is the equivalent of\n//\n//\tunsugared.With(\n//\t  String(\"hello\", \"world\"),\n//\t  String(\"failure\", \"oh no\"),\n//\t  Stack(),\n//\t  Int(\"count\", 42),\n//\t  Object(\"user\", User{Name: \"alice\"}),\n//\t)\n//\n// Note that the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics. In production, the logger is more\n// forgiving: a separate error is logged, but the key-value pair is skipped\n// and execution continues. Passing an orphaned key triggers similar behavior:\n// panics in development and errors in production."},{"path":"sugar.go","start_line":117,"end_line":136,"code":"\n// WithLazy adds a variadic number of fields to the logging context lazily.\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// Similar to [With], fields added to the child don't affect the parent,\n// and vice versa. Also, the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics, while in production it logs an error and skips the pair.\n// Passing an orphaned key has the same behavior.\nfunc (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {"}],"selection":{"visibility":"exported","reason":"public_api","score":0.79},"call_graph":{"callees":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).WithLazy","signature":"func (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger","start_line":129,"end_line":131,"code":"func (s *SugaredLogger) WithLazy(args ...interface{\n}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n","neighbors":[{"path":"sugar.go","start_line":109,"end_line":128,"code":"// Note that the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics. In production, the logger is more\n// forgiving: a separate error is logged, but the key-value pair is skipped\n// and execution continues. Passing an orphaned key triggers similar behavior:\n// panics in development and errors in production.\nfunc (s *SugaredLogger) With(args ...interface{}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.With(s.sweetenFields(args)...)}\n}\n\n// WithLazy adds a variadic number of fields to the logging context lazily.\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// Similar to [With], fields added to the child don't affect the parent,\n// and vice versa. Also, the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics, while in production it logs an error and skips the pair.\n// Passing an orphaned key has the same behavior."},{"path":"sugar.go","start_line":132,"end_line":151,"code":"\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(s.base.core)\n}\n\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.75},"call_graph":{"callees":[{"symbol":"(*Logger).WithLazy","path":"logger.go"},{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Level","signature":"func (s *SugaredLogger) Level() zapcore.Level","start_line":136,"end_line":138,"code":"func (s *SugaredLogger) Level() zapcore.Level {\n\n\treturn zapcore.LevelOf(s.base.core)\n}\n","neighbors":[{"path":"sugar.go","start_line":116,"end_line":135,"code":"}\n\n// WithLazy adds a variadic number of fields to the logging context lazily.\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// Similar to [With], fields added to the child don't affect the parent,\n// and vice versa. Also, the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics, while in production it logs an error and skips the pair.\n// Passing an orphaned key has the same behavior.\nfunc (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel]."},{"path":"sugar.go","start_line":139,"end_line":158,"code":"\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Log","signature":"func (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{})","start_line":142,"end_line":144,"code":"func (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{\n}) {\n\ts.log(lvl, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":122,"end_line":141,"code":"// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// Similar to [With], fields added to the child don't affect the parent,\n// and vice versa. Also, the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics, while in production it logs an error and skips the pair.\n// Passing an orphaned key has the same behavior.\nfunc (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(s.base.core)\n}\n\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":145,"end_line":164,"code":"\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Debug","signature":"func (s *SugaredLogger) Debug(args ...interface{})","start_line":148,"end_line":150,"code":"func (s *SugaredLogger) Debug(args ...interface{\n}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":128,"end_line":147,"code":"// Passing an orphaned key has the same behavior.\nfunc (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger {\n\treturn \u0026SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(s.base.core)\n}\n\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":151,"end_line":170,"code":"\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Info","signature":"func (s *SugaredLogger) Info(args ...interface{})","start_line":154,"end_line":156,"code":"func (s *SugaredLogger) Info(args ...interface{\n}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":134,"end_line":153,"code":"//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(s.base.core)\n}\n\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":157,"end_line":176,"code":"\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Info","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Warn","signature":"func (s *SugaredLogger) Warn(args ...interface{})","start_line":160,"end_line":162,"code":"func (s *SugaredLogger) Warn(args ...interface{\n}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":140,"end_line":159,"code":"// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":163,"end_line":182,"code":"\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Warning","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Error","signature":"func (s *SugaredLogger) Error(args ...interface{})","start_line":166,"end_line":168,"code":"func (s *SugaredLogger) Error(args ...interface{\n}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":146,"end_line":165,"code":"// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":169,"end_line":188,"code":"\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Error","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).DPanic","signature":"func (s *SugaredLogger) DPanic(args ...interface{})","start_line":173,"end_line":175,"code":"func (s *SugaredLogger) DPanic(args ...interface{\n}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":153,"end_line":172,"code":"// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":176,"end_line":195,"code":"\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Panic","signature":"func (s *SugaredLogger) Panic(args ...interface{})","start_line":179,"end_line":181,"code":"func (s *SugaredLogger) Panic(args ...interface{\n}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":159,"end_line":178,"code":"// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":182,"end_line":201,"code":"\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Fatal","signature":"func (s *SugaredLogger) Fatal(args ...interface{})","start_line":185,"end_line":187,"code":"func (s *SugaredLogger) Fatal(args ...interface{\n}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":165,"end_line":184,"code":"// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string."},{"path":"sugar.go","start_line":188,"end_line":207,"code":"\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Logf","signature":"func (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{})","start_line":191,"end_line":193,"code":"func (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{\n}) {\n\ts.log(lvl, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":171,"end_line":190,"code":"// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level."},{"path":"sugar.go","start_line":194,"end_line":213,"code":"\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Debugf","signature":"func (s *SugaredLogger) Debugf(template string, args ...interface{})","start_line":197,"end_line":199,"code":"func (s *SugaredLogger) Debugf(template string, args ...interface{\n}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":177,"end_line":196,"code":"// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel]."},{"path":"sugar.go","start_line":200,"end_line":219,"code":"\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*http2Framer).ReadFrame","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2Framer).logWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*transportRequest).logf","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"readMetaFrame$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Infof","signature":"func (s *SugaredLogger) Infof(template string, args ...interface{})","start_line":203,"end_line":205,"code":"func (s *SugaredLogger) Infof(template string, args ...interface{\n}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":183,"end_line":202,"code":"// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel]."},{"path":"sugar.go","start_line":206,"end_line":225,"code":"\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Infof","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*http2Framer).ReadFrame","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2Framer).logWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*transportRequest).logf","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"readMetaFrame$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Warnf","signature":"func (s *SugaredLogger) Warnf(template string, args ...interface{})","start_line":209,"end_line":211,"code":"func (s *SugaredLogger) Warnf(template string, args ...interface{\n}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":189,"end_line":208,"code":"// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel]."},{"path":"sugar.go","start_line":212,"end_line":231,"code":"\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Warningf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*http2Framer).ReadFrame","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2Framer).logWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*transportRequest).logf","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"readMetaFrame$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Errorf","signature":"func (s *SugaredLogger) Errorf(template string, args ...interface{})","start_line":215,"end_line":217,"code":"func (s *SugaredLogger) Errorf(template string, args ...interface{\n}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":195,"end_line":214,"code":"// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel]."},{"path":"sugar.go","start_line":218,"end_line":237,"code":"\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.69},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*Logger).Errorf","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).DPanicf","signature":"func (s *SugaredLogger) DPanicf(template string, args ...interface{})","start_line":222,"end_line":224,"code":"func (s *SugaredLogger) DPanicf(template string, args ...interface{\n}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":202,"end_line":221,"code":"// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)"},{"path":"sugar.go","start_line":225,"end_line":244,"code":"\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Panicf","signature":"func (s *SugaredLogger) Panicf(template string, args ...interface{})","start_line":228,"end_line":230,"code":"func (s *SugaredLogger) Panicf(template string, args ...interface{\n}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":208,"end_line":227,"code":"// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics."},{"path":"sugar.go","start_line":231,"end_line":250,"code":"\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Fatalf","signature":"func (s *SugaredLogger) Fatalf(template string, args ...interface{})","start_line":234,"end_line":236,"code":"func (s *SugaredLogger) Fatalf(template string, args ...interface{\n}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":214,"end_line":233,"code":"// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit."},{"path":"sugar.go","start_line":237,"end_line":256,"code":"\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":[{"symbol":"(*http2Framer).ReadFrame","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2Framer).logWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*transportRequest).logf","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"readMetaFrame$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Logw","signature":"func (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{})","start_line":240,"end_line":242,"code":"func (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{\n}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":220,"end_line":239,"code":"// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With."},{"path":"sugar.go","start_line":243,"end_line":262,"code":"\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Debugw","signature":"func (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{})","start_line":250,"end_line":252,"code":"func (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":230,"end_line":249,"code":"}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)"},{"path":"sugar.go","start_line":253,"end_line":272,"code":"\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Infow","signature":"func (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{})","start_line":256,"end_line":258,"code":"func (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{\n}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":236,"end_line":255,"code":"}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With."},{"path":"sugar.go","start_line":259,"end_line":278,"code":"\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Warnw","signature":"func (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{})","start_line":262,"end_line":264,"code":"func (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":242,"end_line":261,"code":"}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With."},{"path":"sugar.go","start_line":265,"end_line":284,"code":"\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Errorw","signature":"func (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{})","start_line":268,"end_line":270,"code":"func (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":248,"end_line":267,"code":"//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With."},{"path":"sugar.go","start_line":271,"end_line":290,"code":"\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).DPanicw","signature":"func (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{})","start_line":275,"end_line":277,"code":"func (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":255,"end_line":274,"code":"// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With."},{"path":"sugar.go","start_line":278,"end_line":297,"code":"\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Panicw","signature":"func (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{})","start_line":281,"end_line":283,"code":"func (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":261,"end_line":280,"code":"// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With."},{"path":"sugar.go","start_line":284,"end_line":303,"code":"\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Fatalw","signature":"func (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{})","start_line":287,"end_line":289,"code":"func (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{\n}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n","neighbors":[{"path":"sugar.go","start_line":267,"end_line":286,"code":"// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With."},{"path":"sugar.go","start_line":290,"end_line":309,"code":"\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Logln","signature":"func (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{})","start_line":293,"end_line":295,"code":"func (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{\n}) {\n\ts.logln(lvl, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":273,"end_line":292,"code":"// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":296,"end_line":315,"code":"\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Debugln","signature":"func (s *SugaredLogger) Debugln(args ...interface{})","start_line":299,"end_line":301,"code":"func (s *SugaredLogger) Debugln(args ...interface{\n}) {\n\ts.logln(DebugLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":279,"end_line":298,"code":"// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":302,"end_line":321,"code":"\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel]."}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Infoln","signature":"func (s *SugaredLogger) Infoln(args ...interface{})","start_line":305,"end_line":307,"code":"func (s *SugaredLogger) Infoln(args ...interface{\n}) {\n\ts.logln(InfoLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":285,"end_line":304,"code":"// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":308,"end_line":327,"code":"\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Warnln","signature":"func (s *SugaredLogger) Warnln(args ...interface{})","start_line":311,"end_line":313,"code":"func (s *SugaredLogger) Warnln(args ...interface{\n}) {\n\ts.logln(WarnLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":291,"end_line":310,"code":"// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":314,"end_line":333,"code":"\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Errorln","signature":"func (s *SugaredLogger) Errorln(args ...interface{})","start_line":317,"end_line":319,"code":"func (s *SugaredLogger) Errorln(args ...interface{\n}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":297,"end_line":316,"code":"// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":320,"end_line":339,"code":"\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).DPanicln","signature":"func (s *SugaredLogger) DPanicln(args ...interface{})","start_line":324,"end_line":326,"code":"func (s *SugaredLogger) DPanicln(args ...interface{\n}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":304,"end_line":323,"code":"// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":327,"end_line":346,"code":"\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n\n// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Panicln","signature":"func (s *SugaredLogger) Panicln(args ...interface{})","start_line":330,"end_line":332,"code":"func (s *SugaredLogger) Panicln(args ...interface{\n}) {\n\ts.logln(PanicLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":310,"end_line":329,"code":"// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":333,"end_line":352,"code":"\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n\n// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {\n\t// If logging at this level is completely disabled, skip the overhead of\n\t// string formatting.\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Fatalln","signature":"func (s *SugaredLogger) Fatalln(args ...interface{})","start_line":336,"end_line":338,"code":"func (s *SugaredLogger) Fatalln(args ...interface{\n}) {\n\ts.logln(FatalLevel, args, nil)\n}\n","neighbors":[{"path":"sugar.go","start_line":316,"end_line":335,"code":"// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments."},{"path":"sugar.go","start_line":339,"end_line":358,"code":"\n// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {\n\t// If logging at this level is completely disabled, skip the overhead of\n\t// string formatting.\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).Sync","signature":"func (s *SugaredLogger) Sync() error","start_line":341,"end_line":343,"code":"func (s *SugaredLogger) Sync() error {\n\n\treturn s.base.Sync()\n}\n","neighbors":[{"path":"sugar.go","start_line":321,"end_line":340,"code":"// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n\n// Sync flushes any buffered log entries."},{"path":"sugar.go","start_line":344,"end_line":363,"code":"\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {\n\t// If logging at this level is completely disabled, skip the overhead of\n\t// string formatting.\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// logln message with Sprintln\nfunc (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{}, context []interface{}) {\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.66},"call_graph":{"callees":[{"symbol":"(*Logger).Sync","path":"logger.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).log","signature":"func (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{})","start_line":346,"end_line":357,"code":"func (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{\n}, context []interface{}) {\n\t\n\t\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n","neighbors":[{"path":"sugar.go","start_line":326,"end_line":345,"code":"}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n\n// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither."},{"path":"sugar.go","start_line":358,"end_line":377,"code":"\n// logln message with Sprintln\nfunc (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{}, context []interface{}) {\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessageln(fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// getMessage format with Sprint, Sprintf, or neither.\nfunc getMessage(template string, fmtArgs []interface{}) string {\n\tif len(fmtArgs) == 0 {\n\t\treturn template\n\t}\n\n\tif template != \"\" {"}],"selection":{"visibility":"unexported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).Check","path":"logger.go"},{"symbol":"(*Logger).Core","path":"logger.go"},{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"getMessage","path":"sugar.go"}],"callers":[{"symbol":"(*SugaredLogger).DPanic","path":"sugar.go"},{"symbol":"(*SugaredLogger).DPanicf","path":"sugar.go"},{"symbol":"(*SugaredLogger).DPanicw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Debug","path":"sugar.go"},{"symbol":"(*SugaredLogger).Debugf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Debugw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Error","path":"sugar.go"},{"symbol":"(*SugaredLogger).Errorf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Errorw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatal","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatalf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatalw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Info","path":"sugar.go"},{"symbol":"(*SugaredLogger).Infof","path":"sugar.go"},{"symbol":"(*SugaredLogger).Infow","path":"sugar.go"},{"symbol":"(*SugaredLogger).Log","path":"sugar.go"},{"symbol":"(*SugaredLogger).Logf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Logw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Panic","path":"sugar.go"},{"symbol":"(*SugaredLogger).Panicf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Panicw","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warn","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warnf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warnw","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).logln","signature":"func (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{}, context []interface{})","start_line":360,"end_line":369,"code":"func (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{\n}, context []interface{}) {\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessageln(fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n","neighbors":[{"path":"sugar.go","start_line":340,"end_line":359,"code":"// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {\n\t// If logging at this level is completely disabled, skip the overhead of\n\t// string formatting.\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// logln message with Sprintln"},{"path":"sugar.go","start_line":370,"end_line":389,"code":"\n// getMessage format with Sprint, Sprintf, or neither.\nfunc getMessage(template string, fmtArgs []interface{}) string {\n\tif len(fmtArgs) == 0 {\n\t\treturn template\n\t}\n\n\tif template != \"\" {\n\t\treturn fmt.Sprintf(template, fmtArgs...)\n\t}\n\n\tif len(fmtArgs) == 1 {\n\t\tif str, ok := fmtArgs[0].(string); ok {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn fmt.Sprint(fmtArgs...)\n}\n\n// getMessageln format with Sprintln."}],"selection":{"visibility":"unexported","reason":"other","score":0.53},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).Check","path":"logger.go"},{"symbol":"(*Logger).Core","path":"logger.go"},{"symbol":"(*SugaredLogger).sweetenFields","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"getMessageln","path":"sugar.go"}],"callers":[{"symbol":"(*SugaredLogger).DPanicln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Debugln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Errorln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatalln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Infoln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Logln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Panicln","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warnln","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"getMessage","signature":"func getMessage(template string, fmtArgs []interface{}) string","start_line":372,"end_line":387,"code":"func getMessage(template string, fmtArgs []interface{\n}) string {\n\tif len(fmtArgs) == 0 {\n\t\treturn template\n\t}\n\n\tif template != \"\" {\n\t\treturn fmt.Sprintf(template, fmtArgs...)\n\t}\n\n\tif len(fmtArgs) == 1 {\n\t\tif str, ok := fmtArgs[0].(string); ok {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn fmt.Sprint(fmtArgs...)\n}\n","neighbors":[{"path":"sugar.go","start_line":352,"end_line":371,"code":"\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// logln message with Sprintln\nfunc (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{}, context []interface{}) {\n\tif lvl \u003c DPanicLevel \u0026\u0026 !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessageln(fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// getMessage format with Sprint, Sprintf, or neither."},{"path":"sugar.go","start_line":388,"end_line":407,"code":"\n// getMessageln format with Sprintln.\nfunc getMessageln(fmtArgs []interface{}) string {\n\tmsg := fmt.Sprintln(fmtArgs...)\n\treturn msg[:len(msg)-1]\n}\n\nfunc (s *SugaredLogger) sweetenFields(args []interface{}) []Field {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\t// Allocate enough space for the worst case; if users pass only structured\n\t\t// fields, we shouldn't penalize them with extra allocations.\n\t\tfields    = make([]Field, 0, len(args))\n\t\tinvalid   invalidPairs\n\t\tseenError bool\n\t)\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"Sprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*SugaredLogger).log","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"getMessageln","signature":"func getMessageln(fmtArgs []interface{}) string","start_line":390,"end_line":393,"code":"func getMessageln(fmtArgs []interface{\n}) string {\n\tmsg := fmt.Sprintln(fmtArgs...)\n\treturn msg[:len(msg)-1]\n}\n","neighbors":[{"path":"sugar.go","start_line":370,"end_line":389,"code":"\n// getMessage format with Sprint, Sprintf, or neither.\nfunc getMessage(template string, fmtArgs []interface{}) string {\n\tif len(fmtArgs) == 0 {\n\t\treturn template\n\t}\n\n\tif template != \"\" {\n\t\treturn fmt.Sprintf(template, fmtArgs...)\n\t}\n\n\tif len(fmtArgs) == 1 {\n\t\tif str, ok := fmtArgs[0].(string); ok {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn fmt.Sprint(fmtArgs...)\n}\n\n// getMessageln format with Sprintln."},{"path":"sugar.go","start_line":394,"end_line":413,"code":"\nfunc (s *SugaredLogger) sweetenFields(args []interface{}) []Field {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\t// Allocate enough space for the worst case; if users pass only structured\n\t\t// fields, we shouldn't penalize them with extra allocations.\n\t\tfields    = make([]Field, 0, len(args))\n\t\tinvalid   invalidPairs\n\t\tseenError bool\n\t)\n\n\tfor i := 0; i \u003c len(args); {\n\t\t// This is a strongly-typed field. Consume it and move on.\n\t\tif f, ok := args[i].(Field); ok {\n\t\t\tfields = append(fields, f)\n\t\t\ti++\n\t\t\tcontinue"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"Sprintln","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(*SugaredLogger).sweetenFields","signature":"func (s *SugaredLogger) sweetenFields(args []interface{}) []Field","start_line":395,"end_line":454,"code":"func (s *SugaredLogger) sweetenFields(args []interface{\n}) []Field {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\t\n\t\t\n\t\tfields    = make([]Field, 0, len(args))\n\t\tinvalid   invalidPairs\n\t\tseenError bool\n\t)\n\n\tfor i := 0; i \u003c len(args); {\n\t\t\n\t\tif f, ok := args[i].(Field); ok {\n\t\t\tfields = append(fields, f)\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\t\n\t\tif err, ok := args[i].(error); ok {\n\t\t\tif !seenError {\n\t\t\t\tseenError = true\n\t\t\t\tfields = append(fields, Error(err))\n\t\t\t} else {\n\t\t\t\ts.base.Error(_multipleErrMsg, Error(err))\n\t\t\t}\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\t\n\t\tif i == len(args)-1 {\n\t\t\ts.base.Error(_oddNumberErrMsg, Any(\"ignored\", args[i]))\n\t\t\tbreak\n\t\t}\n\n\t\t\n\t\t\n\t\tkey, val := args[i], args[i+1]\n\t\tif keyStr, ok := key.(string); !ok {\n\t\t\t\n\t\t\tif cap(invalid) == 0 {\n\t\t\t\tinvalid = make(invalidPairs, 0, len(args)/2)\n\t\t\t}\n\t\t\tinvalid = append(invalid, invalidPair{i, key, val})\n\t\t} else {\n\t\t\tfields = append(fields, Any(keyStr, val))\n\t\t}\n\t\ti += 2\n\t}\n\n\t\n\tif len(invalid) \u003e 0 {\n\t\ts.base.Error(_nonStringKeyErrMsg, Array(\"invalid\", invalid))\n\t}\n\treturn fields\n}\n","neighbors":[{"path":"sugar.go","start_line":375,"end_line":394,"code":"\t}\n\n\tif template != \"\" {\n\t\treturn fmt.Sprintf(template, fmtArgs...)\n\t}\n\n\tif len(fmtArgs) == 1 {\n\t\tif str, ok := fmtArgs[0].(string); ok {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn fmt.Sprint(fmtArgs...)\n}\n\n// getMessageln format with Sprintln.\nfunc getMessageln(fmtArgs []interface{}) string {\n\tmsg := fmt.Sprintln(fmtArgs...)\n\treturn msg[:len(msg)-1]\n}\n"},{"path":"sugar.go","start_line":455,"end_line":474,"code":"\ntype invalidPair struct {\n\tposition   int\n\tkey, value interface{}\n}\n\nfunc (p invalidPair) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddInt64(\"position\", int64(p.position))\n\tAny(\"key\", p.key).AddTo(enc)\n\tAny(\"value\", p.value).AddTo(enc)\n\treturn nil\n}\n\ntype invalidPairs []invalidPair\n\nfunc (ps invalidPairs) MarshalLogArray(enc zapcore.ArrayEncoder) error {\n\tvar err error\n\tfor i := range ps {\n\t\terr = multierr.Append(err, enc.AppendObject(ps[i]))\n\t}"}],"selection":{"visibility":"unexported","reason":"other","score":0.52},"call_graph":{"callees":[{"symbol":"(*Logger).Error","path":"logger.go"},{"symbol":"Any","path":"field.go"},{"symbol":"Array","path":"array.go"},{"symbol":"Error","path":"error.go"}],"callers":[{"symbol":"(*SugaredLogger).With","path":"sugar.go"},{"symbol":"(*SugaredLogger).WithLazy","path":"sugar.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(invalidPair).MarshalLogObject","signature":"func (p invalidPair) MarshalLogObject(enc zapcore.ObjectEncoder) error","start_line":461,"end_line":466,"code":"func (p invalidPair) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\n\tenc.AddInt64(\"position\", int64(p.position))\n\tAny(\"key\", p.key).AddTo(enc)\n\tAny(\"value\", p.value).AddTo(enc)\n\treturn nil\n}\n","neighbors":[{"path":"sugar.go","start_line":441,"end_line":460,"code":"\t\t\t}\n\t\t\tinvalid = append(invalid, invalidPair{i, key, val})\n\t\t} else {\n\t\t\tfields = append(fields, Any(keyStr, val))\n\t\t}\n\t\ti += 2\n\t}\n\n\t// If we encountered any invalid key-value pairs, log an error.\n\tif len(invalid) \u003e 0 {\n\t\ts.base.Error(_nonStringKeyErrMsg, Array(\"invalid\", invalid))\n\t}\n\treturn fields\n}\n\ntype invalidPair struct {\n\tposition   int\n\tkey, value interface{}\n}\n"},{"path":"sugar.go","start_line":467,"end_line":477,"code":"\ntype invalidPairs []invalidPair\n\nfunc (ps invalidPairs) MarshalLogArray(enc zapcore.ArrayEncoder) error {\n\tvar err error\n\tfor i := range ps {\n\t\terr = multierr.Append(err, enc.AppendObject(ps[i]))\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"(*MapObjectEncoder).AddInt64","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"Any","path":"field.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*invalidPair).MarshalLogObject","path":"sugar.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"sugar.go","symbol":"(invalidPairs).MarshalLogArray","signature":"func (ps invalidPairs) MarshalLogArray(enc zapcore.ArrayEncoder) error","start_line":470,"end_line":476,"code":"func (ps invalidPairs) MarshalLogArray(enc zapcore.ArrayEncoder) error {\n\n\tvar err error\n\tfor i := range ps {\n\t\terr = multierr.Append(err, enc.AppendObject(ps[i]))\n\t}\n\treturn err\n}\n","neighbors":[{"path":"sugar.go","start_line":450,"end_line":469,"code":"\tif len(invalid) \u003e 0 {\n\t\ts.base.Error(_nonStringKeyErrMsg, Array(\"invalid\", invalid))\n\t}\n\treturn fields\n}\n\ntype invalidPair struct {\n\tposition   int\n\tkey, value interface{}\n}\n\nfunc (p invalidPair) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddInt64(\"position\", int64(p.position))\n\tAny(\"key\", p.key).AddTo(enc)\n\tAny(\"value\", p.value).AddTo(enc)\n\treturn nil\n}\n\ntype invalidPairs []invalidPair\n"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*invalidPairs).MarshalLogArray","path":"sugar.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"time.go","symbol":"timeToMillis","signature":"func timeToMillis(t time.Time) int64","start_line":25,"end_line":27,"code":"func timeToMillis(t time.Time) int64 {\n\n\treturn t.UnixNano() / int64(time.Millisecond)\n}\n","neighbors":[{"path":"time.go","start_line":5,"end_line":24,"code":"// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport \"time\"\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"writer.go","symbol":"Open","signature":"func Open(paths ...string) (zapcore.WriteSyncer, func(), error)","start_line":50,"end_line":58,"code":"func Open(paths ...string) (zapcore.WriteSyncer, func(), error) {\n\n\twriters, closeAll, err := open(paths)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\twriter := CombineWriteSyncers(writers...)\n\treturn writer, closeAll, nil\n}\n","neighbors":[{"path":"writer.go","start_line":30,"end_line":49,"code":")\n\n// Open is a high-level wrapper that takes a variadic number of URLs, opens or\n// creates each of the specified resources, and combines them into a locked\n// WriteSyncer. It also returns any error encountered and a function to close\n// any opened files.\n//\n// Passing no URLs returns a no-op WriteSyncer. Zap handles URLs without a\n// scheme and URLs with the \"file\" scheme. Third-party code may register\n// factories for other schemes using RegisterSink.\n//\n// URLs with the \"file\" scheme must use absolute paths on the local\n// filesystem. No user, password, port, fragments, or query parameters are\n// allowed, and the hostname must be empty or \"localhost\".\n//\n// Since it's common to write logs to the local filesystem, URLs without a\n// scheme (e.g., \"/var/log/foo.log\") are treated as local file paths. Without\n// a scheme, the special paths \"stdout\" and \"stderr\" are interpreted as\n// os.Stdout and os.Stderr. When specified without a scheme, relative file\n// paths also work."},{"path":"writer.go","start_line":59,"end_line":78,"code":"\nfunc open(paths []string) ([]zapcore.WriteSyncer, func(), error) {\n\twriters := make([]zapcore.WriteSyncer, 0, len(paths))\n\tclosers := make([]io.Closer, 0, len(paths))\n\tcloseAll := func() {\n\t\tfor _, c := range closers {\n\t\t\t_ = c.Close()\n\t\t}\n\t}\n\n\tvar openErr error\n\tfor _, path := range paths {\n\t\tsink, err := _sinkRegistry.newSink(path)\n\t\tif err != nil {\n\t\t\topenErr = multierr.Append(openErr, fmt.Errorf(\"open sink %q: %w\", path, err))\n\t\t\tcontinue\n\t\t}\n\t\twriters = append(writers, sink)\n\t\tclosers = append(closers, sink)\n\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"CombineWriteSyncers","path":"writer.go"},{"symbol":"open","path":"writer.go"}],"callers":[{"symbol":"(Config).openSinks","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"writer.go","symbol":"open","signature":"func open(paths []string) ([]zapcore.WriteSyncer, func(), error)","start_line":60,"end_line":85,"code":"func open(paths []string) ([]zapcore.WriteSyncer, func(), error) {\n\n\twriters := make([]zapcore.WriteSyncer, 0, len(paths))\n\tclosers := make([]io.Closer, 0, len(paths))\n\tcloseAll := func() {\n\t\tfor _, c := range closers {\n\t\t\t_ = c.Close()\n\t\t}\n\t}\n\n\tvar openErr error\n\tfor _, path := range paths {\n\t\tsink, err := _sinkRegistry.newSink(path)\n\t\tif err != nil {\n\t\t\topenErr = multierr.Append(openErr, fmt.Errorf(\"open sink %q: %w\", path, err))\n\t\t\tcontinue\n\t\t}\n\t\twriters = append(writers, sink)\n\t\tclosers = append(closers, sink)\n\t}\n\tif openErr != nil {\n\t\tcloseAll()\n\t\treturn nil, nil, openErr\n\t}\n\n\treturn writers, closeAll, nil\n}\n","neighbors":[{"path":"writer.go","start_line":40,"end_line":59,"code":"//\n// URLs with the \"file\" scheme must use absolute paths on the local\n// filesystem. No user, password, port, fragments, or query parameters are\n// allowed, and the hostname must be empty or \"localhost\".\n//\n// Since it's common to write logs to the local filesystem, URLs without a\n// scheme (e.g., \"/var/log/foo.log\") are treated as local file paths. Without\n// a scheme, the special paths \"stdout\" and \"stderr\" are interpreted as\n// os.Stdout and os.Stderr. When specified without a scheme, relative file\n// paths also work.\nfunc Open(paths ...string) (zapcore.WriteSyncer, func(), error) {\n\twriters, closeAll, err := open(paths)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\twriter := CombineWriteSyncers(writers...)\n\treturn writer, closeAll, nil\n}\n"},{"path":"writer.go","start_line":86,"end_line":99,"code":"\n// CombineWriteSyncers is a utility that combines multiple WriteSyncers into a\n// single, locked WriteSyncer. If no inputs are supplied, it returns a no-op\n// WriteSyncer.\n//\n// It's provided purely as a convenience; the result is no different from\n// using zapcore.NewMultiWriteSyncer and zapcore.Lock individually.\nfunc CombineWriteSyncers(writers ...zapcore.WriteSyncer) zapcore.WriteSyncer {\n\tif len(writers) == 0 {\n\t\treturn zapcore.AddSync(io.Discard)\n\t}\n\treturn zapcore.Lock(zapcore.NewMultiWriteSyncer(writers...))\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*sinkRegistry).newSink","path":"sink.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"open$1","path":"writer.go"}],"callers":[{"symbol":"Open","path":"writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"writer.go","symbol":"CombineWriteSyncers","signature":"func CombineWriteSyncers(writers ...zapcore.WriteSyncer) zapcore.WriteSyncer","start_line":93,"end_line":98,"code":"func CombineWriteSyncers(writers ...zapcore.WriteSyncer) zapcore.WriteSyncer {\n\n\tif len(writers) == 0 {\n\t\treturn zapcore.AddSync(io.Discard)\n\t}\n\treturn zapcore.Lock(zapcore.NewMultiWriteSyncer(writers...))\n}\n","neighbors":[{"path":"writer.go","start_line":73,"end_line":92,"code":"\t\t\topenErr = multierr.Append(openErr, fmt.Errorf(\"open sink %q: %w\", path, err))\n\t\t\tcontinue\n\t\t}\n\t\twriters = append(writers, sink)\n\t\tclosers = append(closers, sink)\n\t}\n\tif openErr != nil {\n\t\tcloseAll()\n\t\treturn nil, nil, openErr\n\t}\n\n\treturn writers, closeAll, nil\n}\n\n// CombineWriteSyncers is a utility that combines multiple WriteSyncers into a\n// single, locked WriteSyncer. If no inputs are supplied, it returns a no-op\n// WriteSyncer.\n//\n// It's provided purely as a convenience; the result is no different from\n// using zapcore.NewMultiWriteSyncer and zapcore.Lock individually."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"AddSync","path":"zapcore/write_syncer.go"},{"symbol":"Lock","path":"zapcore/write_syncer.go"},{"symbol":"NewMultiWriteSyncer","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"Open","path":"writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/buffered_write_syncer.go","symbol":"(*BufferedWriteSyncer).initialize","signature":"func (s *BufferedWriteSyncer) initialize()","start_line":112,"end_line":133,"code":"func (s *BufferedWriteSyncer) initialize() {\n\n\tsize := s.Size\n\tif size == 0 {\n\t\tsize = _defaultBufferSize\n\t}\n\n\tflushInterval := s.FlushInterval\n\tif flushInterval == 0 {\n\t\tflushInterval = _defaultFlushInterval\n\t}\n\n\tif s.Clock == nil {\n\t\ts.Clock = DefaultClock\n\t}\n\n\ts.ticker = s.Clock.NewTicker(flushInterval)\n\ts.writer = bufio.NewWriterSize(s.WS, size)\n\ts.stop = make(chan struct{})\n\ts.done = make(chan struct{})\n\ts.initialized = true\n\tgo s.flushLoop()\n}\n","neighbors":[{"path":"zapcore/buffered_write_syncer.go","start_line":92,"end_line":111,"code":"\t//\n\t// Defaults to 30 seconds if unspecified.\n\tFlushInterval time.Duration\n\n\t// Clock, if specified, provides control of the source of time for the\n\t// writer.\n\t//\n\t// Defaults to the system clock.\n\tClock Clock\n\n\t// unexported fields for state\n\tmu          sync.Mutex\n\tinitialized bool // whether initialize() has run\n\tstopped     bool // whether Stop() has run\n\twriter      *bufio.Writer\n\tticker      *time.Ticker\n\tstop        chan struct{} // closed when flushLoop should stop\n\tdone        chan struct{} // closed when flushLoop has stopped\n}\n"},{"path":"zapcore/buffered_write_syncer.go","start_line":134,"end_line":153,"code":"\n// Write writes log data into buffer syncer directly, multiple Write calls will be batched,\n// and log data will be flushed to disk when the buffer is full or periodically.\nfunc (s *BufferedWriteSyncer) Write(bs []byte) (int, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif !s.initialized {\n\t\ts.initialize()\n\t}\n\n\t// To avoid partial writes from being flushed, we manually flush the existing buffer if:\n\t// * The current write doesn't fit into the buffer fully, and\n\t// * The buffer is not empty (since bufio will not split large writes when the buffer is empty)\n\tif len(bs) \u003e s.writer.Available() \u0026\u0026 s.writer.Buffered() \u003e 0 {\n\t\tif err := s.writer.Flush(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).flushLoop","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*MockClock).NewTicker","path":"internal/ztest/clock.go"},{"symbol":"(systemClock).NewTicker","path":"zapcore/clock.go"},{"symbol":"NewWriterSize","path":"../../../../usr/local/go/src/bufio/bufio.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).Write","path":"zapcore/buffered_write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/buffered_write_syncer.go","symbol":"(*BufferedWriteSyncer).Write","signature":"func (s *BufferedWriteSyncer) Write(bs []byte) (int, error)","start_line":137,"end_line":155,"code":"func (s *BufferedWriteSyncer) Write(bs []byte) (int, error) {\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif !s.initialized {\n\t\ts.initialize()\n\t}\n\n\t\n\t\n\t\n\tif len(bs) \u003e s.writer.Available() \u0026\u0026 s.writer.Buffered() \u003e 0 {\n\t\tif err := s.writer.Flush(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn s.writer.Write(bs)\n}\n","neighbors":[{"path":"zapcore/buffered_write_syncer.go","start_line":117,"end_line":136,"code":"\n\tflushInterval := s.FlushInterval\n\tif flushInterval == 0 {\n\t\tflushInterval = _defaultFlushInterval\n\t}\n\n\tif s.Clock == nil {\n\t\ts.Clock = DefaultClock\n\t}\n\n\ts.ticker = s.Clock.NewTicker(flushInterval)\n\ts.writer = bufio.NewWriterSize(s.WS, size)\n\ts.stop = make(chan struct{})\n\ts.done = make(chan struct{})\n\ts.initialized = true\n\tgo s.flushLoop()\n}\n\n// Write writes log data into buffer syncer directly, multiple Write calls will be batched,\n// and log data will be flushed to disk when the buffer is full or periodically."},{"path":"zapcore/buffered_write_syncer.go","start_line":156,"end_line":175,"code":"\n// Sync flushes buffered log data into disk directly.\nfunc (s *BufferedWriteSyncer) Sync() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tvar err error\n\tif s.initialized {\n\t\terr = s.writer.Flush()\n\t}\n\n\treturn multierr.Append(err, s.WS.Sync())\n}\n\n// flushLoop flushes the buffer at the configured interval until Stop is\n// called.\nfunc (s *BufferedWriteSyncer) flushLoop() {\n\tdefer close(s.done)\n\n\tfor {"}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).initialize","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Writer).Available","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Buffered","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/buffered_write_syncer.go","symbol":"(*BufferedWriteSyncer).Sync","signature":"func (s *BufferedWriteSyncer) Sync() error","start_line":158,"end_line":168,"code":"func (s *BufferedWriteSyncer) Sync() error {\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tvar err error\n\tif s.initialized {\n\t\terr = s.writer.Flush()\n\t}\n\n\treturn multierr.Append(err, s.WS.Sync())\n}\n","neighbors":[{"path":"zapcore/buffered_write_syncer.go","start_line":138,"end_line":157,"code":"\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif !s.initialized {\n\t\ts.initialize()\n\t}\n\n\t// To avoid partial writes from being flushed, we manually flush the existing buffer if:\n\t// * The current write doesn't fit into the buffer fully, and\n\t// * The buffer is not empty (since bufio will not split large writes when the buffer is empty)\n\tif len(bs) \u003e s.writer.Available() \u0026\u0026 s.writer.Buffered() \u003e 0 {\n\t\tif err := s.writer.Flush(); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\treturn s.writer.Write(bs)\n}\n\n// Sync flushes buffered log data into disk directly."},{"path":"zapcore/buffered_write_syncer.go","start_line":169,"end_line":188,"code":"\n// flushLoop flushes the buffer at the configured interval until Stop is\n// called.\nfunc (s *BufferedWriteSyncer) flushLoop() {\n\tdefer close(s.done)\n\n\tfor {\n\t\tselect {\n\t\tcase \u003c-s.ticker.C:\n\t\t\t// we just simply ignore error here\n\t\t\t// because the underlying bufio writer stores any errors\n\t\t\t// and we return any error from Sync() as part of the close\n\t\t\t_ = s.Sync()\n\t\tcase \u003c-s.stop:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Stop closes the buffer, cleans up background goroutines, and flushes"}],"selection":{"visibility":"exported","reason":"core","score":0.76},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*File).Sync","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(writerWrapper).Sync","path":"zapcore/write_syncer.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).Stop","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*BufferedWriteSyncer).flushLoop","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/buffered_write_syncer.go","symbol":"(*BufferedWriteSyncer).flushLoop","signature":"func (s *BufferedWriteSyncer) flushLoop()","start_line":172,"end_line":186,"code":"func (s *BufferedWriteSyncer) flushLoop() {\n\n\tdefer close(s.done)\n\n\tfor {\n\t\tselect {\n\t\tcase \u003c-s.ticker.C:\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t_ = s.Sync()\n\t\tcase \u003c-s.stop:\n\t\t\treturn\n\t\t}\n\t}\n}\n","neighbors":[{"path":"zapcore/buffered_write_syncer.go","start_line":152,"end_line":171,"code":"\t}\n\n\treturn s.writer.Write(bs)\n}\n\n// Sync flushes buffered log data into disk directly.\nfunc (s *BufferedWriteSyncer) Sync() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tvar err error\n\tif s.initialized {\n\t\terr = s.writer.Flush()\n\t}\n\n\treturn multierr.Append(err, s.WS.Sync())\n}\n\n// flushLoop flushes the buffer at the configured interval until Stop is\n// called."},{"path":"zapcore/buffered_write_syncer.go","start_line":187,"end_line":206,"code":"\n// Stop closes the buffer, cleans up background goroutines, and flushes\n// remaining unwritten data.\nfunc (s *BufferedWriteSyncer) Stop() (err error) {\n\t// Critical section.\n\tstopped := func() bool {\n\t\ts.mu.Lock()\n\t\tdefer s.mu.Unlock()\n\n\t\tif !s.initialized {\n\t\t\treturn false\n\t\t}\n\n\t\tif s.stopped {\n\t\t\treturn false\n\t\t}\n\t\ts.stopped = true\n\n\t\ts.ticker.Stop()\n\t\tclose(s.stop) // tell flushLoop to stop"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).initialize","path":"zapcore/buffered_write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/buffered_write_syncer.go","symbol":"(*BufferedWriteSyncer).Stop","signature":"func (s *BufferedWriteSyncer) Stop() (err error)","start_line":190,"end_line":220,"code":"func (s *BufferedWriteSyncer) Stop() (err error) {\n\n\t\n\tstopped := func() bool {\n\t\ts.mu.Lock()\n\t\tdefer s.mu.Unlock()\n\n\t\tif !s.initialized {\n\t\t\treturn false\n\t\t}\n\n\t\tif s.stopped {\n\t\t\treturn false\n\t\t}\n\t\ts.stopped = true\n\n\t\ts.ticker.Stop()\n\t\tclose(s.stop) \n\t\treturn true\n\t}()\n\n\t\n\tif !stopped {\n\t\treturn\n\t}\n\n\t\n\t\n\t\u003c-s.done\n\n\treturn s.Sync()\n}\n","neighbors":[{"path":"zapcore/buffered_write_syncer.go","start_line":170,"end_line":189,"code":"// flushLoop flushes the buffer at the configured interval until Stop is\n// called.\nfunc (s *BufferedWriteSyncer) flushLoop() {\n\tdefer close(s.done)\n\n\tfor {\n\t\tselect {\n\t\tcase \u003c-s.ticker.C:\n\t\t\t// we just simply ignore error here\n\t\t\t// because the underlying bufio writer stores any errors\n\t\t\t// and we return any error from Sync() as part of the close\n\t\t\t_ = s.Sync()\n\t\tcase \u003c-s.stop:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Stop closes the buffer, cleans up background goroutines, and flushes\n// remaining unwritten data."}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"Stop$1","path":"zapcore/buffered_write_syncer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/clock.go","symbol":"(systemClock).Now","signature":"func (systemClock) Now() time.Time","start_line":42,"end_line":44,"code":"func (systemClock) Now() time.Time {\n\n\treturn time.Now()\n}\n","neighbors":[{"path":"zapcore/clock.go","start_line":22,"end_line":41,"code":"\nimport \"time\"\n\n// DefaultClock is the default clock used by Zap in operations that require\n// time. This clock uses the system clock for all operations.\nvar DefaultClock = systemClock{}\n\n// Clock is a source of time for logged entries.\ntype Clock interface {\n\t// Now returns the current local time.\n\tNow() time.Time\n\n\t// NewTicker returns *time.Ticker that holds a channel\n\t// that delivers \"ticks\" of a clock.\n\tNewTicker(time.Duration) *time.Ticker\n}\n\n// systemClock implements default Clock that uses system time.\ntype systemClock struct{}\n"},{"path":"zapcore/clock.go","start_line":45,"end_line":49,"code":"\nfunc (systemClock) NewTicker(duration time.Duration) *time.Ticker {\n\treturn time.NewTicker(duration)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.62},"call_graph":{"callees":[{"symbol":"Now","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*systemClock).Now","path":"zapcore/clock.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/clock.go","symbol":"(systemClock).NewTicker","signature":"func (systemClock) NewTicker(duration time.Duration) *time.Ticker","start_line":46,"end_line":48,"code":"func (systemClock) NewTicker(duration time.Duration) *time.Ticker {\n\n\treturn time.NewTicker(duration)\n}\n","neighbors":[{"path":"zapcore/clock.go","start_line":26,"end_line":45,"code":"// time. This clock uses the system clock for all operations.\nvar DefaultClock = systemClock{}\n\n// Clock is a source of time for logged entries.\ntype Clock interface {\n\t// Now returns the current local time.\n\tNow() time.Time\n\n\t// NewTicker returns *time.Ticker that holds a channel\n\t// that delivers \"ticks\" of a clock.\n\tNewTicker(time.Duration) *time.Ticker\n}\n\n// systemClock implements default Clock that uses system time.\ntype systemClock struct{}\n\nfunc (systemClock) Now() time.Time {\n\treturn time.Now()\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.76},"call_graph":{"callees":[{"symbol":"NewTicker","path":"../../../../usr/local/go/src/time/tick.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).initialize","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*systemClock).NewTicker","path":"zapcore/clock.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"getSliceEncoder","signature":"func getSliceEncoder() *sliceArrayEncoder","start_line":37,"end_line":39,"code":"func getSliceEncoder() *sliceArrayEncoder {\n\n\treturn _sliceEncoderPool.Get()\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":17,"end_line":36,"code":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zapcore\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/buffer\"\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/pool\"\n)\n\nvar _sliceEncoderPool = pool.New(func() *sliceArrayEncoder {\n\treturn \u0026sliceArrayEncoder{\n\t\telems: make([]interface{}, 0, 2),\n\t}\n})\n"},{"path":"zapcore/console_encoder.go","start_line":40,"end_line":59,"code":"\nfunc putSliceEncoder(e *sliceArrayEncoder) {\n\te.elems = e.elems[:0]\n\t_sliceEncoderPool.Put(e)\n}\n\ntype consoleEncoder struct {\n\t*jsonEncoder\n}\n\n// NewConsoleEncoder creates an encoder whose output is designed for human -\n// rather than machine - consumption. It serializes the core log entry data\n// (message, level, timestamp, etc.) in a plain-text format and leaves the\n// structured context as JSON.\n//\n// Note that although the console encoder doesn't use the keys specified in the\n// encoder configuration, it will omit any element whose key is set to the empty\n// string.\nfunc NewConsoleEncoder(cfg EncoderConfig) Encoder {\n\tif cfg.ConsoleSeparator == \"\" {"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.45},"call_graph":{"callees":[{"symbol":"(*Pool).Get[*go.uber.org/zap/zapcore.sliceArrayEncoder]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"putSliceEncoder","signature":"func putSliceEncoder(e *sliceArrayEncoder)","start_line":41,"end_line":44,"code":"func putSliceEncoder(e *sliceArrayEncoder) {\n\n\te.elems = e.elems[:0]\n\t_sliceEncoderPool.Put(e)\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":21,"end_line":40,"code":"package zapcore\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/buffer\"\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/pool\"\n)\n\nvar _sliceEncoderPool = pool.New(func() *sliceArrayEncoder {\n\treturn \u0026sliceArrayEncoder{\n\t\telems: make([]interface{}, 0, 2),\n\t}\n})\n\nfunc getSliceEncoder() *sliceArrayEncoder {\n\treturn _sliceEncoderPool.Get()\n}\n"},{"path":"zapcore/console_encoder.go","start_line":45,"end_line":64,"code":"\ntype consoleEncoder struct {\n\t*jsonEncoder\n}\n\n// NewConsoleEncoder creates an encoder whose output is designed for human -\n// rather than machine - consumption. It serializes the core log entry data\n// (message, level, timestamp, etc.) in a plain-text format and leaves the\n// structured context as JSON.\n//\n// Note that although the console encoder doesn't use the keys specified in the\n// encoder configuration, it will omit any element whose key is set to the empty\n// string.\nfunc NewConsoleEncoder(cfg EncoderConfig) Encoder {\n\tif cfg.ConsoleSeparator == \"\" {\n\t\t// Use a default delimiter of '\\t' for backwards compatibility\n\t\tcfg.ConsoleSeparator = \"\\t\"\n\t}\n\treturn consoleEncoder{newJSONEncoder(cfg, true)}\n}"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.45},"call_graph":{"callees":[{"symbol":"(*Pool).Put[*go.uber.org/zap/zapcore.sliceArrayEncoder]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"NewConsoleEncoder","signature":"func NewConsoleEncoder(cfg EncoderConfig) Encoder","start_line":58,"end_line":64,"code":"func NewConsoleEncoder(cfg EncoderConfig) Encoder {\n\n\tif cfg.ConsoleSeparator == \"\" {\n\t\t\n\t\tcfg.ConsoleSeparator = \"\\t\"\n\t}\n\treturn consoleEncoder{newJSONEncoder(cfg, true)}\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":38,"end_line":57,"code":"\treturn _sliceEncoderPool.Get()\n}\n\nfunc putSliceEncoder(e *sliceArrayEncoder) {\n\te.elems = e.elems[:0]\n\t_sliceEncoderPool.Put(e)\n}\n\ntype consoleEncoder struct {\n\t*jsonEncoder\n}\n\n// NewConsoleEncoder creates an encoder whose output is designed for human -\n// rather than machine - consumption. It serializes the core log entry data\n// (message, level, timestamp, etc.) in a plain-text format and leaves the\n// structured context as JSON.\n//\n// Note that although the console encoder doesn't use the keys specified in the\n// encoder configuration, it will omit any element whose key is set to the empty\n// string."},{"path":"zapcore/console_encoder.go","start_line":65,"end_line":84,"code":"\nfunc (c consoleEncoder) Clone() Encoder {\n\treturn consoleEncoder{c.jsonEncoder.Clone().(*jsonEncoder)}\n}\n\nfunc (c consoleEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tline := bufferpool.Get()\n\n\t// We don't want the entry's metadata to be quoted and escaped (if it's\n\t// encoded as strings), which means that we can't use the JSON encoder. The\n\t// simplest option is to use the memory encoder and fmt.Fprint.\n\t//\n\t// If this ever becomes a performance bottleneck, we can implement\n\t// ArrayEncoder for our plain-text format.\n\tarr := getSliceEncoder()\n\tif c.TimeKey != \"\" \u0026\u0026 c.EncodeTime != nil \u0026\u0026 !ent.Time.IsZero() {\n\t\tc.EncodeTime(ent.Time, arr)\n\t}\n\tif c.LevelKey != \"\" \u0026\u0026 c.EncodeLevel != nil {\n\t\tc.EncodeLevel(ent.Level, arr)"}],"selection":{"visibility":"exported","reason":"constructor","score":0.91},"call_graph":{"callees":[{"symbol":"newJSONEncoder","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"NewLogger","path":"zaptest/logger.go"},{"symbol":"init$1","path":"encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"(consoleEncoder).Clone","signature":"func (c consoleEncoder) Clone() Encoder","start_line":66,"end_line":68,"code":"func (c consoleEncoder) Clone() Encoder {\n\n\treturn consoleEncoder{c.jsonEncoder.Clone().(*jsonEncoder)}\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":46,"end_line":65,"code":"type consoleEncoder struct {\n\t*jsonEncoder\n}\n\n// NewConsoleEncoder creates an encoder whose output is designed for human -\n// rather than machine - consumption. It serializes the core log entry data\n// (message, level, timestamp, etc.) in a plain-text format and leaves the\n// structured context as JSON.\n//\n// Note that although the console encoder doesn't use the keys specified in the\n// encoder configuration, it will omit any element whose key is set to the empty\n// string.\nfunc NewConsoleEncoder(cfg EncoderConfig) Encoder {\n\tif cfg.ConsoleSeparator == \"\" {\n\t\t// Use a default delimiter of '\\t' for backwards compatibility\n\t\tcfg.ConsoleSeparator = \"\\t\"\n\t}\n\treturn consoleEncoder{newJSONEncoder(cfg, true)}\n}\n"},{"path":"zapcore/console_encoder.go","start_line":69,"end_line":88,"code":"\nfunc (c consoleEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tline := bufferpool.Get()\n\n\t// We don't want the entry's metadata to be quoted and escaped (if it's\n\t// encoded as strings), which means that we can't use the JSON encoder. The\n\t// simplest option is to use the memory encoder and fmt.Fprint.\n\t//\n\t// If this ever becomes a performance bottleneck, we can implement\n\t// ArrayEncoder for our plain-text format.\n\tarr := getSliceEncoder()\n\tif c.TimeKey != \"\" \u0026\u0026 c.EncodeTime != nil \u0026\u0026 !ent.Time.IsZero() {\n\t\tc.EncodeTime(ent.Time, arr)\n\t}\n\tif c.LevelKey != \"\" \u0026\u0026 c.EncodeLevel != nil {\n\t\tc.EncodeLevel(ent.Level, arr)\n\t}\n\tif ent.LoggerName != \"\" \u0026\u0026 c.NameKey != \"\" {\n\t\tnameEncoder := c.EncodeName\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).Clone","path":"zapcore/console_encoder.go"},{"symbol":"(*ioCore).clone","path":"zapcore/core.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"(consoleEncoder).EncodeEntry","signature":"func (c consoleEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error)","start_line":70,"end_line":130,"code":"func (c consoleEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\n\tline := bufferpool.Get()\n\n\t\n\t\n\t\n\t\n\t\n\t\n\tarr := getSliceEncoder()\n\tif c.TimeKey != \"\" \u0026\u0026 c.EncodeTime != nil \u0026\u0026 !ent.Time.IsZero() {\n\t\tc.EncodeTime(ent.Time, arr)\n\t}\n\tif c.LevelKey != \"\" \u0026\u0026 c.EncodeLevel != nil {\n\t\tc.EncodeLevel(ent.Level, arr)\n\t}\n\tif ent.LoggerName != \"\" \u0026\u0026 c.NameKey != \"\" {\n\t\tnameEncoder := c.EncodeName\n\n\t\tif nameEncoder == nil {\n\t\t\t\n\t\t\tnameEncoder = FullNameEncoder\n\t\t}\n\n\t\tnameEncoder(ent.LoggerName, arr)\n\t}\n\tif ent.Caller.Defined {\n\t\tif c.CallerKey != \"\" \u0026\u0026 c.EncodeCaller != nil {\n\t\t\tc.EncodeCaller(ent.Caller, arr)\n\t\t}\n\t\tif c.FunctionKey != \"\" {\n\t\t\tarr.AppendString(ent.Caller.Function)\n\t\t}\n\t}\n\tfor i := range arr.elems {\n\t\tif i \u003e 0 {\n\t\t\tline.AppendString(c.ConsoleSeparator)\n\t\t}\n\t\t_, _ = fmt.Fprint(line, arr.elems[i])\n\t}\n\tputSliceEncoder(arr)\n\n\t\n\tif c.MessageKey != \"\" {\n\t\tc.addSeparatorIfNecessary(line)\n\t\tline.AppendString(ent.Message)\n\t}\n\n\t\n\tc.writeContext(line, fields)\n\n\t\n\t\n\tif ent.Stack != \"\" \u0026\u0026 c.StacktraceKey != \"\" {\n\t\tline.AppendByte('\\n')\n\t\tline.AppendString(ent.Stack)\n\t}\n\n\tline.AppendString(c.LineEnding)\n\treturn line, nil\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":50,"end_line":69,"code":"// NewConsoleEncoder creates an encoder whose output is designed for human -\n// rather than machine - consumption. It serializes the core log entry data\n// (message, level, timestamp, etc.) in a plain-text format and leaves the\n// structured context as JSON.\n//\n// Note that although the console encoder doesn't use the keys specified in the\n// encoder configuration, it will omit any element whose key is set to the empty\n// string.\nfunc NewConsoleEncoder(cfg EncoderConfig) Encoder {\n\tif cfg.ConsoleSeparator == \"\" {\n\t\t// Use a default delimiter of '\\t' for backwards compatibility\n\t\tcfg.ConsoleSeparator = \"\\t\"\n\t}\n\treturn consoleEncoder{newJSONEncoder(cfg, true)}\n}\n\nfunc (c consoleEncoder) Clone() Encoder {\n\treturn consoleEncoder{c.jsonEncoder.Clone().(*jsonEncoder)}\n}\n"},{"path":"zapcore/console_encoder.go","start_line":131,"end_line":150,"code":"\nfunc (c consoleEncoder) writeContext(line *buffer.Buffer, extra []Field) {\n\tcontext := c.jsonEncoder.Clone().(*jsonEncoder)\n\tdefer func() {\n\t\t// putJSONEncoder assumes the buffer is still used, but we write out the buffer so\n\t\t// we can free it.\n\t\tcontext.buf.Free()\n\t\tputJSONEncoder(context)\n\t}()\n\n\taddFields(context, extra)\n\tcontext.closeOpenNamespaces()\n\tif context.buf.Len() == 0 {\n\t\treturn\n\t}\n\n\tc.addSeparatorIfNecessary(line)\n\tline.AppendByte('{')\n\tline.Write(context.buf.Bytes())\n\tline.AppendByte('}')"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"(Time).IsZero","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(consoleEncoder).addSeparatorIfNecessary","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"CapitalLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochMillisTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochNanosTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"FullCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"FullNameEncoder","path":"zapcore/encoder.go"},{"symbol":"ISO8601TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"},{"symbol":"RFC3339NanoTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"RFC3339TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"ShortCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"TimeEncoderOfLayout$1","path":"zapcore/encoder.go"},{"symbol":"getSliceEncoder","path":"zapcore/console_encoder.go"},{"symbol":"putSliceEncoder","path":"zapcore/console_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"(consoleEncoder).writeContext","signature":"func (c consoleEncoder) writeContext(line *buffer.Buffer, extra []Field)","start_line":132,"end_line":151,"code":"func (c consoleEncoder) writeContext(line *buffer.Buffer, extra []Field) {\n\n\tcontext := c.jsonEncoder.Clone().(*jsonEncoder)\n\tdefer func() {\n\t\t\n\t\t\n\t\tcontext.buf.Free()\n\t\tputJSONEncoder(context)\n\t}()\n\n\taddFields(context, extra)\n\tcontext.closeOpenNamespaces()\n\tif context.buf.Len() == 0 {\n\t\treturn\n\t}\n\n\tc.addSeparatorIfNecessary(line)\n\tline.AppendByte('{')\n\tline.Write(context.buf.Bytes())\n\tline.AppendByte('}')\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":112,"end_line":131,"code":"\t// Add the message itself.\n\tif c.MessageKey != \"\" {\n\t\tc.addSeparatorIfNecessary(line)\n\t\tline.AppendString(ent.Message)\n\t}\n\n\t// Add any structured context.\n\tc.writeContext(line, fields)\n\n\t// If there's no stacktrace key, honor that; this allows users to force\n\t// single-line output.\n\tif ent.Stack != \"\" \u0026\u0026 c.StacktraceKey != \"\" {\n\t\tline.AppendByte('\\n')\n\t\tline.AppendString(ent.Stack)\n\t}\n\n\tline.AppendString(c.LineEnding)\n\treturn line, nil\n}\n"},{"path":"zapcore/console_encoder.go","start_line":152,"end_line":158,"code":"\nfunc (c consoleEncoder) addSeparatorIfNecessary(line *buffer.Buffer) {\n\tif line.Len() \u003e 0 {\n\t\tline.AppendString(c.ConsoleSeparator)\n\t}\n}\n"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.55},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Write","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).addSeparatorIfNecessary","path":"zapcore/console_encoder.go"},{"symbol":"addFields","path":"zapcore/field.go"},{"symbol":"writeContext$1","path":"zapcore/console_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).writeContext","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/console_encoder.go","symbol":"(consoleEncoder).addSeparatorIfNecessary","signature":"func (c consoleEncoder) addSeparatorIfNecessary(line *buffer.Buffer)","start_line":153,"end_line":157,"code":"func (c consoleEncoder) addSeparatorIfNecessary(line *buffer.Buffer) {\n\n\tif line.Len() \u003e 0 {\n\t\tline.AppendString(c.ConsoleSeparator)\n\t}\n}\n","neighbors":[{"path":"zapcore/console_encoder.go","start_line":133,"end_line":152,"code":"\tcontext := c.jsonEncoder.Clone().(*jsonEncoder)\n\tdefer func() {\n\t\t// putJSONEncoder assumes the buffer is still used, but we write out the buffer so\n\t\t// we can free it.\n\t\tcontext.buf.Free()\n\t\tputJSONEncoder(context)\n\t}()\n\n\taddFields(context, extra)\n\tcontext.closeOpenNamespaces()\n\tif context.buf.Len() == 0 {\n\t\treturn\n\t}\n\n\tc.addSeparatorIfNecessary(line)\n\tline.AppendByte('{')\n\tline.Write(context.buf.Bytes())\n\tline.AppendByte('}')\n}\n"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*consoleEncoder).addSeparatorIfNecessary","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"NewNopCore","signature":"func NewNopCore() Core","start_line":50,"end_line":50,"code":"func NewNopCore() Core                                        {\n return nopCore{} }\n","neighbors":[{"path":"zapcore/core.go","start_line":30,"end_line":49,"code":"\t// Check determines whether the supplied Entry should be logged (using the\n\t// embedded LevelEnabler and possibly some extra logic). If the entry\n\t// should be logged, the Core adds itself to the CheckedEntry and returns\n\t// the result.\n\t//\n\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core."},{"path":"zapcore/core.go","start_line":51,"end_line":70,"code":"func (nopCore) Enabled(Level) bool                            { return false }\nfunc (n nopCore) With([]Field) Core                           { return n }\nfunc (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }\nfunc (nopCore) Write(Entry, []Field) error                    { return nil }\nfunc (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.81},"call_graph":{"callees":null,"callers":[{"symbol":"NewNop","path":"logger.go"},{"symbol":"NewTee","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(nopCore).Enabled","signature":"func (nopCore) Enabled(Level) bool","start_line":51,"end_line":51,"code":"func (nopCore) Enabled(Level) bool                            {\n return false }\n","neighbors":[{"path":"zapcore/core.go","start_line":31,"end_line":50,"code":"\t// embedded LevelEnabler and possibly some extra logic). If the entry\n\t// should be logged, the Core adds itself to the CheckedEntry and returns\n\t// the result.\n\t//\n\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }"},{"path":"zapcore/core.go","start_line":52,"end_line":71,"code":"func (n nopCore) With([]Field) Core                           { return n }\nfunc (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }\nfunc (nopCore) Write(Entry, []Field) error                    { return nil }\nfunc (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.73},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(nopCore).With","signature":"func (n nopCore) With([]Field) Core","start_line":52,"end_line":52,"code":"func (n nopCore) With([]Field) Core                           {\n return n }\n","neighbors":[{"path":"zapcore/core.go","start_line":32,"end_line":51,"code":"\t// should be logged, the Core adds itself to the CheckedEntry and returns\n\t// the result.\n\t//\n\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }\nfunc (nopCore) Enabled(Level) bool                            { return false }"},{"path":"zapcore/core.go","start_line":53,"end_line":72,"code":"func (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }\nfunc (nopCore) Write(Entry, []Field) error                    { return nil }\nfunc (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar ("}],"selection":{"visibility":"exported","reason":"public_api","score":0.84},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*nopCore).With","path":"zapcore/core.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(nopCore).Check","signature":"func (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry","start_line":53,"end_line":53,"code":"func (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry {\n return ce }\n","neighbors":[{"path":"zapcore/core.go","start_line":33,"end_line":52,"code":"\t// the result.\n\t//\n\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }\nfunc (nopCore) Enabled(Level) bool                            { return false }\nfunc (n nopCore) With([]Field) Core                           { return n }"},{"path":"zapcore/core.go","start_line":54,"end_line":73,"code":"func (nopCore) Write(Entry, []Field) error                    { return nil }\nfunc (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)"}],"selection":{"visibility":"exported","reason":"core","score":0.69},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*nopCore).Check","path":"zapcore/core.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(nopCore).Write","signature":"func (nopCore) Write(Entry, []Field) error","start_line":54,"end_line":54,"code":"func (nopCore) Write(Entry, []Field) error                    {\n return nil }\n","neighbors":[{"path":"zapcore/core.go","start_line":34,"end_line":53,"code":"\t//\n\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }\nfunc (nopCore) Enabled(Level) bool                            { return false }\nfunc (n nopCore) With([]Field) Core                           { return n }\nfunc (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }"},{"path":"zapcore/core.go","start_line":55,"end_line":74,"code":"func (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)"}],"selection":{"visibility":"exported","reason":"core","score":0.75},"call_graph":{"callees":null,"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(*nopCore).Write","path":"zapcore/core.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(nopCore).Sync","signature":"func (nopCore) Sync() error","start_line":55,"end_line":55,"code":"func (nopCore) Sync() error                                   {\n return nil }\n","neighbors":[{"path":"zapcore/core.go","start_line":35,"end_line":54,"code":"\t// Callers must use Check before calling Write.\n\tCheck(Entry, *CheckedEntry) *CheckedEntry\n\t// Write serializes the Entry and any Fields supplied at the log site and\n\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }\nfunc (nopCore) Enabled(Level) bool                            { return false }\nfunc (n nopCore) With([]Field) Core                           { return n }\nfunc (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }\nfunc (nopCore) Write(Entry, []Field) error                    { return nil }"},{"path":"zapcore/core.go","start_line":56,"end_line":75,"code":"\n// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)\n)"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).Sync","path":"logger.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(*nopCore).Sync","path":"zapcore/core.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"NewCore","signature":"func NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core","start_line":58,"end_line":64,"code":"func NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":38,"end_line":57,"code":"\t// writes them to their destination.\n\t//\n\t// If called, Write should always log the Entry and Fields; it should not\n\t// replicate the logic of Check.\n\tWrite(Entry, []Field) error\n\t// Sync flushes buffered logs (if any).\n\tSync() error\n}\n\ntype nopCore struct{}\n\n// NewNopCore returns a no-op Core.\nfunc NewNopCore() Core                                        { return nopCore{} }\nfunc (nopCore) Enabled(Level) bool                            { return false }\nfunc (n nopCore) With([]Field) Core                           { return n }\nfunc (nopCore) Check(_ Entry, ce *CheckedEntry) *CheckedEntry { return ce }\nfunc (nopCore) Write(Entry, []Field) error                    { return nil }\nfunc (nopCore) Sync() error                                   { return nil }\n\n// NewCore creates a Core that writes logs to a WriteSyncer."},{"path":"zapcore/core.go","start_line":65,"end_line":84,"code":"\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)\n)\n\nfunc (c *ioCore) Level() Level {\n\treturn LevelOf(c.LevelEnabler)\n}\n\nfunc (c *ioCore) With(fields []Field) Core {\n\tclone := c.clone()\n\taddFields(clone.enc, fields)\n\treturn clone"}],"selection":{"visibility":"exported","reason":"constructor","score":0.91},"call_graph":{"callees":null,"callers":[{"symbol":"(Config).Build","path":"config.go"},{"symbol":"NewExample","path":"logger.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).Level","signature":"func (c *ioCore) Level() Level","start_line":77,"end_line":79,"code":"func (c *ioCore) Level() Level {\n\n\treturn LevelOf(c.LevelEnabler)\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":57,"end_line":76,"code":"// NewCore creates a Core that writes logs to a WriteSyncer.\nfunc NewCore(enc Encoder, ws WriteSyncer, enab LevelEnabler) Core {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: enab,\n\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)\n)\n"},{"path":"zapcore/core.go","start_line":80,"end_line":99,"code":"\nfunc (c *ioCore) With(fields []Field) Core {\n\tclone := c.clone()\n\taddFields(clone.enc, fields)\n\treturn clone\n}\n\nfunc (c *ioCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif c.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, c)\n\t}\n\treturn ce\n}\n\nfunc (c *ioCore) Write(ent Entry, fields []Field) error {\n\tbuf, err := c.enc.EncodeEntry(ent, fields)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())"}],"selection":{"visibility":"exported","reason":"core","score":0.68},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).With","signature":"func (c *ioCore) With(fields []Field) Core","start_line":81,"end_line":85,"code":"func (c *ioCore) With(fields []Field) Core {\n\n\tclone := c.clone()\n\taddFields(clone.enc, fields)\n\treturn clone\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":61,"end_line":80,"code":"\t\tenc:          enc,\n\t\tout:          ws,\n\t}\n}\n\ntype ioCore struct {\n\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)\n)\n\nfunc (c *ioCore) Level() Level {\n\treturn LevelOf(c.LevelEnabler)\n}\n"},{"path":"zapcore/core.go","start_line":86,"end_line":105,"code":"\nfunc (c *ioCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif c.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, c)\n\t}\n\treturn ce\n}\n\nfunc (c *ioCore) Write(ent Entry, fields []Field) error {\n\tbuf, err := c.enc.EncodeEntry(ent, fields)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())\n\tbuf.Free()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ent.Level \u003e ErrorLevel {\n\t\t// Since we may be crashing the program, sync the output."}],"selection":{"visibility":"exported","reason":"public_api","score":0.94},"call_graph":{"callees":[{"symbol":"(*ioCore).clone","path":"zapcore/core.go"},{"symbol":"addFields","path":"zapcore/field.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).Check","signature":"func (c *ioCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry","start_line":87,"end_line":92,"code":"func (c *ioCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\n\tif c.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, c)\n\t}\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":67,"end_line":86,"code":"\tLevelEnabler\n\tenc Encoder\n\tout WriteSyncer\n}\n\nvar (\n\t_ Core           = (*ioCore)(nil)\n\t_ leveledEnabler = (*ioCore)(nil)\n)\n\nfunc (c *ioCore) Level() Level {\n\treturn LevelOf(c.LevelEnabler)\n}\n\nfunc (c *ioCore) With(fields []Field) Core {\n\tclone := c.clone()\n\taddFields(clone.enc, fields)\n\treturn clone\n}\n"},{"path":"zapcore/core.go","start_line":93,"end_line":112,"code":"\nfunc (c *ioCore) Write(ent Entry, fields []Field) error {\n\tbuf, err := c.enc.EncodeEntry(ent, fields)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())\n\tbuf.Free()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ent.Level \u003e ErrorLevel {\n\t\t// Since we may be crashing the program, sync the output.\n\t\t// Ignore Sync errors, pending a clean solution to issue #370.\n\t\t_ = c.Sync()\n\t}\n\treturn nil\n}\n\nfunc (c *ioCore) Sync() error {"}],"selection":{"visibility":"exported","reason":"core","score":0.79},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).AddCore","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).Write","signature":"func (c *ioCore) Write(ent Entry, fields []Field) error","start_line":94,"end_line":110,"code":"func (c *ioCore) Write(ent Entry, fields []Field) error {\n\n\tbuf, err := c.enc.EncodeEntry(ent, fields)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())\n\tbuf.Free()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ent.Level \u003e ErrorLevel {\n\t\t\n\t\t\n\t\t_ = c.Sync()\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":74,"end_line":93,"code":"\t_ leveledEnabler = (*ioCore)(nil)\n)\n\nfunc (c *ioCore) Level() Level {\n\treturn LevelOf(c.LevelEnabler)\n}\n\nfunc (c *ioCore) With(fields []Field) Core {\n\tclone := c.clone()\n\taddFields(clone.enc, fields)\n\treturn clone\n}\n\nfunc (c *ioCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif c.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, c)\n\t}\n\treturn ce\n}\n"},{"path":"zapcore/core.go","start_line":111,"end_line":123,"code":"\nfunc (c *ioCore) Sync() error {\n\treturn c.out.Sync()\n}\n\nfunc (c *ioCore) clone() *ioCore {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: c.LevelEnabler,\n\t\tenc:          c.enc.Clone(),\n\t\tout:          c.out,\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.85},"call_graph":{"callees":[{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Write","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*BufferedWriteSyncer).Write","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*Decoder).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/hpack.go"},{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512.go"},{"symbol":"(*Discarder).Write","path":"internal/ztest/writer.go"},{"symbol":"(*File).Write","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"(*SHA3).Write","path":"../../../../usr/local/go/src/crypto/sha3/sha3.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*dictWriter).Write","path":"../../../../usr/local/go/src/compress/flate/deflate.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/crypto/sha1/sha1.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/hash/crc32/crc32.go"},{"symbol":"(*encoder).Write","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2bufferedWriterTimeoutWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2pipe).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*lockedWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"(*loggingConn).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*netFD).Write","path":"../../../../usr/local/go/src/net/fd_posix.go"},{"symbol":"(*populateResponse).Write","path":"../../../../usr/local/go/src/net/http/filetransport.go"},{"symbol":"(*prefixSuffixSaver).Write","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*response).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*runtimeStderr).Write","path":"../../../../usr/local/go/src/internal/godebug/godebug.go"},{"symbol":"(TestingWriter).Write","path":"zaptest/logger.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(discard).Write","path":"../../../../usr/local/go/src/io/io.go"},{"symbol":"(http2stickyErrWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(multiWriteSyncer).Write","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).Sync","signature":"func (c *ioCore) Sync() error","start_line":112,"end_line":114,"code":"func (c *ioCore) Sync() error {\n\n\treturn c.out.Sync()\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":92,"end_line":111,"code":"}\n\nfunc (c *ioCore) Write(ent Entry, fields []Field) error {\n\tbuf, err := c.enc.EncodeEntry(ent, fields)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())\n\tbuf.Free()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ent.Level \u003e ErrorLevel {\n\t\t// Since we may be crashing the program, sync the output.\n\t\t// Ignore Sync errors, pending a clean solution to issue #370.\n\t\t_ = c.Sync()\n\t}\n\treturn nil\n}\n"},{"path":"zapcore/core.go","start_line":115,"end_line":123,"code":"\nfunc (c *ioCore) clone() *ioCore {\n\treturn \u0026ioCore{\n\t\tLevelEnabler: c.LevelEnabler,\n\t\tenc:          c.enc.Clone(),\n\t\tout:          c.out,\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*File).Sync","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(writerWrapper).Sync","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"(*Logger).Sync","path":"logger.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/core.go","symbol":"(*ioCore).clone","signature":"func (c *ioCore) clone() *ioCore","start_line":116,"end_line":122,"code":"func (c *ioCore) clone() *ioCore {\n\n\treturn \u0026ioCore{\n\t\tLevelEnabler: c.LevelEnabler,\n\t\tenc:          c.enc.Clone(),\n\t\tout:          c.out,\n\t}\n}\n","neighbors":[{"path":"zapcore/core.go","start_line":96,"end_line":115,"code":"\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = c.out.Write(buf.Bytes())\n\tbuf.Free()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ent.Level \u003e ErrorLevel {\n\t\t// Since we may be crashing the program, sync the output.\n\t\t// Ignore Sync errors, pending a clean solution to issue #370.\n\t\t_ = c.Sync()\n\t}\n\treturn nil\n}\n\nfunc (c *ioCore) Sync() error {\n\treturn c.out.Sync()\n}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.59},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).Clone","path":"zapcore/console_encoder.go"}],"callers":[{"symbol":"(*ioCore).With","path":"zapcore/core.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"LowercaseLevelEncoder","signature":"func LowercaseLevelEncoder(l Level, enc PrimitiveArrayEncoder)","start_line":47,"end_line":49,"code":"func LowercaseLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendString(l.String())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":27,"end_line":46,"code":"\n\t\"go.uber.org/zap/buffer\"\n)\n\n// DefaultLineEnding defines the default line ending when writing logs.\n// Alternate line endings specified in EncoderConfig can override this\n// behavior.\nconst DefaultLineEnding = \"\\n\"\n\n// OmitKey defines the key to use when callers want to remove a key from log output.\nconst OmitKey = \"\"\n\n// A LevelEncoder serializes a Level to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype LevelEncoder func(Level, PrimitiveArrayEncoder)\n\n// LowercaseLevelEncoder serializes a Level to a lowercase string. For example,\n// InfoLevel is serialized to \"info\"."},{"path":"zapcore/encoder.go","start_line":50,"end_line":69,"code":"\n// LowercaseColorLevelEncoder serializes a Level to a lowercase string and adds coloring.\n// For example, InfoLevel is serialized to \"info\" and colored blue.\nfunc LowercaseColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToLowercaseColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.String())\n\t}\n\tenc.AppendString(s)\n}\n\n// CapitalLevelEncoder serializes a Level to an all-caps string. For example,\n// InfoLevel is serialized to \"INFO\".\nfunc CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.CapitalString())\n}\n\n// CapitalColorLevelEncoder serializes a Level to an all-caps string and adds color.\n// For example, InfoLevel is serialized to \"INFO\" and colored blue.\nfunc CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Level).String","path":"zapcore/level.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"LowercaseColorLevelEncoder","signature":"func LowercaseColorLevelEncoder(l Level, enc PrimitiveArrayEncoder)","start_line":53,"end_line":59,"code":"func LowercaseColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\n\ts, ok := _levelToLowercaseColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.String())\n\t}\n\tenc.AppendString(s)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":33,"end_line":52,"code":"// behavior.\nconst DefaultLineEnding = \"\\n\"\n\n// OmitKey defines the key to use when callers want to remove a key from log output.\nconst OmitKey = \"\"\n\n// A LevelEncoder serializes a Level to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype LevelEncoder func(Level, PrimitiveArrayEncoder)\n\n// LowercaseLevelEncoder serializes a Level to a lowercase string. For example,\n// InfoLevel is serialized to \"info\".\nfunc LowercaseLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.String())\n}\n\n// LowercaseColorLevelEncoder serializes a Level to a lowercase string and adds coloring.\n// For example, InfoLevel is serialized to \"info\" and colored blue."},{"path":"zapcore/encoder.go","start_line":60,"end_line":79,"code":"\n// CapitalLevelEncoder serializes a Level to an all-caps string. For example,\n// InfoLevel is serialized to \"INFO\".\nfunc CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.CapitalString())\n}\n\n// CapitalColorLevelEncoder serializes a Level to an all-caps string and adds color.\n// For example, InfoLevel is serialized to \"INFO\" and colored blue.\nfunc CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToCapitalColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.CapitalString())\n\t}\n\tenc.AppendString(s)\n}\n\n// UnmarshalText unmarshals text to a LevelEncoder. \"capital\" is unmarshaled to\n// CapitalLevelEncoder, \"coloredCapital\" is unmarshaled to CapitalColorLevelEncoder,\n// \"colored\" is unmarshaled to LowercaseColorLevelEncoder, and anything else"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Color).Add","path":"internal/color/color.go"},{"symbol":"(Level).String","path":"zapcore/level.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"CapitalLevelEncoder","signature":"func CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder)","start_line":63,"end_line":65,"code":"func CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendString(l.CapitalString())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":43,"end_line":62,"code":"type LevelEncoder func(Level, PrimitiveArrayEncoder)\n\n// LowercaseLevelEncoder serializes a Level to a lowercase string. For example,\n// InfoLevel is serialized to \"info\".\nfunc LowercaseLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.String())\n}\n\n// LowercaseColorLevelEncoder serializes a Level to a lowercase string and adds coloring.\n// For example, InfoLevel is serialized to \"info\" and colored blue.\nfunc LowercaseColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToLowercaseColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.String())\n\t}\n\tenc.AppendString(s)\n}\n\n// CapitalLevelEncoder serializes a Level to an all-caps string. For example,\n// InfoLevel is serialized to \"INFO\"."},{"path":"zapcore/encoder.go","start_line":66,"end_line":85,"code":"\n// CapitalColorLevelEncoder serializes a Level to an all-caps string and adds color.\n// For example, InfoLevel is serialized to \"INFO\" and colored blue.\nfunc CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToCapitalColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.CapitalString())\n\t}\n\tenc.AppendString(s)\n}\n\n// UnmarshalText unmarshals text to a LevelEncoder. \"capital\" is unmarshaled to\n// CapitalLevelEncoder, \"coloredCapital\" is unmarshaled to CapitalColorLevelEncoder,\n// \"colored\" is unmarshaled to LowercaseColorLevelEncoder, and anything else\n// is unmarshaled to LowercaseLevelEncoder.\nfunc (e *LevelEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"capital\":\n\t\t*e = CapitalLevelEncoder\n\tcase \"capitalColor\":"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Level).CapitalString","path":"zapcore/level.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"CapitalColorLevelEncoder","signature":"func CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder)","start_line":69,"end_line":75,"code":"func CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\n\ts, ok := _levelToCapitalColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.CapitalString())\n\t}\n\tenc.AppendString(s)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":49,"end_line":68,"code":"}\n\n// LowercaseColorLevelEncoder serializes a Level to a lowercase string and adds coloring.\n// For example, InfoLevel is serialized to \"info\" and colored blue.\nfunc LowercaseColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToLowercaseColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.String())\n\t}\n\tenc.AppendString(s)\n}\n\n// CapitalLevelEncoder serializes a Level to an all-caps string. For example,\n// InfoLevel is serialized to \"INFO\".\nfunc CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.CapitalString())\n}\n\n// CapitalColorLevelEncoder serializes a Level to an all-caps string and adds color.\n// For example, InfoLevel is serialized to \"INFO\" and colored blue."},{"path":"zapcore/encoder.go","start_line":76,"end_line":95,"code":"\n// UnmarshalText unmarshals text to a LevelEncoder. \"capital\" is unmarshaled to\n// CapitalLevelEncoder, \"coloredCapital\" is unmarshaled to CapitalColorLevelEncoder,\n// \"colored\" is unmarshaled to LowercaseColorLevelEncoder, and anything else\n// is unmarshaled to LowercaseLevelEncoder.\nfunc (e *LevelEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"capital\":\n\t\t*e = CapitalLevelEncoder\n\tcase \"capitalColor\":\n\t\t*e = CapitalColorLevelEncoder\n\tcase \"color\":\n\t\t*e = LowercaseColorLevelEncoder\n\tdefault:\n\t\t*e = LowercaseLevelEncoder\n\t}\n\treturn nil\n}\n\n// A TimeEncoder serializes a time.Time to a primitive type."}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Color).Add","path":"internal/color/color.go"},{"symbol":"(Level).CapitalString","path":"zapcore/level.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*LevelEncoder).UnmarshalText","signature":"func (e *LevelEncoder) UnmarshalText(text []byte) error","start_line":81,"end_line":93,"code":"func (e *LevelEncoder) UnmarshalText(text []byte) error {\n\n\tswitch string(text) {\n\tcase \"capital\":\n\t\t*e = CapitalLevelEncoder\n\tcase \"capitalColor\":\n\t\t*e = CapitalColorLevelEncoder\n\tcase \"color\":\n\t\t*e = LowercaseColorLevelEncoder\n\tdefault:\n\t\t*e = LowercaseLevelEncoder\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":61,"end_line":80,"code":"// CapitalLevelEncoder serializes a Level to an all-caps string. For example,\n// InfoLevel is serialized to \"INFO\".\nfunc CapitalLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(l.CapitalString())\n}\n\n// CapitalColorLevelEncoder serializes a Level to an all-caps string and adds color.\n// For example, InfoLevel is serialized to \"INFO\" and colored blue.\nfunc CapitalColorLevelEncoder(l Level, enc PrimitiveArrayEncoder) {\n\ts, ok := _levelToCapitalColorString[l]\n\tif !ok {\n\t\ts = _unknownLevelColor.Add(l.CapitalString())\n\t}\n\tenc.AppendString(s)\n}\n\n// UnmarshalText unmarshals text to a LevelEncoder. \"capital\" is unmarshaled to\n// CapitalLevelEncoder, \"coloredCapital\" is unmarshaled to CapitalColorLevelEncoder,\n// \"colored\" is unmarshaled to LowercaseColorLevelEncoder, and anything else\n// is unmarshaled to LowercaseLevelEncoder."},{"path":"zapcore/encoder.go","start_line":94,"end_line":113,"code":"\n// A TimeEncoder serializes a time.Time to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype TimeEncoder func(time.Time, PrimitiveArrayEncoder)\n\n// EpochTimeEncoder serializes a time.Time to a floating-point number of seconds\n// since the Unix epoch.\nfunc EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tsec := float64(nanos) / float64(time.Second)\n\tenc.AppendFloat64(sec)\n}\n\n// EpochMillisTimeEncoder serializes a time.Time to a floating-point number of\n// milliseconds since the Unix epoch.\nfunc EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tmillis := float64(nanos) / float64(time.Millisecond)"}],"selection":{"visibility":"exported","reason":"encoder","score":0.77},"call_graph":{"callees":null,"callers":[{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"EpochTimeEncoder","signature":"func EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":103,"end_line":107,"code":"func EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tnanos := t.UnixNano()\n\tsec := float64(nanos) / float64(time.Second)\n\tenc.AppendFloat64(sec)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":83,"end_line":102,"code":"\tcase \"capital\":\n\t\t*e = CapitalLevelEncoder\n\tcase \"capitalColor\":\n\t\t*e = CapitalColorLevelEncoder\n\tcase \"color\":\n\t\t*e = LowercaseColorLevelEncoder\n\tdefault:\n\t\t*e = LowercaseLevelEncoder\n\t}\n\treturn nil\n}\n\n// A TimeEncoder serializes a time.Time to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype TimeEncoder func(time.Time, PrimitiveArrayEncoder)\n\n// EpochTimeEncoder serializes a time.Time to a floating-point number of seconds\n// since the Unix epoch."},{"path":"zapcore/encoder.go","start_line":108,"end_line":127,"code":"\n// EpochMillisTimeEncoder serializes a time.Time to a floating-point number of\n// milliseconds since the Unix epoch.\nfunc EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tmillis := float64(nanos) / float64(time.Millisecond)\n\tenc.AppendFloat64(millis)\n}\n\n// EpochNanosTimeEncoder serializes a time.Time to an integer number of\n// nanoseconds since the Unix epoch.\nfunc EpochNanosTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(t.UnixNano())\n}\n\nfunc encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder) {\n\ttype appendTimeEncoder interface {\n\t\tAppendTimeLayout(time.Time, string)\n\t}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendFloat64","path":"zapcore/memory_encoder.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"EpochMillisTimeEncoder","signature":"func EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":111,"end_line":115,"code":"func EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tnanos := t.UnixNano()\n\tmillis := float64(nanos) / float64(time.Millisecond)\n\tenc.AppendFloat64(millis)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":91,"end_line":110,"code":"\t}\n\treturn nil\n}\n\n// A TimeEncoder serializes a time.Time to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype TimeEncoder func(time.Time, PrimitiveArrayEncoder)\n\n// EpochTimeEncoder serializes a time.Time to a floating-point number of seconds\n// since the Unix epoch.\nfunc EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tsec := float64(nanos) / float64(time.Second)\n\tenc.AppendFloat64(sec)\n}\n\n// EpochMillisTimeEncoder serializes a time.Time to a floating-point number of\n// milliseconds since the Unix epoch."},{"path":"zapcore/encoder.go","start_line":116,"end_line":135,"code":"\n// EpochNanosTimeEncoder serializes a time.Time to an integer number of\n// nanoseconds since the Unix epoch.\nfunc EpochNanosTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(t.UnixNano())\n}\n\nfunc encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder) {\n\ttype appendTimeEncoder interface {\n\t\tAppendTimeLayout(time.Time, string)\n\t}\n\n\tif enc, ok := enc.(appendTimeEncoder); ok {\n\t\tenc.AppendTimeLayout(t, layout)\n\t\treturn\n\t}\n\n\tenc.AppendString(t.Format(layout))\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendFloat64","path":"zapcore/memory_encoder.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"EpochNanosTimeEncoder","signature":"func EpochNanosTimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":119,"end_line":121,"code":"func EpochNanosTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendInt64(t.UnixNano())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":99,"end_line":118,"code":"type TimeEncoder func(time.Time, PrimitiveArrayEncoder)\n\n// EpochTimeEncoder serializes a time.Time to a floating-point number of seconds\n// since the Unix epoch.\nfunc EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tsec := float64(nanos) / float64(time.Second)\n\tenc.AppendFloat64(sec)\n}\n\n// EpochMillisTimeEncoder serializes a time.Time to a floating-point number of\n// milliseconds since the Unix epoch.\nfunc EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tmillis := float64(nanos) / float64(time.Millisecond)\n\tenc.AppendFloat64(millis)\n}\n\n// EpochNanosTimeEncoder serializes a time.Time to an integer number of\n// nanoseconds since the Unix epoch."},{"path":"zapcore/encoder.go","start_line":122,"end_line":141,"code":"\nfunc encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder) {\n\ttype appendTimeEncoder interface {\n\t\tAppendTimeLayout(time.Time, string)\n\t}\n\n\tif enc, ok := enc.(appendTimeEncoder); ok {\n\t\tenc.AppendTimeLayout(t, layout)\n\t\treturn\n\t}\n\n\tenc.AppendString(t.Format(layout))\n}\n\n// ISO8601TimeEncoder serializes a time.Time to an ISO8601-formatted string\n// with millisecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt64","path":"zapcore/memory_encoder.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"encodeTimeLayout","signature":"func encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder)","start_line":123,"end_line":134,"code":"func encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder) {\n\n\ttype appendTimeEncoder interface {\n\t\tAppendTimeLayout(time.Time, string)\n\t}\n\n\tif enc, ok := enc.(appendTimeEncoder); ok {\n\t\tenc.AppendTimeLayout(t, layout)\n\t\treturn\n\t}\n\n\tenc.AppendString(t.Format(layout))\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":103,"end_line":122,"code":"func EpochTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tsec := float64(nanos) / float64(time.Second)\n\tenc.AppendFloat64(sec)\n}\n\n// EpochMillisTimeEncoder serializes a time.Time to a floating-point number of\n// milliseconds since the Unix epoch.\nfunc EpochMillisTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tnanos := t.UnixNano()\n\tmillis := float64(nanos) / float64(time.Millisecond)\n\tenc.AppendFloat64(millis)\n}\n\n// EpochNanosTimeEncoder serializes a time.Time to an integer number of\n// nanoseconds since the Unix epoch.\nfunc EpochNanosTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(t.UnixNano())\n}\n"},{"path":"zapcore/encoder.go","start_line":135,"end_line":154,"code":"\n// ISO8601TimeEncoder serializes a time.Time to an ISO8601-formatted string\n// with millisecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, \"2006-01-02T15:04:05.000Z0700\", enc)\n}\n\n// RFC3339TimeEncoder serializes a time.Time to an RFC3339-formatted string.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339, enc)\n}\n\n// RFC3339NanoTimeEncoder serializes a time.Time to an RFC3339-formatted string\n// with nanosecond precision."}],"selection":{"visibility":"unexported","reason":"encoder","score":0.57},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Time).Format","path":"../../../../usr/local/go/src/time/format.go"}],"callers":[{"symbol":"ISO8601TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"RFC3339NanoTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"RFC3339TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"TimeEncoderOfLayout$1","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"ISO8601TimeEncoder","signature":"func ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":141,"end_line":143,"code":"func ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tencodeTimeLayout(t, \"2006-01-02T15:04:05.000Z0700\", enc)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":121,"end_line":140,"code":"}\n\nfunc encodeTimeLayout(t time.Time, layout string, enc PrimitiveArrayEncoder) {\n\ttype appendTimeEncoder interface {\n\t\tAppendTimeLayout(time.Time, string)\n\t}\n\n\tif enc, ok := enc.(appendTimeEncoder); ok {\n\t\tenc.AppendTimeLayout(t, layout)\n\t\treturn\n\t}\n\n\tenc.AppendString(t.Format(layout))\n}\n\n// ISO8601TimeEncoder serializes a time.Time to an ISO8601-formatted string\n// with millisecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value."},{"path":"zapcore/encoder.go","start_line":144,"end_line":163,"code":"\n// RFC3339TimeEncoder serializes a time.Time to an RFC3339-formatted string.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339, enc)\n}\n\n// RFC3339NanoTimeEncoder serializes a time.Time to an RFC3339-formatted string\n// with nanosecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339Nano, enc)\n}\n\n// TimeEncoderOfLayout returns TimeEncoder which serializes a time.Time using\n// given layout."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"RFC3339TimeEncoder","signature":"func RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":149,"end_line":151,"code":"func RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tencodeTimeLayout(t, time.RFC3339, enc)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":129,"end_line":148,"code":"\t\tenc.AppendTimeLayout(t, layout)\n\t\treturn\n\t}\n\n\tenc.AppendString(t.Format(layout))\n}\n\n// ISO8601TimeEncoder serializes a time.Time to an ISO8601-formatted string\n// with millisecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, \"2006-01-02T15:04:05.000Z0700\", enc)\n}\n\n// RFC3339TimeEncoder serializes a time.Time to an RFC3339-formatted string.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value."},{"path":"zapcore/encoder.go","start_line":152,"end_line":171,"code":"\n// RFC3339NanoTimeEncoder serializes a time.Time to an RFC3339-formatted string\n// with nanosecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339Nano, enc)\n}\n\n// TimeEncoderOfLayout returns TimeEncoder which serializes a time.Time using\n// given layout.\nfunc TimeEncoderOfLayout(layout string) TimeEncoder {\n\treturn func(t time.Time, enc PrimitiveArrayEncoder) {\n\t\tencodeTimeLayout(t, layout, enc)\n\t}\n}\n\n// UnmarshalText unmarshals text to a TimeEncoder.\n// \"rfc3339nano\" and \"RFC3339Nano\" are unmarshaled to RFC3339NanoTimeEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"RFC3339NanoTimeEncoder","signature":"func RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder)","start_line":158,"end_line":160,"code":"func RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\n\tencodeTimeLayout(t, time.RFC3339Nano, enc)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":138,"end_line":157,"code":"//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc ISO8601TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, \"2006-01-02T15:04:05.000Z0700\", enc)\n}\n\n// RFC3339TimeEncoder serializes a time.Time to an RFC3339-formatted string.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339, enc)\n}\n\n// RFC3339NanoTimeEncoder serializes a time.Time to an RFC3339-formatted string\n// with nanosecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value."},{"path":"zapcore/encoder.go","start_line":161,"end_line":180,"code":"\n// TimeEncoderOfLayout returns TimeEncoder which serializes a time.Time using\n// given layout.\nfunc TimeEncoderOfLayout(layout string) TimeEncoder {\n\treturn func(t time.Time, enc PrimitiveArrayEncoder) {\n\t\tencodeTimeLayout(t, layout, enc)\n\t}\n}\n\n// UnmarshalText unmarshals text to a TimeEncoder.\n// \"rfc3339nano\" and \"RFC3339Nano\" are unmarshaled to RFC3339NanoTimeEncoder.\n// \"rfc3339\" and \"RFC3339\" are unmarshaled to RFC3339TimeEncoder.\n// \"iso8601\" and \"ISO8601\" are unmarshaled to ISO8601TimeEncoder.\n// \"millis\" is unmarshaled to EpochMillisTimeEncoder.\n// \"nanos\" is unmarshaled to EpochNanosEncoder.\n// Anything else is unmarshaled to EpochTimeEncoder.\nfunc (e *TimeEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"rfc3339nano\", \"RFC3339Nano\":\n\t\t*e = RFC3339NanoTimeEncoder"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"TimeEncoderOfLayout","signature":"func TimeEncoderOfLayout(layout string) TimeEncoder","start_line":164,"end_line":168,"code":"func TimeEncoderOfLayout(layout string) TimeEncoder {\n\n\treturn func(t time.Time, enc PrimitiveArrayEncoder) {\n\t\tencodeTimeLayout(t, layout, enc)\n\t}\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":144,"end_line":163,"code":"\n// RFC3339TimeEncoder serializes a time.Time to an RFC3339-formatted string.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339TimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339, enc)\n}\n\n// RFC3339NanoTimeEncoder serializes a time.Time to an RFC3339-formatted string\n// with nanosecond precision.\n//\n// If enc supports AppendTimeLayout(t time.Time,layout string), it's used\n// instead of appending a pre-formatted string value.\nfunc RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339Nano, enc)\n}\n\n// TimeEncoderOfLayout returns TimeEncoder which serializes a time.Time using\n// given layout."},{"path":"zapcore/encoder.go","start_line":169,"end_line":188,"code":"\n// UnmarshalText unmarshals text to a TimeEncoder.\n// \"rfc3339nano\" and \"RFC3339Nano\" are unmarshaled to RFC3339NanoTimeEncoder.\n// \"rfc3339\" and \"RFC3339\" are unmarshaled to RFC3339TimeEncoder.\n// \"iso8601\" and \"ISO8601\" are unmarshaled to ISO8601TimeEncoder.\n// \"millis\" is unmarshaled to EpochMillisTimeEncoder.\n// \"nanos\" is unmarshaled to EpochNanosEncoder.\n// Anything else is unmarshaled to EpochTimeEncoder.\nfunc (e *TimeEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"rfc3339nano\", \"RFC3339Nano\":\n\t\t*e = RFC3339NanoTimeEncoder\n\tcase \"rfc3339\", \"RFC3339\":\n\t\t*e = RFC3339TimeEncoder\n\tcase \"iso8601\", \"ISO8601\":\n\t\t*e = ISO8601TimeEncoder\n\tcase \"millis\":\n\t\t*e = EpochMillisTimeEncoder\n\tcase \"nanos\":\n\t\t*e = EpochNanosTimeEncoder"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":null,"callers":[{"symbol":"(*TimeEncoder).UnmarshalYAML","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*TimeEncoder).UnmarshalText","signature":"func (e *TimeEncoder) UnmarshalText(text []byte) error","start_line":177,"end_line":193,"code":"func (e *TimeEncoder) UnmarshalText(text []byte) error {\n\n\tswitch string(text) {\n\tcase \"rfc3339nano\", \"RFC3339Nano\":\n\t\t*e = RFC3339NanoTimeEncoder\n\tcase \"rfc3339\", \"RFC3339\":\n\t\t*e = RFC3339TimeEncoder\n\tcase \"iso8601\", \"ISO8601\":\n\t\t*e = ISO8601TimeEncoder\n\tcase \"millis\":\n\t\t*e = EpochMillisTimeEncoder\n\tcase \"nanos\":\n\t\t*e = EpochNanosTimeEncoder\n\tdefault:\n\t\t*e = EpochTimeEncoder\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":157,"end_line":176,"code":"// instead of appending a pre-formatted string value.\nfunc RFC3339NanoTimeEncoder(t time.Time, enc PrimitiveArrayEncoder) {\n\tencodeTimeLayout(t, time.RFC3339Nano, enc)\n}\n\n// TimeEncoderOfLayout returns TimeEncoder which serializes a time.Time using\n// given layout.\nfunc TimeEncoderOfLayout(layout string) TimeEncoder {\n\treturn func(t time.Time, enc PrimitiveArrayEncoder) {\n\t\tencodeTimeLayout(t, layout, enc)\n\t}\n}\n\n// UnmarshalText unmarshals text to a TimeEncoder.\n// \"rfc3339nano\" and \"RFC3339Nano\" are unmarshaled to RFC3339NanoTimeEncoder.\n// \"rfc3339\" and \"RFC3339\" are unmarshaled to RFC3339TimeEncoder.\n// \"iso8601\" and \"ISO8601\" are unmarshaled to ISO8601TimeEncoder.\n// \"millis\" is unmarshaled to EpochMillisTimeEncoder.\n// \"nanos\" is unmarshaled to EpochNanosEncoder.\n// Anything else is unmarshaled to EpochTimeEncoder."},{"path":"zapcore/encoder.go","start_line":194,"end_line":213,"code":"\n// UnmarshalYAML unmarshals YAML to a TimeEncoder.\n// If value is an object with a \"layout\" field, it will be unmarshaled to  TimeEncoder with given layout.\n//\n//\ttimeEncoder:\n//\t  layout: 06/01/02 03:04pm\n//\n// If value is string, it uses UnmarshalText.\n//\n//\ttimeEncoder: iso8601\nfunc (e *TimeEncoder) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar o struct {\n\t\tLayout string `json:\"layout\" yaml:\"layout\"`\n\t}\n\tif err := unmarshal(\u0026o); err == nil {\n\t\t*e = TimeEncoderOfLayout(o.Layout)\n\t\treturn nil\n\t}\n\n\tvar s string"}],"selection":{"visibility":"exported","reason":"encoder","score":0.77},"call_graph":{"callees":null,"callers":[{"symbol":"(*TimeEncoder).UnmarshalYAML","path":"zapcore/encoder.go"},{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*TimeEncoder).UnmarshalYAML","signature":"func (e *TimeEncoder) UnmarshalYAML(unmarshal func(interface{}) error) error","start_line":204,"end_line":218,"code":"func (e *TimeEncoder) UnmarshalYAML(unmarshal func(interface{\n}) error) error {\n\tvar o struct {\n\t\tLayout string `json:\"layout\" yaml:\"layout\"`\n\t}\n\tif err := unmarshal(\u0026o); err == nil {\n\t\t*e = TimeEncoderOfLayout(o.Layout)\n\t\treturn nil\n\t}\n\n\tvar s string\n\tif err := unmarshal(\u0026s); err != nil {\n\t\treturn err\n\t}\n\treturn e.UnmarshalText([]byte(s))\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":184,"end_line":203,"code":"\t\t*e = ISO8601TimeEncoder\n\tcase \"millis\":\n\t\t*e = EpochMillisTimeEncoder\n\tcase \"nanos\":\n\t\t*e = EpochNanosTimeEncoder\n\tdefault:\n\t\t*e = EpochTimeEncoder\n\t}\n\treturn nil\n}\n\n// UnmarshalYAML unmarshals YAML to a TimeEncoder.\n// If value is an object with a \"layout\" field, it will be unmarshaled to  TimeEncoder with given layout.\n//\n//\ttimeEncoder:\n//\t  layout: 06/01/02 03:04pm\n//\n// If value is string, it uses UnmarshalText.\n//\n//\ttimeEncoder: iso8601"},{"path":"zapcore/encoder.go","start_line":219,"end_line":238,"code":"\n// UnmarshalJSON unmarshals JSON to a TimeEncoder as same way UnmarshalYAML does.\nfunc (e *TimeEncoder) UnmarshalJSON(data []byte) error {\n\treturn e.UnmarshalYAML(func(v interface{}) error {\n\t\treturn json.Unmarshal(data, v)\n\t})\n}\n\n// A DurationEncoder serializes a time.Duration to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype DurationEncoder func(time.Duration, PrimitiveArrayEncoder)\n\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed.\nfunc SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n\n// NanosDurationEncoder serializes a time.Duration to an integer number of"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*TimeEncoder).UnmarshalText","path":"zapcore/encoder.go"},{"symbol":"TimeEncoderOfLayout","path":"zapcore/encoder.go"},{"symbol":"UnmarshalJSON$1","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*TimeEncoder).UnmarshalJSON","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*TimeEncoder).UnmarshalJSON","signature":"func (e *TimeEncoder) UnmarshalJSON(data []byte) error","start_line":221,"end_line":225,"code":"func (e *TimeEncoder) UnmarshalJSON(data []byte) error {\n\n\treturn e.UnmarshalYAML(func(v interface{}) error {\n\t\treturn json.Unmarshal(data, v)\n\t})\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":201,"end_line":220,"code":"// If value is string, it uses UnmarshalText.\n//\n//\ttimeEncoder: iso8601\nfunc (e *TimeEncoder) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar o struct {\n\t\tLayout string `json:\"layout\" yaml:\"layout\"`\n\t}\n\tif err := unmarshal(\u0026o); err == nil {\n\t\t*e = TimeEncoderOfLayout(o.Layout)\n\t\treturn nil\n\t}\n\n\tvar s string\n\tif err := unmarshal(\u0026s); err != nil {\n\t\treturn err\n\t}\n\treturn e.UnmarshalText([]byte(s))\n}\n\n// UnmarshalJSON unmarshals JSON to a TimeEncoder as same way UnmarshalYAML does."},{"path":"zapcore/encoder.go","start_line":226,"end_line":245,"code":"\n// A DurationEncoder serializes a time.Duration to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype DurationEncoder func(time.Duration, PrimitiveArrayEncoder)\n\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed.\nfunc SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n\n// NanosDurationEncoder serializes a time.Duration to an integer number of\n// nanoseconds elapsed.\nfunc NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(int64(d))\n}\n\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed."}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*TimeEncoder).UnmarshalYAML","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*decodeState).array","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(*decodeState).object","path":"../../../../usr/local/go/src/encoding/json/decode.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"SecondsDurationEncoder","signature":"func SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder)","start_line":234,"end_line":236,"code":"func SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":214,"end_line":233,"code":"\tif err := unmarshal(\u0026s); err != nil {\n\t\treturn err\n\t}\n\treturn e.UnmarshalText([]byte(s))\n}\n\n// UnmarshalJSON unmarshals JSON to a TimeEncoder as same way UnmarshalYAML does.\nfunc (e *TimeEncoder) UnmarshalJSON(data []byte) error {\n\treturn e.UnmarshalYAML(func(v interface{}) error {\n\t\treturn json.Unmarshal(data, v)\n\t})\n}\n\n// A DurationEncoder serializes a time.Duration to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype DurationEncoder func(time.Duration, PrimitiveArrayEncoder)\n\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed."},{"path":"zapcore/encoder.go","start_line":237,"end_line":256,"code":"\n// NanosDurationEncoder serializes a time.Duration to an integer number of\n// nanoseconds elapsed.\nfunc NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(int64(d))\n}\n\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed.\nfunc MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(d.Nanoseconds() / 1e6)\n}\n\n// StringDurationEncoder serializes a time.Duration using its built-in String\n// method.\nfunc StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(d.String())\n}\n\n// UnmarshalText unmarshals text to a DurationEncoder. \"string\" is unmarshaled"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendFloat64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"NanosDurationEncoder","signature":"func NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder)","start_line":240,"end_line":242,"code":"func NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendInt64(int64(d))\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":220,"end_line":239,"code":"// UnmarshalJSON unmarshals JSON to a TimeEncoder as same way UnmarshalYAML does.\nfunc (e *TimeEncoder) UnmarshalJSON(data []byte) error {\n\treturn e.UnmarshalYAML(func(v interface{}) error {\n\t\treturn json.Unmarshal(data, v)\n\t})\n}\n\n// A DurationEncoder serializes a time.Duration to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype DurationEncoder func(time.Duration, PrimitiveArrayEncoder)\n\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed.\nfunc SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n\n// NanosDurationEncoder serializes a time.Duration to an integer number of\n// nanoseconds elapsed."},{"path":"zapcore/encoder.go","start_line":243,"end_line":262,"code":"\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed.\nfunc MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(d.Nanoseconds() / 1e6)\n}\n\n// StringDurationEncoder serializes a time.Duration using its built-in String\n// method.\nfunc StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(d.String())\n}\n\n// UnmarshalText unmarshals text to a DurationEncoder. \"string\" is unmarshaled\n// to StringDurationEncoder, and anything else is unmarshaled to\n// NanosDurationEncoder.\nfunc (e *DurationEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"string\":\n\t\t*e = StringDurationEncoder"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt64","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"MillisDurationEncoder","signature":"func MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder)","start_line":246,"end_line":248,"code":"func MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendInt64(d.Nanoseconds() / 1e6)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":226,"end_line":245,"code":"\n// A DurationEncoder serializes a time.Duration to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype DurationEncoder func(time.Duration, PrimitiveArrayEncoder)\n\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed.\nfunc SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n\n// NanosDurationEncoder serializes a time.Duration to an integer number of\n// nanoseconds elapsed.\nfunc NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(int64(d))\n}\n\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed."},{"path":"zapcore/encoder.go","start_line":249,"end_line":268,"code":"\n// StringDurationEncoder serializes a time.Duration using its built-in String\n// method.\nfunc StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(d.String())\n}\n\n// UnmarshalText unmarshals text to a DurationEncoder. \"string\" is unmarshaled\n// to StringDurationEncoder, and anything else is unmarshaled to\n// NanosDurationEncoder.\nfunc (e *DurationEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"string\":\n\t\t*e = StringDurationEncoder\n\tcase \"nanos\":\n\t\t*e = NanosDurationEncoder\n\tcase \"ms\":\n\t\t*e = MillisDurationEncoder\n\tdefault:\n\t\t*e = SecondsDurationEncoder"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendInt64","path":"zapcore/memory_encoder.go"},{"symbol":"(Duration).Nanoseconds","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"StringDurationEncoder","signature":"func StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder)","start_line":252,"end_line":254,"code":"func StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendString(d.String())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":232,"end_line":251,"code":"\n// SecondsDurationEncoder serializes a time.Duration to a floating-point number of seconds elapsed.\nfunc SecondsDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendFloat64(float64(d) / float64(time.Second))\n}\n\n// NanosDurationEncoder serializes a time.Duration to an integer number of\n// nanoseconds elapsed.\nfunc NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(int64(d))\n}\n\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed.\nfunc MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(d.Nanoseconds() / 1e6)\n}\n\n// StringDurationEncoder serializes a time.Duration using its built-in String\n// method."},{"path":"zapcore/encoder.go","start_line":255,"end_line":274,"code":"\n// UnmarshalText unmarshals text to a DurationEncoder. \"string\" is unmarshaled\n// to StringDurationEncoder, and anything else is unmarshaled to\n// NanosDurationEncoder.\nfunc (e *DurationEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"string\":\n\t\t*e = StringDurationEncoder\n\tcase \"nanos\":\n\t\t*e = NanosDurationEncoder\n\tcase \"ms\":\n\t\t*e = MillisDurationEncoder\n\tdefault:\n\t\t*e = SecondsDurationEncoder\n\t}\n\treturn nil\n}\n\n// A CallerEncoder serializes an EntryCaller to a primitive type.\n//"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(Duration).String","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*DurationEncoder).UnmarshalText","signature":"func (e *DurationEncoder) UnmarshalText(text []byte) error","start_line":259,"end_line":271,"code":"func (e *DurationEncoder) UnmarshalText(text []byte) error {\n\n\tswitch string(text) {\n\tcase \"string\":\n\t\t*e = StringDurationEncoder\n\tcase \"nanos\":\n\t\t*e = NanosDurationEncoder\n\tcase \"ms\":\n\t\t*e = MillisDurationEncoder\n\tdefault:\n\t\t*e = SecondsDurationEncoder\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":239,"end_line":258,"code":"// nanoseconds elapsed.\nfunc NanosDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(int64(d))\n}\n\n// MillisDurationEncoder serializes a time.Duration to an integer number of\n// milliseconds elapsed.\nfunc MillisDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendInt64(d.Nanoseconds() / 1e6)\n}\n\n// StringDurationEncoder serializes a time.Duration using its built-in String\n// method.\nfunc StringDurationEncoder(d time.Duration, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(d.String())\n}\n\n// UnmarshalText unmarshals text to a DurationEncoder. \"string\" is unmarshaled\n// to StringDurationEncoder, and anything else is unmarshaled to\n// NanosDurationEncoder."},{"path":"zapcore/encoder.go","start_line":272,"end_line":291,"code":"\n// A CallerEncoder serializes an EntryCaller to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype CallerEncoder func(EntryCaller, PrimitiveArrayEncoder)\n\n// FullCallerEncoder serializes a caller in /full/path/to/package/file:line\n// format.\nfunc FullCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.String())\n}\n\n// ShortCallerEncoder serializes a caller in package/file:line format, trimming\n// all but the final directory from the full path.\nfunc ShortCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.TrimmedPath())\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.77},"call_graph":{"callees":null,"callers":[{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"FullCallerEncoder","signature":"func FullCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder)","start_line":281,"end_line":284,"code":"func FullCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\n\t\n\tenc.AppendString(caller.String())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":261,"end_line":280,"code":"\tcase \"string\":\n\t\t*e = StringDurationEncoder\n\tcase \"nanos\":\n\t\t*e = NanosDurationEncoder\n\tcase \"ms\":\n\t\t*e = MillisDurationEncoder\n\tdefault:\n\t\t*e = SecondsDurationEncoder\n\t}\n\treturn nil\n}\n\n// A CallerEncoder serializes an EntryCaller to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype CallerEncoder func(EntryCaller, PrimitiveArrayEncoder)\n\n// FullCallerEncoder serializes a caller in /full/path/to/package/file:line\n// format."},{"path":"zapcore/encoder.go","start_line":285,"end_line":304,"code":"\n// ShortCallerEncoder serializes a caller in package/file:line format, trimming\n// all but the final directory from the full path.\nfunc ShortCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.TrimmedPath())\n}\n\n// UnmarshalText unmarshals text to a CallerEncoder. \"full\" is unmarshaled to\n// FullCallerEncoder and anything else is unmarshaled to ShortCallerEncoder.\nfunc (e *CallerEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullCallerEncoder\n\tdefault:\n\t\t*e = ShortCallerEncoder\n\t}\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(EntryCaller).String","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"ShortCallerEncoder","signature":"func ShortCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder)","start_line":288,"end_line":291,"code":"func ShortCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\n\t\n\tenc.AppendString(caller.TrimmedPath())\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":268,"end_line":287,"code":"\t\t*e = SecondsDurationEncoder\n\t}\n\treturn nil\n}\n\n// A CallerEncoder serializes an EntryCaller to a primitive type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype CallerEncoder func(EntryCaller, PrimitiveArrayEncoder)\n\n// FullCallerEncoder serializes a caller in /full/path/to/package/file:line\n// format.\nfunc FullCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.String())\n}\n\n// ShortCallerEncoder serializes a caller in package/file:line format, trimming\n// all but the final directory from the full path."},{"path":"zapcore/encoder.go","start_line":292,"end_line":311,"code":"\n// UnmarshalText unmarshals text to a CallerEncoder. \"full\" is unmarshaled to\n// FullCallerEncoder and anything else is unmarshaled to ShortCallerEncoder.\nfunc (e *CallerEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullCallerEncoder\n\tdefault:\n\t\t*e = ShortCallerEncoder\n\t}\n\treturn nil\n}\n\n// A NameEncoder serializes a period-separated logger name to a primitive\n// type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype NameEncoder func(string, PrimitiveArrayEncoder)\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*CallerEncoder).UnmarshalText","signature":"func (e *CallerEncoder) UnmarshalText(text []byte) error","start_line":295,"end_line":303,"code":"func (e *CallerEncoder) UnmarshalText(text []byte) error {\n\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullCallerEncoder\n\tdefault:\n\t\t*e = ShortCallerEncoder\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":275,"end_line":294,"code":"// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype CallerEncoder func(EntryCaller, PrimitiveArrayEncoder)\n\n// FullCallerEncoder serializes a caller in /full/path/to/package/file:line\n// format.\nfunc FullCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.String())\n}\n\n// ShortCallerEncoder serializes a caller in package/file:line format, trimming\n// all but the final directory from the full path.\nfunc ShortCallerEncoder(caller EntryCaller, enc PrimitiveArrayEncoder) {\n\t// TODO: consider using a byte-oriented API to save an allocation.\n\tenc.AppendString(caller.TrimmedPath())\n}\n\n// UnmarshalText unmarshals text to a CallerEncoder. \"full\" is unmarshaled to\n// FullCallerEncoder and anything else is unmarshaled to ShortCallerEncoder."},{"path":"zapcore/encoder.go","start_line":304,"end_line":323,"code":"\n// A NameEncoder serializes a period-separated logger name to a primitive\n// type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype NameEncoder func(string, PrimitiveArrayEncoder)\n\n// FullNameEncoder serializes the logger name as-is.\nfunc FullNameEncoder(loggerName string, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(loggerName)\n}\n\n// UnmarshalText unmarshals text to a NameEncoder. Currently, everything is\n// unmarshaled to FullNameEncoder.\nfunc (e *NameEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullNameEncoder\n\tdefault:"}],"selection":{"visibility":"exported","reason":"encoder","score":0.77},"call_graph":{"callees":null,"callers":[{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"FullNameEncoder","signature":"func FullNameEncoder(loggerName string, enc PrimitiveArrayEncoder)","start_line":313,"end_line":315,"code":"func FullNameEncoder(loggerName string, enc PrimitiveArrayEncoder) {\n\n\tenc.AppendString(loggerName)\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":293,"end_line":312,"code":"// UnmarshalText unmarshals text to a CallerEncoder. \"full\" is unmarshaled to\n// FullCallerEncoder and anything else is unmarshaled to ShortCallerEncoder.\nfunc (e *CallerEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullCallerEncoder\n\tdefault:\n\t\t*e = ShortCallerEncoder\n\t}\n\treturn nil\n}\n\n// A NameEncoder serializes a period-separated logger name to a primitive\n// type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype NameEncoder func(string, PrimitiveArrayEncoder)\n\n// FullNameEncoder serializes the logger name as-is."},{"path":"zapcore/encoder.go","start_line":316,"end_line":335,"code":"\n// UnmarshalText unmarshals text to a NameEncoder. Currently, everything is\n// unmarshaled to FullNameEncoder.\nfunc (e *NameEncoder) UnmarshalText(text []byte) error {\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullNameEncoder\n\tdefault:\n\t\t*e = FullNameEncoder\n\t}\n\treturn nil\n}\n\n// An EncoderConfig allows users to configure the concrete encoders supplied by\n// zapcore.\ntype EncoderConfig struct {\n\t// Set the keys used for each log entry. If any key is empty, that portion\n\t// of the entry is omitted.\n\tMessageKey     string `json:\"messageKey\" yaml:\"messageKey\"`\n\tLevelKey       string `json:\"levelKey\" yaml:\"levelKey\"`"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendString","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/encoder.go","symbol":"(*NameEncoder).UnmarshalText","signature":"func (e *NameEncoder) UnmarshalText(text []byte) error","start_line":319,"end_line":327,"code":"func (e *NameEncoder) UnmarshalText(text []byte) error {\n\n\tswitch string(text) {\n\tcase \"full\":\n\t\t*e = FullNameEncoder\n\tdefault:\n\t\t*e = FullNameEncoder\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/encoder.go","start_line":299,"end_line":318,"code":"\tdefault:\n\t\t*e = ShortCallerEncoder\n\t}\n\treturn nil\n}\n\n// A NameEncoder serializes a period-separated logger name to a primitive\n// type.\n//\n// This function must make exactly one call\n// to a PrimitiveArrayEncoder's Append* method.\ntype NameEncoder func(string, PrimitiveArrayEncoder)\n\n// FullNameEncoder serializes the logger name as-is.\nfunc FullNameEncoder(loggerName string, enc PrimitiveArrayEncoder) {\n\tenc.AppendString(loggerName)\n}\n\n// UnmarshalText unmarshals text to a NameEncoder. Currently, everything is\n// unmarshaled to FullNameEncoder."},{"path":"zapcore/encoder.go","start_line":328,"end_line":347,"code":"\n// An EncoderConfig allows users to configure the concrete encoders supplied by\n// zapcore.\ntype EncoderConfig struct {\n\t// Set the keys used for each log entry. If any key is empty, that portion\n\t// of the entry is omitted.\n\tMessageKey     string `json:\"messageKey\" yaml:\"messageKey\"`\n\tLevelKey       string `json:\"levelKey\" yaml:\"levelKey\"`\n\tTimeKey        string `json:\"timeKey\" yaml:\"timeKey\"`\n\tNameKey        string `json:\"nameKey\" yaml:\"nameKey\"`\n\tCallerKey      string `json:\"callerKey\" yaml:\"callerKey\"`\n\tFunctionKey    string `json:\"functionKey\" yaml:\"functionKey\"`\n\tStacktraceKey  string `json:\"stacktraceKey\" yaml:\"stacktraceKey\"`\n\tSkipLineEnding bool   `json:\"skipLineEnding\" yaml:\"skipLineEnding\"`\n\tLineEnding     string `json:\"lineEnding\" yaml:\"lineEnding\"`\n\t// Configure the primitive representations of common complex types. For\n\t// example, some users may want all time.Times serialized as floating-point\n\t// seconds since epoch, while others may prefer ISO8601 strings.\n\tEncodeLevel    LevelEncoder    `json:\"levelEncoder\" yaml:\"levelEncoder\"`\n\tEncodeTime     TimeEncoder     `json:\"timeEncoder\" yaml:\"timeEncoder\"`"}],"selection":{"visibility":"exported","reason":"encoder","score":0.77},"call_graph":{"callees":null,"callers":[{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"getCheckedEntry","signature":"func getCheckedEntry() *CheckedEntry","start_line":42,"end_line":46,"code":"func getCheckedEntry() *CheckedEntry {\n\n\tce := _cePool.Get()\n\tce.reset()\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":22,"end_line":41,"code":"\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"go.uber.org/multierr\"\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/exit\"\n\t\"go.uber.org/zap/internal/pool\"\n)\n\nvar _cePool = pool.New(func() *CheckedEntry {\n\t// Pre-allocate some space for cores.\n\treturn \u0026CheckedEntry{\n\t\tcores: make([]Core, 4),\n\t}\n})\n"},{"path":"zapcore/entry.go","start_line":47,"end_line":66,"code":"\nfunc putCheckedEntry(ce *CheckedEntry) {\n\tif ce == nil {\n\t\treturn\n\t}\n\t_cePool.Put(ce)\n}\n\n// NewEntryCaller makes an EntryCaller from the return signature of\n// runtime.Caller.\nfunc NewEntryCaller(pc uintptr, file string, line int, ok bool) EntryCaller {\n\tif !ok {\n\t\treturn EntryCaller{}\n\t}\n\treturn EntryCaller{\n\t\tPC:      pc,\n\t\tFile:    file,\n\t\tLine:    line,\n\t\tDefined: true,\n\t}"}],"selection":{"visibility":"unexported","reason":"core","score":0.51},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).reset","path":"zapcore/entry.go"},{"symbol":"(*Pool).Get[*go.uber.org/zap/zapcore.CheckedEntry]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*CheckedEntry).AddCore","path":"zapcore/entry.go"},{"symbol":"(*CheckedEntry).After","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"putCheckedEntry","signature":"func putCheckedEntry(ce *CheckedEntry)","start_line":48,"end_line":53,"code":"func putCheckedEntry(ce *CheckedEntry) {\n\n\tif ce == nil {\n\t\treturn\n\t}\n\t_cePool.Put(ce)\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":28,"end_line":47,"code":"\n\t\"go.uber.org/multierr\"\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/exit\"\n\t\"go.uber.org/zap/internal/pool\"\n)\n\nvar _cePool = pool.New(func() *CheckedEntry {\n\t// Pre-allocate some space for cores.\n\treturn \u0026CheckedEntry{\n\t\tcores: make([]Core, 4),\n\t}\n})\n\nfunc getCheckedEntry() *CheckedEntry {\n\tce := _cePool.Get()\n\tce.reset()\n\treturn ce\n}\n"},{"path":"zapcore/entry.go","start_line":54,"end_line":73,"code":"\n// NewEntryCaller makes an EntryCaller from the return signature of\n// runtime.Caller.\nfunc NewEntryCaller(pc uintptr, file string, line int, ok bool) EntryCaller {\n\tif !ok {\n\t\treturn EntryCaller{}\n\t}\n\treturn EntryCaller{\n\t\tPC:      pc,\n\t\tFile:    file,\n\t\tLine:    line,\n\t\tDefined: true,\n\t}\n}\n\n// EntryCaller represents the caller of a logging function.\ntype EntryCaller struct {\n\tDefined  bool\n\tPC       uintptr\n\tFile     string"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"(*Pool).Put[*go.uber.org/zap/zapcore.CheckedEntry]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"NewEntryCaller","signature":"func NewEntryCaller(pc uintptr, file string, line int, ok bool) EntryCaller","start_line":57,"end_line":67,"code":"func NewEntryCaller(pc uintptr, file string, line int, ok bool) EntryCaller {\n\n\tif !ok {\n\t\treturn EntryCaller{}\n\t}\n\treturn EntryCaller{\n\t\tPC:      pc,\n\t\tFile:    file,\n\t\tLine:    line,\n\t\tDefined: true,\n\t}\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":37,"end_line":56,"code":"\treturn \u0026CheckedEntry{\n\t\tcores: make([]Core, 4),\n\t}\n})\n\nfunc getCheckedEntry() *CheckedEntry {\n\tce := _cePool.Get()\n\tce.reset()\n\treturn ce\n}\n\nfunc putCheckedEntry(ce *CheckedEntry) {\n\tif ce == nil {\n\t\treturn\n\t}\n\t_cePool.Put(ce)\n}\n\n// NewEntryCaller makes an EntryCaller from the return signature of\n// runtime.Caller."},{"path":"zapcore/entry.go","start_line":68,"end_line":87,"code":"\n// EntryCaller represents the caller of a logging function.\ntype EntryCaller struct {\n\tDefined  bool\n\tPC       uintptr\n\tFile     string\n\tLine     int\n\tFunction string\n}\n\n// String returns the full path and line number of the caller.\nfunc (ec EntryCaller) String() string {\n\treturn ec.FullPath()\n}\n\n// FullPath returns a /full/path/to/package/file:line description of the\n// caller.\nfunc (ec EntryCaller) FullPath() string {\n\tif !ec.Defined {\n\t\treturn \"undefined\""}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(EntryCaller).String","signature":"func (ec EntryCaller) String() string","start_line":79,"end_line":81,"code":"func (ec EntryCaller) String() string {\n\n\treturn ec.FullPath()\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":59,"end_line":78,"code":"\t\treturn EntryCaller{}\n\t}\n\treturn EntryCaller{\n\t\tPC:      pc,\n\t\tFile:    file,\n\t\tLine:    line,\n\t\tDefined: true,\n\t}\n}\n\n// EntryCaller represents the caller of a logging function.\ntype EntryCaller struct {\n\tDefined  bool\n\tPC       uintptr\n\tFile     string\n\tLine     int\n\tFunction string\n}\n\n// String returns the full path and line number of the caller."},{"path":"zapcore/entry.go","start_line":82,"end_line":101,"code":"\n// FullPath returns a /full/path/to/package/file:line description of the\n// caller.\nfunc (ec EntryCaller) FullPath() string {\n\tif !ec.Defined {\n\t\treturn \"undefined\"\n\t}\n\tbuf := bufferpool.Get()\n\tbuf.AppendString(ec.File)\n\tbuf.AppendByte(':')\n\tbuf.AppendInt(int64(ec.Line))\n\tcaller := buf.String()\n\tbuf.Free()\n\treturn caller\n}\n\n// TrimmedPath returns a package/file:line description of the caller,\n// preserving only the leaf directory name and file name.\nfunc (ec EntryCaller) TrimmedPath() string {\n\tif !ec.Defined {"}],"selection":{"visibility":"exported","reason":"core","score":0.68},"call_graph":{"callees":[{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*EntryCaller).String","path":"zapcore/entry.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*pp).handleMethods","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"(http2FrameWriteRequest).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"FullCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"contextName","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"stringify","path":"../../../../usr/local/go/src/context/context.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(EntryCaller).FullPath","signature":"func (ec EntryCaller) FullPath() string","start_line":85,"end_line":96,"code":"func (ec EntryCaller) FullPath() string {\n\n\tif !ec.Defined {\n\t\treturn \"undefined\"\n\t}\n\tbuf := bufferpool.Get()\n\tbuf.AppendString(ec.File)\n\tbuf.AppendByte(':')\n\tbuf.AppendInt(int64(ec.Line))\n\tcaller := buf.String()\n\tbuf.Free()\n\treturn caller\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":65,"end_line":84,"code":"\t\tDefined: true,\n\t}\n}\n\n// EntryCaller represents the caller of a logging function.\ntype EntryCaller struct {\n\tDefined  bool\n\tPC       uintptr\n\tFile     string\n\tLine     int\n\tFunction string\n}\n\n// String returns the full path and line number of the caller.\nfunc (ec EntryCaller) String() string {\n\treturn ec.FullPath()\n}\n\n// FullPath returns a /full/path/to/package/file:line description of the\n// caller."},{"path":"zapcore/entry.go","start_line":97,"end_line":116,"code":"\n// TrimmedPath returns a package/file:line description of the caller,\n// preserving only the leaf directory name and file name.\nfunc (ec EntryCaller) TrimmedPath() string {\n\tif !ec.Defined {\n\t\treturn \"undefined\"\n\t}\n\t// nb. To make sure we trim the path correctly on Windows too, we\n\t// counter-intuitively need to use '/' and *not* os.PathSeparator here,\n\t// because the path given originates from Go stdlib, specifically\n\t// runtime.Caller() which (as of Mar/17) returns forward slashes even on\n\t// Windows.\n\t//\n\t// See https://github.com/golang/go/issues/3335\n\t// and https://github.com/golang/go/issues/18151\n\t//\n\t// for discussion on the issue on Go side.\n\t//\n\t// Find the last separator.\n\t//"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendInt","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Buffer).String","path":"buffer/buffer.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"}],"callers":[{"symbol":"(*EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).String","path":"zapcore/entry.go"},{"symbol":"(EntryCaller).TrimmedPath","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(EntryCaller).TrimmedPath","signature":"func (ec EntryCaller) TrimmedPath() string","start_line":100,"end_line":134,"code":"func (ec EntryCaller) TrimmedPath() string {\n\n\tif !ec.Defined {\n\t\treturn \"undefined\"\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tidx := strings.LastIndexByte(ec.File, '/')\n\tif idx == -1 {\n\t\treturn ec.FullPath()\n\t}\n\t\n\tidx = strings.LastIndexByte(ec.File[:idx], '/')\n\tif idx == -1 {\n\t\treturn ec.FullPath()\n\t}\n\tbuf := bufferpool.Get()\n\t\n\tbuf.AppendString(ec.File[idx+1:])\n\tbuf.AppendByte(':')\n\tbuf.AppendInt(int64(ec.Line))\n\tcaller := buf.String()\n\tbuf.Free()\n\treturn caller\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":80,"end_line":99,"code":"\treturn ec.FullPath()\n}\n\n// FullPath returns a /full/path/to/package/file:line description of the\n// caller.\nfunc (ec EntryCaller) FullPath() string {\n\tif !ec.Defined {\n\t\treturn \"undefined\"\n\t}\n\tbuf := bufferpool.Get()\n\tbuf.AppendString(ec.File)\n\tbuf.AppendByte(':')\n\tbuf.AppendInt(int64(ec.Line))\n\tcaller := buf.String()\n\tbuf.Free()\n\treturn caller\n}\n\n// TrimmedPath returns a package/file:line description of the caller,\n// preserving only the leaf directory name and file name."},{"path":"zapcore/entry.go","start_line":135,"end_line":154,"code":"\n// An Entry represents a complete log message. The entry's structured context\n// is already serialized, but the log level, time, message, and call site\n// information are available for inspection and modification. Any fields left\n// empty will be omitted when encoding.\n//\n// Entries are pooled, so any functions that accept them MUST be careful not to\n// retain references to them.\ntype Entry struct {\n\tLevel      Level\n\tTime       time.Time\n\tLoggerName string\n\tMessage    string\n\tCaller     EntryCaller\n\tStack      string\n}\n\n// CheckWriteHook is a custom action that may be executed after an entry is\n// written.\n//"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendInt","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Buffer).String","path":"buffer/buffer.go"},{"symbol":"(EntryCaller).FullPath","path":"zapcore/entry.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"LastIndexByte","path":"../../../../usr/local/go/src/strings/strings.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"}],"callers":[{"symbol":"(*EntryCaller).TrimmedPath","path":"zapcore/entry.go"},{"symbol":"ShortCallerEncoder","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(CheckWriteAction).OnWrite","signature":"func (a CheckWriteAction) OnWrite(ce *CheckedEntry, _ []Field)","start_line":191,"end_line":200,"code":"func (a CheckWriteAction) OnWrite(ce *CheckedEntry, _ []Field) {\n\n\tswitch a {\n\tcase WriteThenGoexit:\n\t\truntime.Goexit()\n\tcase WriteThenPanic:\n\t\tpanic(ce.Message)\n\tcase WriteThenFatal:\n\t\texit.With(1)\n\t}\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":171,"end_line":190,"code":"}\n\n// CheckWriteAction indicates what action to take after a log entry is\n// processed. Actions are ordered in increasing severity.\ntype CheckWriteAction uint8\n\nconst (\n\t// WriteThenNoop indicates that nothing special needs to be done. It's the\n\t// default behavior.\n\tWriteThenNoop CheckWriteAction = iota\n\t// WriteThenGoexit runs runtime.Goexit after Write.\n\tWriteThenGoexit\n\t// WriteThenPanic causes a panic after Write.\n\tWriteThenPanic\n\t// WriteThenFatal causes an os.Exit(1) after Write.\n\tWriteThenFatal\n)\n\n// OnWrite implements the OnWrite method to keep CheckWriteAction compatible\n// with the new CheckWriteHook interface which deprecates CheckWriteAction."},{"path":"zapcore/entry.go","start_line":201,"end_line":220,"code":"\nvar _ CheckWriteHook = CheckWriteAction(0)\n\n// CheckedEntry is an Entry together with a collection of Cores that have\n// already agreed to log it.\n//\n// CheckedEntry references should be created by calling AddCore or After on a\n// nil *CheckedEntry. References are returned to a pool after Write, and MUST\n// NOT be retained after calling their Write method.\ntype CheckedEntry struct {\n\tEntry\n\tErrorOutput WriteSyncer\n\tdirty       bool // best-effort detection of pool misuse\n\tafter       CheckWriteHook\n\tcores       []Core\n}\n\nfunc (ce *CheckedEntry) reset() {\n\tce.Entry = Entry{}\n\tce.ErrorOutput = nil"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"Goexit","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"With","path":"internal/exit/exit.go"}],"callers":[{"symbol":"(*CheckWriteAction).OnWrite","path":"zapcore/entry.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(*CheckedEntry).reset","signature":"func (ce *CheckedEntry) reset()","start_line":218,"end_line":228,"code":"func (ce *CheckedEntry) reset() {\n\n\tce.Entry = Entry{}\n\tce.ErrorOutput = nil\n\tce.dirty = false\n\tce.after = nil\n\tfor i := range ce.cores {\n\t\t\n\t\tce.cores[i] = nil\n\t}\n\tce.cores = ce.cores[:0]\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":198,"end_line":217,"code":"\t\texit.With(1)\n\t}\n}\n\nvar _ CheckWriteHook = CheckWriteAction(0)\n\n// CheckedEntry is an Entry together with a collection of Cores that have\n// already agreed to log it.\n//\n// CheckedEntry references should be created by calling AddCore or After on a\n// nil *CheckedEntry. References are returned to a pool after Write, and MUST\n// NOT be retained after calling their Write method.\ntype CheckedEntry struct {\n\tEntry\n\tErrorOutput WriteSyncer\n\tdirty       bool // best-effort detection of pool misuse\n\tafter       CheckWriteHook\n\tcores       []Core\n}\n"},{"path":"zapcore/entry.go","start_line":229,"end_line":248,"code":"\n// Write writes the entry to the stored Cores, returns any errors, and returns\n// the CheckedEntry reference to a pool for immediate re-use. Finally, it\n// executes any required CheckWriteAction.\nfunc (ce *CheckedEntry) Write(fields ...Field) {\n\tif ce == nil {\n\t\treturn\n\t}\n\n\tif ce.dirty {\n\t\tif ce.ErrorOutput != nil {\n\t\t\t// Make a best effort to detect unsafe re-use of this CheckedEntry.\n\t\t\t// If the entry is dirty, log an internal error; because the\n\t\t\t// CheckedEntry is being used after it was returned to the pool,\n\t\t\t// the message may be an amalgamation from multiple call sites.\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tce.ErrorOutput,\n\t\t\t\t\"%v Unsafe CheckedEntry re-use near Entry %+v.\\n\",\n\t\t\t\tce.Time,\n\t\t\t\tce.Entry,"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":null,"callers":[{"symbol":"getCheckedEntry","path":"zapcore/entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(*CheckedEntry).Write","signature":"func (ce *CheckedEntry) Write(fields ...Field)","start_line":233,"end_line":275,"code":"func (ce *CheckedEntry) Write(fields ...Field) {\n\n\tif ce == nil {\n\t\treturn\n\t}\n\n\tif ce.dirty {\n\t\tif ce.ErrorOutput != nil {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tce.ErrorOutput,\n\t\t\t\t\"%v Unsafe CheckedEntry re-use near Entry %+v.\\n\",\n\t\t\t\tce.Time,\n\t\t\t\tce.Entry,\n\t\t\t)\n\t\t\t_ = ce.ErrorOutput.Sync() \n\t\t}\n\t\treturn\n\t}\n\tce.dirty = true\n\n\tvar err error\n\tfor i := range ce.cores {\n\t\terr = multierr.Append(err, ce.cores[i].Write(ce.Entry, fields))\n\t}\n\tif err != nil \u0026\u0026 ce.ErrorOutput != nil {\n\t\t_, _ = fmt.Fprintf(\n\t\t\tce.ErrorOutput,\n\t\t\t\"%v write error: %v\\n\",\n\t\t\tce.Time,\n\t\t\terr,\n\t\t)\n\t\t_ = ce.ErrorOutput.Sync() \n\t}\n\n\thook := ce.after\n\tif hook != nil {\n\t\thook.OnWrite(ce, fields)\n\t}\n\tputCheckedEntry(ce)\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":213,"end_line":232,"code":"\tdirty       bool // best-effort detection of pool misuse\n\tafter       CheckWriteHook\n\tcores       []Core\n}\n\nfunc (ce *CheckedEntry) reset() {\n\tce.Entry = Entry{}\n\tce.ErrorOutput = nil\n\tce.dirty = false\n\tce.after = nil\n\tfor i := range ce.cores {\n\t\t// don't keep references to cores\n\t\tce.cores[i] = nil\n\t}\n\tce.cores = ce.cores[:0]\n}\n\n// Write writes the entry to the stored Cores, returns any errors, and returns\n// the CheckedEntry reference to a pool for immediate re-use. Finally, it\n// executes any required CheckWriteAction."},{"path":"zapcore/entry.go","start_line":276,"end_line":295,"code":"\n// AddCore adds a Core that has agreed to log this CheckedEntry. It's intended to be\n// used by Core.Check implementations, and is safe to call on nil CheckedEntry\n// references.\nfunc (ce *CheckedEntry) AddCore(ent Entry, core Core) *CheckedEntry {\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.cores = append(ce.cores, core)\n\treturn ce\n}\n\n// Should sets this CheckedEntry's CheckWriteAction, which controls whether a\n// Core will panic or fatal after writing this log entry. Like AddCore, it's\n// safe to call on nil CheckedEntry references.\n//\n// Deprecated: Use [CheckedEntry.After] instead.\nfunc (ce *CheckedEntry) Should(ent Entry, should CheckWriteAction) *CheckedEntry {\n\treturn ce.After(ent, should)"}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*File).Sync","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Write","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Write","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(CheckWriteAction).OnWrite","path":"zapcore/entry.go"},{"symbol":"(TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(nopCore).Write","path":"zapcore/core.go"},{"symbol":"(writerWrapper).Sync","path":"zapcore/write_syncer.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"putCheckedEntry","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*Logger).DPanic","path":"logger.go"},{"symbol":"(*Logger).Debug","path":"logger.go"},{"symbol":"(*Logger).Error","path":"logger.go"},{"symbol":"(*Logger).Fatal","path":"logger.go"},{"symbol":"(*Logger).Info","path":"logger.go"},{"symbol":"(*Logger).Log","path":"logger.go"},{"symbol":"(*Logger).Panic","path":"logger.go"},{"symbol":"(*Logger).Warn","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).log","path":"zapio/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(*CheckedEntry).AddCore","signature":"func (ce *CheckedEntry) AddCore(ent Entry, core Core) *CheckedEntry","start_line":280,"end_line":287,"code":"func (ce *CheckedEntry) AddCore(ent Entry, core Core) *CheckedEntry {\n\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.cores = append(ce.cores, core)\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":260,"end_line":279,"code":"\tif err != nil \u0026\u0026 ce.ErrorOutput != nil {\n\t\t_, _ = fmt.Fprintf(\n\t\t\tce.ErrorOutput,\n\t\t\t\"%v write error: %v\\n\",\n\t\t\tce.Time,\n\t\t\terr,\n\t\t)\n\t\t_ = ce.ErrorOutput.Sync() // ignore error\n\t}\n\n\thook := ce.after\n\tif hook != nil {\n\t\thook.OnWrite(ce, fields)\n\t}\n\tputCheckedEntry(ce)\n}\n\n// AddCore adds a Core that has agreed to log this CheckedEntry. It's intended to be\n// used by Core.Check implementations, and is safe to call on nil CheckedEntry\n// references."},{"path":"zapcore/entry.go","start_line":288,"end_line":307,"code":"\n// Should sets this CheckedEntry's CheckWriteAction, which controls whether a\n// Core will panic or fatal after writing this log entry. Like AddCore, it's\n// safe to call on nil CheckedEntry references.\n//\n// Deprecated: Use [CheckedEntry.After] instead.\nfunc (ce *CheckedEntry) Should(ent Entry, should CheckWriteAction) *CheckedEntry {\n\treturn ce.After(ent, should)\n}\n\n// After sets this CheckEntry's CheckWriteHook, which will be called after this\n// log entry has been written. It's safe to call this on nil CheckedEntry\n// references.\nfunc (ce *CheckedEntry) After(ent Entry, hook CheckWriteHook) *CheckedEntry {\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.after = hook\n\treturn ce"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":[{"symbol":"getCheckedEntry","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(*CheckedEntry).Should","signature":"func (ce *CheckedEntry) Should(ent Entry, should CheckWriteAction) *CheckedEntry","start_line":294,"end_line":296,"code":"func (ce *CheckedEntry) Should(ent Entry, should CheckWriteAction) *CheckedEntry {\n\n\treturn ce.After(ent, should)\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":274,"end_line":293,"code":"\tputCheckedEntry(ce)\n}\n\n// AddCore adds a Core that has agreed to log this CheckedEntry. It's intended to be\n// used by Core.Check implementations, and is safe to call on nil CheckedEntry\n// references.\nfunc (ce *CheckedEntry) AddCore(ent Entry, core Core) *CheckedEntry {\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.cores = append(ce.cores, core)\n\treturn ce\n}\n\n// Should sets this CheckedEntry's CheckWriteAction, which controls whether a\n// Core will panic or fatal after writing this log entry. Like AddCore, it's\n// safe to call on nil CheckedEntry references.\n//\n// Deprecated: Use [CheckedEntry.After] instead."},{"path":"zapcore/entry.go","start_line":297,"end_line":309,"code":"\n// After sets this CheckEntry's CheckWriteHook, which will be called after this\n// log entry has been written. It's safe to call this on nil CheckedEntry\n// references.\nfunc (ce *CheckedEntry) After(ent Entry, hook CheckWriteHook) *CheckedEntry {\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.after = hook\n\treturn ce\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.6},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).After","path":"zapcore/entry.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/entry.go","symbol":"(*CheckedEntry).After","signature":"func (ce *CheckedEntry) After(ent Entry, hook CheckWriteHook) *CheckedEntry","start_line":301,"end_line":308,"code":"func (ce *CheckedEntry) After(ent Entry, hook CheckWriteHook) *CheckedEntry {\n\n\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.after = hook\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/entry.go","start_line":281,"end_line":300,"code":"\tif ce == nil {\n\t\tce = getCheckedEntry()\n\t\tce.Entry = ent\n\t}\n\tce.cores = append(ce.cores, core)\n\treturn ce\n}\n\n// Should sets this CheckedEntry's CheckWriteAction, which controls whether a\n// Core will panic or fatal after writing this log entry. Like AddCore, it's\n// safe to call on nil CheckedEntry references.\n//\n// Deprecated: Use [CheckedEntry.After] instead.\nfunc (ce *CheckedEntry) Should(ent Entry, should CheckWriteAction) *CheckedEntry {\n\treturn ce.After(ent, should)\n}\n\n// After sets this CheckEntry's CheckWriteHook, which will be called after this\n// log entry has been written. It's safe to call this on nil CheckedEntry\n// references."}],"selection":{"visibility":"exported","reason":"core","score":0.72},"call_graph":{"callees":[{"symbol":"getCheckedEntry","path":"zapcore/entry.go"}],"callers":[{"symbol":"(*CheckedEntry).Should","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"encodeError","signature":"func encodeError(key string, err error, enc ObjectEncoder) (retErr error)","start_line":47,"end_line":79,"code":"func encodeError(key string, err error, enc ObjectEncoder) (retErr error) {\n\n\t\n\t\n\tdefer func() {\n\t\tif rerr := recover(); rerr != nil {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif v := reflect.ValueOf(err); v.Kind() == reflect.Ptr \u0026\u0026 v.IsNil() {\n\t\t\t\tenc.AddString(key, \"\u003cnil\u003e\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tretErr = fmt.Errorf(\"PANIC=%v\", rerr)\n\t\t}\n\t}()\n\n\tbasic := err.Error()\n\tenc.AddString(key, basic)\n\n\tswitch e := err.(type) {\n\tcase errorGroup:\n\t\treturn enc.AddArray(key+\"Causes\", errArray(e.Errors()))\n\tcase fmt.Formatter:\n\t\tverbose := fmt.Sprintf(\"%+v\", e)\n\t\tif verbose != basic {\n\t\t\t\n\t\t\t\n\t\t\tenc.AddString(key+\"Verbose\", verbose)\n\t\t}\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":27,"end_line":46,"code":"\t\"go.uber.org/zap/internal/pool\"\n)\n\n// Encodes the given error into fields of an object. A field with the given\n// name is added for the error message.\n//\n// If the error implements fmt.Formatter, a field with the name ${key}Verbose\n// is also added with the full verbose error message.\n//\n// Finally, if the error implements errorGroup (from go.uber.org/multierr) or\n// causer (from github.com/pkg/errors), a ${key}Causes field is added with an\n// array of objects containing the errors this error was comprised of.\n//\n//\t{\n//\t  \"error\": err.Error(),\n//\t  \"errorVerbose\": fmt.Sprintf(\"%+v\", err),\n//\t  \"errorCauses\": [\n//\t    ...\n//\t  ],\n//\t}"},{"path":"zapcore/error.go","start_line":80,"end_line":99,"code":"\ntype errorGroup interface {\n\t// Provides read-only access to the underlying list of errors, preferably\n\t// without causing any allocs.\n\tErrors() []error\n}\n\n// Note that errArray and errArrayElem are very similar to the version\n// implemented in the top-level error.go file. We can't re-use this because\n// that would require exporting errArray as part of the zapcore API.\n\n// Encodes a list of errors using the standard error encoding logic.\ntype errArray []error\n\nfunc (errs errArray) MarshalLogArray(arr ArrayEncoder) error {\n\tfor i := range errs {\n\t\tif errs[i] == nil {\n\t\t\tcontinue\n\t\t}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.51},"call_graph":{"callees":[{"symbol":"(*DeadlineExceededError).Error","path":"../../../../usr/local/go/src/internal/poll/fd.go"},{"symbol":"(*Error).Error","path":"../../../../usr/local/go/src/net/url/url.go"},{"symbol":"(*OpError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*ReadError).Error","path":"../../../../usr/local/go/src/compress/flate/inflate.go"},{"symbol":"(*SyntaxError).Error","path":"../../../../usr/local/go/src/encoding/json/scanner.go"},{"symbol":"(*errUnmarshalChaCha8).Error","path":"../../../../usr/local/go/src/internal/chacha8rand/chacha8.go"},{"symbol":"(*errorString).Error","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"(*jsonEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*multiError).Error","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*nestedError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/dns/dnsmessage/message.go"},{"symbol":"(*temporaryError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*wrapError).Error","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"(*wrapErrors).Error","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"(ConstraintViolationError).Error","path":"../../../../usr/local/go/src/crypto/x509/x509.go"},{"symbol":"(ErrNaN).Error","path":"../../../../usr/local/go/src/math/big/float.go"},{"symbol":"(InvalidIndexError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/hpack.go"},{"symbol":"(KeySizeError).Error","path":"../../../../usr/local/go/src/crypto/aes/aes.go"},{"symbol":"(StructuralError).Error","path":"../../../../usr/local/go/src/encoding/asn1/asn1.go"},{"symbol":"(UnhandledCriticalExtension).Error","path":"../../../../usr/local/go/src/crypto/x509/x509.go"},{"symbol":"(UnknownNetworkError).Error","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(http2GoAwayError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(http2duplicatePseudoHeaderError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(http2goAwayFlowError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(http2pseudoHeaderError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(labelError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/idna/idna10.0.0.go"},{"symbol":"(runeError).Error","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/idna/idna10.0.0.go"},{"symbol":"(synctestDeadlockError).Error","path":"../../../../usr/local/go/src/runtime/synctest.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"encodeError$1","path":"zapcore/error.go"}],"callers":[{"symbol":"(*errArrayElem).MarshalLogObject","path":"zapcore/error.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"(errArray).MarshalLogArray","signature":"func (errs errArray) MarshalLogArray(arr ArrayEncoder) error","start_line":94,"end_line":108,"code":"func (errs errArray) MarshalLogArray(arr ArrayEncoder) error {\n\n\tfor i := range errs {\n\t\tif errs[i] == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tel := newErrArrayElem(errs[i])\n\t\terr := arr.AppendObject(el)\n\t\tel.Free()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":74,"end_line":93,"code":"\t\t\t// github.com/pkg/errors.\n\t\t\tenc.AddString(key+\"Verbose\", verbose)\n\t\t}\n\t}\n\treturn nil\n}\n\ntype errorGroup interface {\n\t// Provides read-only access to the underlying list of errors, preferably\n\t// without causing any allocs.\n\tErrors() []error\n}\n\n// Note that errArray and errArrayElem are very similar to the version\n// implemented in the top-level error.go file. We can't re-use this because\n// that would require exporting errArray as part of the zapcore API.\n\n// Encodes a list of errors using the standard error encoding logic.\ntype errArray []error\n"},{"path":"zapcore/error.go","start_line":109,"end_line":128,"code":"\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Encodes any error into a {\"error\": ...} re-using the same errors logic.\n//\n// May be passed in place of an array to build a single-element array.\ntype errArrayElem struct{ err error }\n\nfunc newErrArrayElem(err error) *errArrayElem {\n\te := _errArrayElemPool.Get()\n\te.err = err\n\treturn e\n}\n\nfunc (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error {\n\treturn arr.AppendObject(e)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":[{"symbol":"(*errArrayElem).Free","path":"zapcore/error.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"newErrArrayElem","path":"zapcore/error.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"newErrArrayElem","signature":"func newErrArrayElem(err error) *errArrayElem","start_line":119,"end_line":123,"code":"func newErrArrayElem(err error) *errArrayElem {\n\n\te := _errArrayElemPool.Get()\n\te.err = err\n\treturn e\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":99,"end_line":118,"code":"\n\t\tel := newErrArrayElem(errs[i])\n\t\terr := arr.AppendObject(el)\n\t\tel.Free()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Encodes any error into a {\"error\": ...} re-using the same errors logic.\n//\n// May be passed in place of an array to build a single-element array.\ntype errArrayElem struct{ err error }\n"},{"path":"zapcore/error.go","start_line":124,"end_line":137,"code":"\nfunc (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error {\n\treturn arr.AppendObject(e)\n}\n\nfunc (e *errArrayElem) MarshalLogObject(enc ObjectEncoder) error {\n\treturn encodeError(\"error\", e.err, enc)\n}\n\nfunc (e *errArrayElem) Free() {\n\te.err = nil\n\t_errArrayElemPool.Put(e)\n}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"(*Pool).Get[*go.uber.org/zap/zapcore.errArrayElem]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"(*errArrayElem).MarshalLogArray","signature":"func (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error","start_line":125,"end_line":127,"code":"func (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error {\n\n\treturn arr.AppendObject(e)\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":105,"end_line":124,"code":"\t\t}\n\t}\n\treturn nil\n}\n\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Encodes any error into a {\"error\": ...} re-using the same errors logic.\n//\n// May be passed in place of an array to build a single-element array.\ntype errArrayElem struct{ err error }\n\nfunc newErrArrayElem(err error) *errArrayElem {\n\te := _errArrayElemPool.Get()\n\te.err = err\n\treturn e\n}\n"},{"path":"zapcore/error.go","start_line":128,"end_line":137,"code":"\nfunc (e *errArrayElem) MarshalLogObject(enc ObjectEncoder) error {\n\treturn encodeError(\"error\", e.err, enc)\n}\n\nfunc (e *errArrayElem) Free() {\n\te.err = nil\n\t_errArrayElemPool.Put(e)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.61},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"(*errArrayElem).MarshalLogObject","signature":"func (e *errArrayElem) MarshalLogObject(enc ObjectEncoder) error","start_line":129,"end_line":131,"code":"func (e *errArrayElem) MarshalLogObject(enc ObjectEncoder) error {\n\n\treturn encodeError(\"error\", e.err, enc)\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":109,"end_line":128,"code":"\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn \u0026errArrayElem{}\n})\n\n// Encodes any error into a {\"error\": ...} re-using the same errors logic.\n//\n// May be passed in place of an array to build a single-element array.\ntype errArrayElem struct{ err error }\n\nfunc newErrArrayElem(err error) *errArrayElem {\n\te := _errArrayElemPool.Get()\n\te.err = err\n\treturn e\n}\n\nfunc (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error {\n\treturn arr.AppendObject(e)\n}\n"},{"path":"zapcore/error.go","start_line":132,"end_line":137,"code":"\nfunc (e *errArrayElem) Free() {\n\te.err = nil\n\t_errArrayElemPool.Put(e)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.62},"call_graph":{"callees":[{"symbol":"encodeError","path":"zapcore/error.go"}],"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/error.go","symbol":"(*errArrayElem).Free","signature":"func (e *errArrayElem) Free()","start_line":133,"end_line":136,"code":"func (e *errArrayElem) Free() {\n\n\te.err = nil\n\t_errArrayElemPool.Put(e)\n}\n","neighbors":[{"path":"zapcore/error.go","start_line":113,"end_line":132,"code":"\n// Encodes any error into a {\"error\": ...} re-using the same errors logic.\n//\n// May be passed in place of an array to build a single-element array.\ntype errArrayElem struct{ err error }\n\nfunc newErrArrayElem(err error) *errArrayElem {\n\te := _errArrayElemPool.Get()\n\te.err = err\n\treturn e\n}\n\nfunc (e *errArrayElem) MarshalLogArray(arr ArrayEncoder) error {\n\treturn arr.AppendObject(e)\n}\n\nfunc (e *errArrayElem) MarshalLogObject(enc ObjectEncoder) error {\n\treturn encodeError(\"error\", e.err, enc)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.64},"call_graph":{"callees":[{"symbol":"(*Pool).Put[*go.uber.org/zap/zapcore.errArrayElem]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/field.go","symbol":"(Field).AddTo","signature":"func (f Field) AddTo(enc ObjectEncoder)","start_line":114,"end_line":186,"code":"func (f Field) AddTo(enc ObjectEncoder) {\n\n\tvar err error\n\n\tswitch f.Type {\n\tcase ArrayMarshalerType:\n\t\terr = enc.AddArray(f.Key, f.Interface.(ArrayMarshaler))\n\tcase ObjectMarshalerType:\n\t\terr = enc.AddObject(f.Key, f.Interface.(ObjectMarshaler))\n\tcase InlineMarshalerType:\n\t\terr = f.Interface.(ObjectMarshaler).MarshalLogObject(enc)\n\tcase BinaryType:\n\t\tenc.AddBinary(f.Key, f.Interface.([]byte))\n\tcase BoolType:\n\t\tenc.AddBool(f.Key, f.Integer == 1)\n\tcase ByteStringType:\n\t\tenc.AddByteString(f.Key, f.Interface.([]byte))\n\tcase Complex128Type:\n\t\tenc.AddComplex128(f.Key, f.Interface.(complex128))\n\tcase Complex64Type:\n\t\tenc.AddComplex64(f.Key, f.Interface.(complex64))\n\tcase DurationType:\n\t\tenc.AddDuration(f.Key, time.Duration(f.Integer))\n\tcase Float64Type:\n\t\tenc.AddFloat64(f.Key, math.Float64frombits(uint64(f.Integer)))\n\tcase Float32Type:\n\t\tenc.AddFloat32(f.Key, math.Float32frombits(uint32(f.Integer)))\n\tcase Int64Type:\n\t\tenc.AddInt64(f.Key, f.Integer)\n\tcase Int32Type:\n\t\tenc.AddInt32(f.Key, int32(f.Integer))\n\tcase Int16Type:\n\t\tenc.AddInt16(f.Key, int16(f.Integer))\n\tcase Int8Type:\n\t\tenc.AddInt8(f.Key, int8(f.Integer))\n\tcase StringType:\n\t\tenc.AddString(f.Key, f.String)\n\tcase TimeType:\n\t\tif f.Interface != nil {\n\t\t\tenc.AddTime(f.Key, time.Unix(0, f.Integer).In(f.Interface.(*time.Location)))\n\t\t} else {\n\t\t\t\n\t\t\tenc.AddTime(f.Key, time.Unix(0, f.Integer))\n\t\t}\n\tcase TimeFullType:\n\t\tenc.AddTime(f.Key, f.Interface.(time.Time))\n\tcase Uint64Type:\n\t\tenc.AddUint64(f.Key, uint64(f.Integer))\n\tcase Uint32Type:\n\t\tenc.AddUint32(f.Key, uint32(f.Integer))\n\tcase Uint16Type:\n\t\tenc.AddUint16(f.Key, uint16(f.Integer))\n\tcase Uint8Type:\n\t\tenc.AddUint8(f.Key, uint8(f.Integer))\n\tcase UintptrType:\n\t\tenc.AddUintptr(f.Key, uintptr(f.Integer))\n\tcase ReflectType:\n\t\terr = enc.AddReflected(f.Key, f.Interface)\n\tcase NamespaceType:\n\t\tenc.OpenNamespace(f.Key)\n\tcase StringerType:\n\t\terr = encodeStringer(f.Key, f.Interface, enc)\n\tcase ErrorType:\n\t\terr = encodeError(f.Key, f.Interface.(error), enc)\n\tcase SkipType:\n\t\tbreak\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown field type: %v\", f))\n\t}\n\n\tif err != nil {\n\t\tenc.AddString(fmt.Sprintf(\"%sError\", f.Key), err.Error())\n\t}\n}\n","neighbors":[{"path":"zapcore/field.go","start_line":94,"end_line":113,"code":"\tSkipType\n\n\t// InlineMarshalerType indicates that the field carries an ObjectMarshaler\n\t// that should be inlined.\n\tInlineMarshalerType\n)\n\n// A Field is a marshaling operation used to add a key-value pair to a logger's\n// context. Most fields are lazily marshaled, so it's inexpensive to add fields\n// to disabled debug-level log statements.\ntype Field struct {\n\tKey       string\n\tType      FieldType\n\tInteger   int64\n\tString    string\n\tInterface interface{}\n}\n\n// AddTo exports a field through the ObjectEncoder interface. It's primarily\n// useful to library authors, and shouldn't be necessary in most applications."},{"path":"zapcore/field.go","start_line":187,"end_line":206,"code":"\n// Equals returns whether two fields are equal. For non-primitive types such as\n// errors, marshalers, or reflect types, it uses reflect.DeepEqual.\nfunc (f Field) Equals(other Field) bool {\n\tif f.Type != other.Type {\n\t\treturn false\n\t}\n\tif f.Key != other.Key {\n\t\treturn false\n\t}\n\n\tswitch f.Type {\n\tcase BinaryType, ByteStringType:\n\t\treturn bytes.Equal(f.Interface.([]byte), other.Interface.([]byte))\n\tcase ArrayMarshalerType, ObjectMarshalerType, ErrorType, ReflectType:\n\t\treturn reflect.DeepEqual(f.Interface, other.Interface)\n\tdefault:\n\t\treturn f == other\n\t}\n}"}],"selection":{"visibility":"exported","reason":"core","score":0.72},"call_graph":{"callees":[{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*MapObjectEncoder).AddBinary","path":"zapcore/memory_encoder.go"},{"symbol":"(*MapObjectEncoder).AddBool","path":"zapcore/memory_encoder.go"},{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*MaxBytesError).Error","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"zapcore/error.go"},{"symbol":"(*errSinkNotFound).Error","path":"sink.go"},{"symbol":"(*errorString).Error","path":"../../../../usr/local/go/src/errors/errors.go"},{"symbol":"(*jsonEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddBinary","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddBool","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*permanentError).Error","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(OSStatus).Error","path":"../../../../usr/local/go/src/crypto/x509/internal/macos/security.go"},{"symbol":"(ObjectMarshalerFunc).MarshalLogObject","path":"zapcore/marshaler.go"},{"symbol":"(Time).In","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(errorAddressString).Error","path":"../../../../usr/local/go/src/runtime/error.go"},{"symbol":"(http2headerFieldValueError).Error","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"},{"symbol":"(unhashableTypeError).Error","path":"../../../../usr/local/go/src/internal/runtime/maps/map.go"},{"symbol":"(wrappedError).Error","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"Float32frombits","path":"../../../../usr/local/go/src/math/unsafe.go"},{"symbol":"Float64frombits","path":"../../../../usr/local/go/src/math/unsafe.go"},{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Unix","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"encodeError","path":"zapcore/error.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"}],"callers":[{"symbol":"(*Field).AddTo","path":"zapcore/field.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"},{"symbol":"(LoggedEntry).ContextMap","path":"zaptest/observer/logged_entry.go"},{"symbol":"(dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"},{"symbol":"addFields","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/field.go","symbol":"(Field).Equals","signature":"func (f Field) Equals(other Field) bool","start_line":190,"end_line":206,"code":"func (f Field) Equals(other Field) bool {\n\n\tif f.Type != other.Type {\n\t\treturn false\n\t}\n\tif f.Key != other.Key {\n\t\treturn false\n\t}\n\n\tswitch f.Type {\n\tcase BinaryType, ByteStringType:\n\t\treturn bytes.Equal(f.Interface.([]byte), other.Interface.([]byte))\n\tcase ArrayMarshalerType, ObjectMarshalerType, ErrorType, ReflectType:\n\t\treturn reflect.DeepEqual(f.Interface, other.Interface)\n\tdefault:\n\t\treturn f == other\n\t}\n}\n","neighbors":[{"path":"zapcore/field.go","start_line":170,"end_line":189,"code":"\t\terr = enc.AddReflected(f.Key, f.Interface)\n\tcase NamespaceType:\n\t\tenc.OpenNamespace(f.Key)\n\tcase StringerType:\n\t\terr = encodeStringer(f.Key, f.Interface, enc)\n\tcase ErrorType:\n\t\terr = encodeError(f.Key, f.Interface.(error), enc)\n\tcase SkipType:\n\t\tbreak\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unknown field type: %v\", f))\n\t}\n\n\tif err != nil {\n\t\tenc.AddString(fmt.Sprintf(\"%sError\", f.Key), err.Error())\n\t}\n}\n\n// Equals returns whether two fields are equal. For non-primitive types such as\n// errors, marshalers, or reflect types, it uses reflect.DeepEqual."},{"path":"zapcore/field.go","start_line":207,"end_line":226,"code":"\nfunc addFields(enc ObjectEncoder, fields []Field) {\n\tfor i := range fields {\n\t\tfields[i].AddTo(enc)\n\t}\n}\n\nfunc encodeStringer(key string, stringer interface{}, enc ObjectEncoder) (retErr error) {\n\t// Try to capture panics (from nil references or otherwise) when calling\n\t// the String() method, similar to https://golang.org/src/fmt/print.go#L540\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\t// If it's a nil pointer, just say \"\u003cnil\u003e\". The likeliest causes are a\n\t\t\t// Stringer that fails to guard against nil or a nil pointer for a\n\t\t\t// value receiver, and in either case, \"\u003cnil\u003e\" is a nice result.\n\t\t\tif v := reflect.ValueOf(stringer); v.Kind() == reflect.Ptr \u0026\u0026 v.IsNil() {\n\t\t\t\tenc.AddString(key, \"\u003cnil\u003e\")\n\t\t\t\treturn\n\t\t\t}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"DeepEqual","path":"../../../../usr/local/go/src/reflect/deepequal.go"},{"symbol":"Equal","path":"../../../../usr/local/go/src/bytes/bytes.go"}],"callers":[{"symbol":"(*Field).Equals","path":"zapcore/field.go"},{"symbol":"FilterField$1","path":"zaptest/observer/observer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/field.go","symbol":"addFields","signature":"func addFields(enc ObjectEncoder, fields []Field)","start_line":208,"end_line":212,"code":"func addFields(enc ObjectEncoder, fields []Field) {\n\n\tfor i := range fields {\n\t\tfields[i].AddTo(enc)\n\t}\n}\n","neighbors":[{"path":"zapcore/field.go","start_line":188,"end_line":207,"code":"// Equals returns whether two fields are equal. For non-primitive types such as\n// errors, marshalers, or reflect types, it uses reflect.DeepEqual.\nfunc (f Field) Equals(other Field) bool {\n\tif f.Type != other.Type {\n\t\treturn false\n\t}\n\tif f.Key != other.Key {\n\t\treturn false\n\t}\n\n\tswitch f.Type {\n\tcase BinaryType, ByteStringType:\n\t\treturn bytes.Equal(f.Interface.([]byte), other.Interface.([]byte))\n\tcase ArrayMarshalerType, ObjectMarshalerType, ErrorType, ReflectType:\n\t\treturn reflect.DeepEqual(f.Interface, other.Interface)\n\tdefault:\n\t\treturn f == other\n\t}\n}\n"},{"path":"zapcore/field.go","start_line":213,"end_line":232,"code":"\nfunc encodeStringer(key string, stringer interface{}, enc ObjectEncoder) (retErr error) {\n\t// Try to capture panics (from nil references or otherwise) when calling\n\t// the String() method, similar to https://golang.org/src/fmt/print.go#L540\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\t// If it's a nil pointer, just say \"\u003cnil\u003e\". The likeliest causes are a\n\t\t\t// Stringer that fails to guard against nil or a nil pointer for a\n\t\t\t// value receiver, and in either case, \"\u003cnil\u003e\" is a nice result.\n\t\t\tif v := reflect.ValueOf(stringer); v.Kind() == reflect.Ptr \u0026\u0026 v.IsNil() {\n\t\t\t\tenc.AddString(key, \"\u003cnil\u003e\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tretErr = fmt.Errorf(\"PANIC=%v\", err)\n\t\t}\n\t}()\n\n\tenc.AddString(key, stringer.(fmt.Stringer).String())\n\treturn nil"}],"selection":{"visibility":"unexported","reason":"core","score":0.51},"call_graph":{"callees":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"callers":[{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/field.go","symbol":"encodeStringer","signature":"func encodeStringer(key string, stringer interface{}, enc ObjectEncoder) (retErr error)","start_line":214,"end_line":233,"code":"func encodeStringer(key string, stringer interface{\n}, enc ObjectEncoder) (retErr error) {\n\t\n\t\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif v := reflect.ValueOf(stringer); v.Kind() == reflect.Ptr \u0026\u0026 v.IsNil() {\n\t\t\t\tenc.AddString(key, \"\u003cnil\u003e\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tretErr = fmt.Errorf(\"PANIC=%v\", err)\n\t\t}\n\t}()\n\n\tenc.AddString(key, stringer.(fmt.Stringer).String())\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/field.go","start_line":194,"end_line":213,"code":"\tif f.Key != other.Key {\n\t\treturn false\n\t}\n\n\tswitch f.Type {\n\tcase BinaryType, ByteStringType:\n\t\treturn bytes.Equal(f.Interface.([]byte), other.Interface.([]byte))\n\tcase ArrayMarshalerType, ObjectMarshalerType, ErrorType, ReflectType:\n\t\treturn reflect.DeepEqual(f.Interface, other.Interface)\n\tdefault:\n\t\treturn f == other\n\t}\n}\n\nfunc addFields(enc ObjectEncoder, fields []Field) {\n\tfor i := range fields {\n\t\tfields[i].AddTo(enc)\n\t}\n}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"(*BranchNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*Cmd).String","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*DotNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*Location).String","path":"../../../../usr/local/go/src/time/zoneinfo.go"},{"symbol":"(*NumberNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*StringNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*TCPAddr).String","path":"../../../../usr/local/go/src/net/tcpsock.go"},{"symbol":"(*VariableNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*benchmarkRow).String","path":"internal/readme/readme.go"},{"symbol":"(*bracketPair).String","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/bidi/bracket.go"},{"symbol":"(*cancelCtx).String","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"(*elseNode).String","path":"../../../../usr/local/go/src/text/template/parse/node.go"},{"symbol":"(*float64Value).String","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(Duration).String","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Flags).String","path":"../../../../usr/local/go/src/net/interface.go"},{"symbol":"(Hash).String","path":"../../../../usr/local/go/src/crypto/crypto.go"},{"symbol":"(IP).String","path":"../../../../usr/local/go/src/net/ip.go"},{"symbol":"(OID).String","path":"../../../../usr/local/go/src/crypto/x509/oid.go"},{"symbol":"(Prefix).String","path":"../../../../usr/local/go/src/net/netip/netip.go"},{"symbol":"(ProcStatus).String","path":"../../../../usr/local/go/src/internal/trace/tracev2/events.go"},{"symbol":"(QUICEncryptionLevel).String","path":"../../../../usr/local/go/src/crypto/tls/quic.go"},{"symbol":"(Time).String","path":"../../../../usr/local/go/src/time/format.go"},{"symbol":"(Weekday).String","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(funcValue).String","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"(http2FrameType).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(http2Setting).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(pipeAddr).String","path":"../../../../usr/local/go/src/net/pipe.go"},{"symbol":"(socksCommand).String","path":"../../../../usr/local/go/src/net/http/socks_bundle.go"},{"symbol":"encodeStringer$1","path":"zapcore/field.go"}],"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/hook.go","symbol":"RegisterHooks","signature":"func RegisterHooks(core Core, hooks ...func(Entry) error) Core","start_line":40,"end_line":46,"code":"func RegisterHooks(core Core, hooks ...func(Entry) error) Core {\n\n\tfuncs := append([]func(Entry) error{}, hooks...)\n\treturn \u0026hooked{\n\t\tCore:  core,\n\t\tfuncs: funcs,\n\t}\n}\n","neighbors":[{"path":"zapcore/hook.go","start_line":20,"end_line":39,"code":"\npackage zapcore\n\nimport \"go.uber.org/multierr\"\n\ntype hooked struct {\n\tCore\n\tfuncs []func(Entry) error\n}\n\nvar (\n\t_ Core           = (*hooked)(nil)\n\t_ leveledEnabler = (*hooked)(nil)\n)\n\n// RegisterHooks wraps a Core and runs a collection of user-defined callback\n// hooks each time a message is logged. Execution of the callbacks is blocking.\n//\n// This offers users an easy way to register simple callbacks (e.g., metrics\n// collection) without implementing the full Core interface."},{"path":"zapcore/hook.go","start_line":47,"end_line":66,"code":"\nfunc (h *hooked) Level() Level {\n\treturn LevelOf(h.Core)\n}\n\nfunc (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\t// Let the wrapped Core decide whether to log this message or not. This\n\t// also gives the downstream a chance to register itself directly with the\n\t// CheckedEntry.\n\tif downstream := h.Core.Check(ent, ce); downstream != nil {\n\t\treturn downstream.AddCore(ent, h)\n\t}\n\treturn ce\n}\n\nfunc (h *hooked) With(fields []Field) Core {\n\treturn \u0026hooked{\n\t\tCore:  h.Core.With(fields),\n\t\tfuncs: h.funcs,\n\t}"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"Hooks$1","path":"options.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/hook.go","symbol":"(*hooked).Level","signature":"func (h *hooked) Level() Level","start_line":48,"end_line":50,"code":"func (h *hooked) Level() Level {\n\n\treturn LevelOf(h.Core)\n}\n","neighbors":[{"path":"zapcore/hook.go","start_line":28,"end_line":47,"code":"}\n\nvar (\n\t_ Core           = (*hooked)(nil)\n\t_ leveledEnabler = (*hooked)(nil)\n)\n\n// RegisterHooks wraps a Core and runs a collection of user-defined callback\n// hooks each time a message is logged. Execution of the callbacks is blocking.\n//\n// This offers users an easy way to register simple callbacks (e.g., metrics\n// collection) without implementing the full Core interface.\nfunc RegisterHooks(core Core, hooks ...func(Entry) error) Core {\n\tfuncs := append([]func(Entry) error{}, hooks...)\n\treturn \u0026hooked{\n\t\tCore:  core,\n\t\tfuncs: funcs,\n\t}\n}\n"},{"path":"zapcore/hook.go","start_line":51,"end_line":70,"code":"\nfunc (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\t// Let the wrapped Core decide whether to log this message or not. This\n\t// also gives the downstream a chance to register itself directly with the\n\t// CheckedEntry.\n\tif downstream := h.Core.Check(ent, ce); downstream != nil {\n\t\treturn downstream.AddCore(ent, h)\n\t}\n\treturn ce\n}\n\nfunc (h *hooked) With(fields []Field) Core {\n\treturn \u0026hooked{\n\t\tCore:  h.Core.With(fields),\n\t\tfuncs: h.funcs,\n\t}\n}\n\nfunc (h *hooked) Write(ent Entry, _ []Field) error {\n\t// Since our downstream had a chance to register itself directly with the"}],"selection":{"visibility":"exported","reason":"core","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/hook.go","symbol":"(*hooked).Check","signature":"func (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry","start_line":52,"end_line":60,"code":"func (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\n\t\n\t\n\t\n\tif downstream := h.Core.Check(ent, ce); downstream != nil {\n\t\treturn downstream.AddCore(ent, h)\n\t}\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/hook.go","start_line":32,"end_line":51,"code":"\t_ leveledEnabler = (*hooked)(nil)\n)\n\n// RegisterHooks wraps a Core and runs a collection of user-defined callback\n// hooks each time a message is logged. Execution of the callbacks is blocking.\n//\n// This offers users an easy way to register simple callbacks (e.g., metrics\n// collection) without implementing the full Core interface.\nfunc RegisterHooks(core Core, hooks ...func(Entry) error) Core {\n\tfuncs := append([]func(Entry) error{}, hooks...)\n\treturn \u0026hooked{\n\t\tCore:  core,\n\t\tfuncs: funcs,\n\t}\n}\n\nfunc (h *hooked) Level() Level {\n\treturn LevelOf(h.Core)\n}\n"},{"path":"zapcore/hook.go","start_line":61,"end_line":78,"code":"\nfunc (h *hooked) With(fields []Field) Core {\n\treturn \u0026hooked{\n\t\tCore:  h.Core.With(fields),\n\t\tfuncs: h.funcs,\n\t}\n}\n\nfunc (h *hooked) Write(ent Entry, _ []Field) error {\n\t// Since our downstream had a chance to register itself directly with the\n\t// CheckedMessage, we don't need to call it here.\n\tvar err error\n\tfor i := range h.funcs {\n\t\terr = multierr.Append(err, h.funcs[i](ent))\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.74},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).AddCore","path":"zapcore/entry.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/hook.go","symbol":"(*hooked).With","signature":"func (h *hooked) With(fields []Field) Core","start_line":62,"end_line":67,"code":"func (h *hooked) With(fields []Field) Core {\n\n\treturn \u0026hooked{\n\t\tCore:  h.Core.With(fields),\n\t\tfuncs: h.funcs,\n\t}\n}\n","neighbors":[{"path":"zapcore/hook.go","start_line":42,"end_line":61,"code":"\treturn \u0026hooked{\n\t\tCore:  core,\n\t\tfuncs: funcs,\n\t}\n}\n\nfunc (h *hooked) Level() Level {\n\treturn LevelOf(h.Core)\n}\n\nfunc (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\t// Let the wrapped Core decide whether to log this message or not. This\n\t// also gives the downstream a chance to register itself directly with the\n\t// CheckedEntry.\n\tif downstream := h.Core.Check(ent, ce); downstream != nil {\n\t\treturn downstream.AddCore(ent, h)\n\t}\n\treturn ce\n}\n"},{"path":"zapcore/hook.go","start_line":68,"end_line":78,"code":"\nfunc (h *hooked) Write(ent Entry, _ []Field) error {\n\t// Since our downstream had a chance to register itself directly with the\n\t// CheckedMessage, we don't need to call it here.\n\tvar err error\n\tfor i := range h.funcs {\n\t\terr = multierr.Append(err, h.funcs[i](ent))\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.89},"call_graph":{"callees":[{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/hook.go","symbol":"(*hooked).Write","signature":"func (h *hooked) Write(ent Entry, _ []Field) error","start_line":69,"end_line":77,"code":"func (h *hooked) Write(ent Entry, _ []Field) error {\n\n\t\n\t\n\tvar err error\n\tfor i := range h.funcs {\n\t\terr = multierr.Append(err, h.funcs[i](ent))\n\t}\n\treturn err\n}\n","neighbors":[{"path":"zapcore/hook.go","start_line":49,"end_line":68,"code":"\treturn LevelOf(h.Core)\n}\n\nfunc (h *hooked) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\t// Let the wrapped Core decide whether to log this message or not. This\n\t// also gives the downstream a chance to register itself directly with the\n\t// CheckedEntry.\n\tif downstream := h.Core.Check(ent, ce); downstream != nil {\n\t\treturn downstream.AddCore(ent, h)\n\t}\n\treturn ce\n}\n\nfunc (h *hooked) With(fields []Field) Core {\n\treturn \u0026hooked{\n\t\tCore:  h.Core.With(fields),\n\t\tfuncs: h.funcs,\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"NewIncreaseLevelCore","signature":"func NewIncreaseLevelCore(core Core, level LevelEnabler) (Core, error)","start_line":39,"end_line":47,"code":"func NewIncreaseLevelCore(core Core, level LevelEnabler) (Core, error) {\n\n\tfor l := _maxLevel; l \u003e= _minLevel; l-- {\n\t\tif !core.Enabled(l) \u0026\u0026 level.Enabled(l) {\n\t\t\treturn nil, fmt.Errorf(\"invalid increase level, as level %q is allowed by increased level, but not by existing core\", l)\n\t\t}\n\t}\n\n\treturn \u0026levelFilterCore{core, level}, nil\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":19,"end_line":38,"code":"// THE SOFTWARE.\n\npackage zapcore\n\nimport \"fmt\"\n\ntype levelFilterCore struct {\n\tcore  Core\n\tlevel LevelEnabler\n}\n\nvar (\n\t_ Core           = (*levelFilterCore)(nil)\n\t_ leveledEnabler = (*levelFilterCore)(nil)\n)\n\n// NewIncreaseLevelCore creates a core that can be used to increase the level of\n// an existing Core. It cannot be used to decrease the logging level, as it acts\n// as a filter before calling the underlying core. If level decreases the log level,\n// an error is returned."},{"path":"zapcore/increase_level.go","start_line":48,"end_line":67,"code":"\nfunc (c *levelFilterCore) Enabled(lvl Level) bool {\n\treturn c.level.Enabled(lvl)\n}\n\nfunc (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"}],"callers":[{"symbol":"IncreaseLevel$1","path":"options.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).Enabled","signature":"func (c *levelFilterCore) Enabled(lvl Level) bool","start_line":49,"end_line":51,"code":"func (c *levelFilterCore) Enabled(lvl Level) bool {\n\n\treturn c.level.Enabled(lvl)\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":29,"end_line":48,"code":"\nvar (\n\t_ Core           = (*levelFilterCore)(nil)\n\t_ leveledEnabler = (*levelFilterCore)(nil)\n)\n\n// NewIncreaseLevelCore creates a core that can be used to increase the level of\n// an existing Core. It cannot be used to decrease the logging level, as it acts\n// as a filter before calling the underlying core. If level decreases the log level,\n// an error is returned.\nfunc NewIncreaseLevelCore(core Core, level LevelEnabler) (Core, error) {\n\tfor l := _maxLevel; l \u003e= _minLevel; l-- {\n\t\tif !core.Enabled(l) \u0026\u0026 level.Enabled(l) {\n\t\t\treturn nil, fmt.Errorf(\"invalid increase level, as level %q is allowed by increased level, but not by existing core\", l)\n\t\t}\n\t}\n\n\treturn \u0026levelFilterCore{core, level}, nil\n}\n"},{"path":"zapcore/increase_level.go","start_line":52,"end_line":71,"code":"\nfunc (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n\nfunc (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\treturn c.core.Write(ent, fields)\n}"}],"selection":{"visibility":"exported","reason":"core","score":0.68},"call_graph":{"callees":[{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).Level","signature":"func (c *levelFilterCore) Level() Level","start_line":53,"end_line":55,"code":"func (c *levelFilterCore) Level() Level {\n\n\treturn LevelOf(c.level)\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":33,"end_line":52,"code":")\n\n// NewIncreaseLevelCore creates a core that can be used to increase the level of\n// an existing Core. It cannot be used to decrease the logging level, as it acts\n// as a filter before calling the underlying core. If level decreases the log level,\n// an error is returned.\nfunc NewIncreaseLevelCore(core Core, level LevelEnabler) (Core, error) {\n\tfor l := _maxLevel; l \u003e= _minLevel; l-- {\n\t\tif !core.Enabled(l) \u0026\u0026 level.Enabled(l) {\n\t\t\treturn nil, fmt.Errorf(\"invalid increase level, as level %q is allowed by increased level, but not by existing core\", l)\n\t\t}\n\t}\n\n\treturn \u0026levelFilterCore{core, level}, nil\n}\n\nfunc (c *levelFilterCore) Enabled(lvl Level) bool {\n\treturn c.level.Enabled(lvl)\n}\n"},{"path":"zapcore/increase_level.go","start_line":56,"end_line":75,"code":"\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n\nfunc (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\treturn c.core.Write(ent, fields)\n}\n\nfunc (c *levelFilterCore) Sync() error {\n\treturn c.core.Sync()\n}"}],"selection":{"visibility":"exported","reason":"core","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).With","signature":"func (c *levelFilterCore) With(fields []Field) Core","start_line":57,"end_line":59,"code":"func (c *levelFilterCore) With(fields []Field) Core {\n\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":37,"end_line":56,"code":"// as a filter before calling the underlying core. If level decreases the log level,\n// an error is returned.\nfunc NewIncreaseLevelCore(core Core, level LevelEnabler) (Core, error) {\n\tfor l := _maxLevel; l \u003e= _minLevel; l-- {\n\t\tif !core.Enabled(l) \u0026\u0026 level.Enabled(l) {\n\t\t\treturn nil, fmt.Errorf(\"invalid increase level, as level %q is allowed by increased level, but not by existing core\", l)\n\t\t}\n\t}\n\n\treturn \u0026levelFilterCore{core, level}, nil\n}\n\nfunc (c *levelFilterCore) Enabled(lvl Level) bool {\n\treturn c.level.Enabled(lvl)\n}\n\nfunc (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n"},{"path":"zapcore/increase_level.go","start_line":60,"end_line":76,"code":"\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n\nfunc (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\treturn c.core.Write(ent, fields)\n}\n\nfunc (c *levelFilterCore) Sync() error {\n\treturn c.core.Sync()\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.79},"call_graph":{"callees":[{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).Check","signature":"func (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry","start_line":61,"end_line":67,"code":"func (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":41,"end_line":60,"code":"\t\tif !core.Enabled(l) \u0026\u0026 level.Enabled(l) {\n\t\t\treturn nil, fmt.Errorf(\"invalid increase level, as level %q is allowed by increased level, but not by existing core\", l)\n\t\t}\n\t}\n\n\treturn \u0026levelFilterCore{core, level}, nil\n}\n\nfunc (c *levelFilterCore) Enabled(lvl Level) bool {\n\treturn c.level.Enabled(lvl)\n}\n\nfunc (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n"},{"path":"zapcore/increase_level.go","start_line":68,"end_line":76,"code":"\nfunc (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\treturn c.core.Write(ent, fields)\n}\n\nfunc (c *levelFilterCore) Sync() error {\n\treturn c.core.Sync()\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.74},"call_graph":{"callees":[{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).Write","signature":"func (c *levelFilterCore) Write(ent Entry, fields []Field) error","start_line":69,"end_line":71,"code":"func (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\n\treturn c.core.Write(ent, fields)\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":49,"end_line":68,"code":"func (c *levelFilterCore) Enabled(lvl Level) bool {\n\treturn c.level.Enabled(lvl)\n}\n\nfunc (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n"},{"path":"zapcore/increase_level.go","start_line":72,"end_line":76,"code":"\nfunc (c *levelFilterCore) Sync() error {\n\treturn c.core.Sync()\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"(*contextObserver).Write","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Write","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"},{"symbol":"(nopCore).Write","path":"zapcore/core.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/increase_level.go","symbol":"(*levelFilterCore).Sync","signature":"func (c *levelFilterCore) Sync() error","start_line":73,"end_line":75,"code":"func (c *levelFilterCore) Sync() error {\n\n\treturn c.core.Sync()\n}\n","neighbors":[{"path":"zapcore/increase_level.go","start_line":53,"end_line":72,"code":"func (c *levelFilterCore) Level() Level {\n\treturn LevelOf(c.level)\n}\n\nfunc (c *levelFilterCore) With(fields []Field) Core {\n\treturn \u0026levelFilterCore{c.core.With(fields), c.level}\n}\n\nfunc (c *levelFilterCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !c.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\treturn c.core.Check(ent, ce)\n}\n\nfunc (c *levelFilterCore) Write(ent Entry, fields []Field) error {\n\treturn c.core.Write(ent, fields)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.66},"call_graph":{"callees":[{"symbol":"(*contextObserver).Sync","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"},{"symbol":"(nopCore).Sync","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).Sync","path":"logger.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"putJSONEncoder","signature":"func putJSONEncoder(enc *jsonEncoder)","start_line":41,"end_line":52,"code":"func putJSONEncoder(enc *jsonEncoder) {\n\n\tif enc.reflectBuf != nil {\n\t\tenc.reflectBuf.Free()\n\t}\n\tenc.EncoderConfig = nil\n\tenc.buf = nil\n\tenc.spaced = false\n\tenc.openNamespaces = 0\n\tenc.reflectBuf = nil\n\tenc.reflectEnc = nil\n\t_jsonPool.Put(enc)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":21,"end_line":40,"code":"package zapcore\n\nimport (\n\t\"encoding/base64\"\n\t\"math\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"go.uber.org/zap/buffer\"\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/pool\"\n)\n\n// For JSON-escaping; see jsonEncoder.safeAddString below.\nconst _hex = \"0123456789abcdef\"\n\nvar _jsonPool = pool.New(func() *jsonEncoder {\n\treturn \u0026jsonEncoder{}\n})\n"},{"path":"zapcore/json_encoder.go","start_line":53,"end_line":72,"code":"\ntype jsonEncoder struct {\n\t*EncoderConfig\n\tbuf            *buffer.Buffer\n\tspaced         bool // include spaces after colons and commas\n\topenNamespaces int\n\n\t// for encoding generic values by reflection\n\treflectBuf *buffer.Buffer\n\treflectEnc ReflectedEncoder\n}\n\n// NewJSONEncoder creates a fast, low-allocation JSON encoder. The encoder\n// appropriately escapes all field keys and values.\n//\n// Note that the encoder doesn't deduplicate keys, so it's possible to produce\n// a message like\n//\n//\t{\"foo\":\"bar\",\"foo\":\"baz\"}\n//"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).Free","path":"buffer/buffer.go"},{"symbol":"(*Pool).Put[*go.uber.org/zap/zapcore.jsonEncoder]","path":"internal/pool/pool.go"}],"callers":[{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"writeContext$1","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"NewJSONEncoder","signature":"func NewJSONEncoder(cfg EncoderConfig) Encoder","start_line":77,"end_line":79,"code":"func NewJSONEncoder(cfg EncoderConfig) Encoder {\n\n\treturn newJSONEncoder(cfg, false)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":57,"end_line":76,"code":"\tspaced         bool // include spaces after colons and commas\n\topenNamespaces int\n\n\t// for encoding generic values by reflection\n\treflectBuf *buffer.Buffer\n\treflectEnc ReflectedEncoder\n}\n\n// NewJSONEncoder creates a fast, low-allocation JSON encoder. The encoder\n// appropriately escapes all field keys and values.\n//\n// Note that the encoder doesn't deduplicate keys, so it's possible to produce\n// a message like\n//\n//\t{\"foo\":\"bar\",\"foo\":\"baz\"}\n//\n// This is permitted by the JSON specification, but not encouraged. Many\n// libraries will ignore duplicate key-value pairs (typically keeping the last\n// pair) when unmarshaling, but users should attempt to avoid adding duplicate\n// keys."},{"path":"zapcore/json_encoder.go","start_line":80,"end_line":99,"code":"\nfunc newJSONEncoder(cfg EncoderConfig, spaced bool) *jsonEncoder {\n\tif cfg.SkipLineEnding {\n\t\tcfg.LineEnding = \"\"\n\t} else if cfg.LineEnding == \"\" {\n\t\tcfg.LineEnding = DefaultLineEnding\n\t}\n\n\t// If no EncoderConfig.NewReflectedEncoder is provided by the user, then use default\n\tif cfg.NewReflectedEncoder == nil {\n\t\tcfg.NewReflectedEncoder = defaultReflectedEncoder\n\t}\n\n\treturn \u0026jsonEncoder{\n\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.81},"call_graph":{"callees":[{"symbol":"newJSONEncoder","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"NewExample","path":"logger.go"},{"symbol":"init$2","path":"encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"newJSONEncoder","signature":"func newJSONEncoder(cfg EncoderConfig, spaced bool) *jsonEncoder","start_line":81,"end_line":98,"code":"func newJSONEncoder(cfg EncoderConfig, spaced bool) *jsonEncoder {\n\n\tif cfg.SkipLineEnding {\n\t\tcfg.LineEnding = \"\"\n\t} else if cfg.LineEnding == \"\" {\n\t\tcfg.LineEnding = DefaultLineEnding\n\t}\n\n\t\n\tif cfg.NewReflectedEncoder == nil {\n\t\tcfg.NewReflectedEncoder = defaultReflectedEncoder\n\t}\n\n\treturn \u0026jsonEncoder{\n\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":61,"end_line":80,"code":"\treflectBuf *buffer.Buffer\n\treflectEnc ReflectedEncoder\n}\n\n// NewJSONEncoder creates a fast, low-allocation JSON encoder. The encoder\n// appropriately escapes all field keys and values.\n//\n// Note that the encoder doesn't deduplicate keys, so it's possible to produce\n// a message like\n//\n//\t{\"foo\":\"bar\",\"foo\":\"baz\"}\n//\n// This is permitted by the JSON specification, but not encouraged. Many\n// libraries will ignore duplicate key-value pairs (typically keeping the last\n// pair) when unmarshaling, but users should attempt to avoid adding duplicate\n// keys.\nfunc NewJSONEncoder(cfg EncoderConfig) Encoder {\n\treturn newJSONEncoder(cfg, false)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":99,"end_line":118,"code":"\nfunc (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"}],"callers":[{"symbol":"NewConsoleEncoder","path":"zapcore/console_encoder.go"},{"symbol":"NewJSONEncoder","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddArray","signature":"func (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error","start_line":100,"end_line":103,"code":"func (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":80,"end_line":99,"code":"\nfunc newJSONEncoder(cfg EncoderConfig, spaced bool) *jsonEncoder {\n\tif cfg.SkipLineEnding {\n\t\tcfg.LineEnding = \"\"\n\t} else if cfg.LineEnding == \"\" {\n\t\tcfg.LineEnding = DefaultLineEnding\n\t}\n\n\t// If no EncoderConfig.NewReflectedEncoder is provided by the user, then use default\n\tif cfg.NewReflectedEncoder == nil {\n\t\tcfg.NewReflectedEncoder = defaultReflectedEncoder\n\t}\n\n\treturn \u0026jsonEncoder{\n\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n"},{"path":"zapcore/json_encoder.go","start_line":104,"end_line":123,"code":"\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"encodeError","path":"zapcore/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddObject","signature":"func (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error","start_line":105,"end_line":108,"code":"func (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":85,"end_line":104,"code":"\t\tcfg.LineEnding = DefaultLineEnding\n\t}\n\n\t// If no EncoderConfig.NewReflectedEncoder is provided by the user, then use default\n\tif cfg.NewReflectedEncoder == nil {\n\t\tcfg.NewReflectedEncoder = defaultReflectedEncoder\n\t}\n\n\treturn \u0026jsonEncoder{\n\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n\nfunc (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":109,"end_line":128,"code":"\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddObject","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddObject","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddBinary","signature":"func (enc *jsonEncoder) AddBinary(key string, val []byte)","start_line":110,"end_line":112,"code":"func (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":90,"end_line":109,"code":"\t\tcfg.NewReflectedEncoder = defaultReflectedEncoder\n\t}\n\n\treturn \u0026jsonEncoder{\n\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n\nfunc (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":113,"end_line":132,"code":"\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*Encoding).EncodeToString","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddBinary","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddBinary","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddByteString","signature":"func (enc *jsonEncoder) AddByteString(key string, val []byte)","start_line":114,"end_line":117,"code":"func (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":94,"end_line":113,"code":"\t\tEncoderConfig: \u0026cfg,\n\t\tbuf:           bufferpool.Get(),\n\t\tspaced:        spaced,\n\t}\n}\n\nfunc (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n"},{"path":"zapcore/json_encoder.go","start_line":118,"end_line":137,"code":"\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddByteString","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddByteString","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddBool","signature":"func (enc *jsonEncoder) AddBool(key string, val bool)","start_line":119,"end_line":122,"code":"func (enc *jsonEncoder) AddBool(key string, val bool) {\n\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":99,"end_line":118,"code":"\nfunc (enc *jsonEncoder) AddArray(key string, arr ArrayMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendArray(arr)\n}\n\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":123,"end_line":142,"code":"\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendBool","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddBool","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddBool","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddComplex128","signature":"func (enc *jsonEncoder) AddComplex128(key string, val complex128)","start_line":124,"end_line":127,"code":"func (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":104,"end_line":123,"code":"\nfunc (enc *jsonEncoder) AddObject(key string, obj ObjectMarshaler) error {\n\tenc.addKey(key)\n\treturn enc.AppendObject(obj)\n}\n\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":128,"end_line":147,"code":"\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddComplex128","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddComplex64","signature":"func (enc *jsonEncoder) AddComplex64(key string, val complex64)","start_line":129,"end_line":132,"code":"func (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":109,"end_line":128,"code":"\nfunc (enc *jsonEncoder) AddBinary(key string, val []byte) {\n\tenc.AddString(key, base64.StdEncoding.EncodeToString(val))\n}\n\nfunc (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":133,"end_line":152,"code":"\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddComplex64","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddDuration","signature":"func (enc *jsonEncoder) AddDuration(key string, val time.Duration)","start_line":134,"end_line":137,"code":"func (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":114,"end_line":133,"code":"func (enc *jsonEncoder) AddByteString(key string, val []byte) {\n\tenc.addKey(key)\n\tenc.AppendByteString(val)\n}\n\nfunc (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":138,"end_line":157,"code":"\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n\nfunc (enc *jsonEncoder) resetReflectBuf() {\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddDuration","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddDuration","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddFloat64","signature":"func (enc *jsonEncoder) AddFloat64(key string, val float64)","start_line":139,"end_line":142,"code":"func (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":119,"end_line":138,"code":"func (enc *jsonEncoder) AddBool(key string, val bool) {\n\tenc.addKey(key)\n\tenc.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":143,"end_line":162,"code":"\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n\nfunc (enc *jsonEncoder) resetReflectBuf() {\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)\n\t} else {\n\t\tenc.reflectBuf.Reset()\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddFloat64","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddFloat32","signature":"func (enc *jsonEncoder) AddFloat32(key string, val float32)","start_line":144,"end_line":147,"code":"func (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":124,"end_line":143,"code":"func (enc *jsonEncoder) AddComplex128(key string, val complex128) {\n\tenc.addKey(key)\n\tenc.AppendComplex128(val)\n}\n\nfunc (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":148,"end_line":167,"code":"\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n\nfunc (enc *jsonEncoder) resetReflectBuf() {\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)\n\t} else {\n\t\tenc.reflectBuf.Reset()\n\t}\n}\n\nvar nullLiteralBytes = []byte(\"null\")\n\n// Only invoke the standard JSON encoder if there is actually something to\n// encode; otherwise write JSON null literal directly.\nfunc (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error) {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddFloat32","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddInt64","signature":"func (enc *jsonEncoder) AddInt64(key string, val int64)","start_line":149,"end_line":152,"code":"func (enc *jsonEncoder) AddInt64(key string, val int64) {\n\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":129,"end_line":148,"code":"func (enc *jsonEncoder) AddComplex64(key string, val complex64) {\n\tenc.addKey(key)\n\tenc.AppendComplex64(val)\n}\n\nfunc (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":153,"end_line":172,"code":"\nfunc (enc *jsonEncoder) resetReflectBuf() {\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)\n\t} else {\n\t\tenc.reflectBuf.Reset()\n\t}\n}\n\nvar nullLiteralBytes = []byte(\"null\")\n\n// Only invoke the standard JSON encoder if there is actually something to\n// encode; otherwise write JSON null literal directly.\nfunc (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error) {\n\tif obj == nil {\n\t\treturn nullLiteralBytes, nil\n\t}\n\tenc.resetReflectBuf()\n\tif err := enc.reflectEnc.Encode(obj); err != nil {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt16","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt8","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddInt64","path":"zapcore/json_encoder.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).resetReflectBuf","signature":"func (enc *jsonEncoder) resetReflectBuf()","start_line":154,"end_line":161,"code":"func (enc *jsonEncoder) resetReflectBuf() {\n\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)\n\t} else {\n\t\tenc.reflectBuf.Reset()\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":134,"end_line":153,"code":"func (enc *jsonEncoder) AddDuration(key string, val time.Duration) {\n\tenc.addKey(key)\n\tenc.AppendDuration(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat64(key string, val float64) {\n\tenc.addKey(key)\n\tenc.AppendFloat64(val)\n}\n\nfunc (enc *jsonEncoder) AddFloat32(key string, val float32) {\n\tenc.addKey(key)\n\tenc.AppendFloat32(val)\n}\n\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":162,"end_line":181,"code":"\nvar nullLiteralBytes = []byte(\"null\")\n\n// Only invoke the standard JSON encoder if there is actually something to\n// encode; otherwise write JSON null literal directly.\nfunc (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error) {\n\tif obj == nil {\n\t\treturn nullLiteralBytes, nil\n\t}\n\tenc.resetReflectBuf()\n\tif err := enc.reflectEnc.Encode(obj); err != nil {\n\t\treturn nil, err\n\t}\n\tenc.reflectBuf.TrimNewline()\n\treturn enc.reflectBuf.Bytes(), nil\n}\n\nfunc (enc *jsonEncoder) AddReflected(key string, obj interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.55},"call_graph":{"callees":[{"symbol":"(*Buffer).Reset","path":"buffer/buffer.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"},{"symbol":"defaultReflectedEncoder","path":"zapcore/reflected_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).encodeReflected","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).encodeReflected","signature":"func (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error)","start_line":167,"end_line":177,"code":"func (enc *jsonEncoder) encodeReflected(obj interface{\n}) ([]byte, error) {\n\tif obj == nil {\n\t\treturn nullLiteralBytes, nil\n\t}\n\tenc.resetReflectBuf()\n\tif err := enc.reflectEnc.Encode(obj); err != nil {\n\t\treturn nil, err\n\t}\n\tenc.reflectBuf.TrimNewline()\n\treturn enc.reflectBuf.Bytes(), nil\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":147,"end_line":166,"code":"}\n\nfunc (enc *jsonEncoder) AddInt64(key string, val int64) {\n\tenc.addKey(key)\n\tenc.AppendInt64(val)\n}\n\nfunc (enc *jsonEncoder) resetReflectBuf() {\n\tif enc.reflectBuf == nil {\n\t\tenc.reflectBuf = bufferpool.Get()\n\t\tenc.reflectEnc = enc.NewReflectedEncoder(enc.reflectBuf)\n\t} else {\n\t\tenc.reflectBuf.Reset()\n\t}\n}\n\nvar nullLiteralBytes = []byte(\"null\")\n\n// Only invoke the standard JSON encoder if there is actually something to\n// encode; otherwise write JSON null literal directly."},{"path":"zapcore/json_encoder.go","start_line":178,"end_line":197,"code":"\nfunc (enc *jsonEncoder) AddReflected(key string, obj interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addKey(key)\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) OpenNamespace(key string) {\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).TrimNewline","path":"buffer/buffer.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*jsonEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).encodeReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendReflected","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).encodeReflected","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddReflected","signature":"func (enc *jsonEncoder) AddReflected(key string, obj interface{}) error","start_line":179,"end_line":187,"code":"func (enc *jsonEncoder) AddReflected(key string, obj interface{\n}) error {\n\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addKey(key)\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":159,"end_line":178,"code":"\t\tenc.reflectBuf.Reset()\n\t}\n}\n\nvar nullLiteralBytes = []byte(\"null\")\n\n// Only invoke the standard JSON encoder if there is actually something to\n// encode; otherwise write JSON null literal directly.\nfunc (enc *jsonEncoder) encodeReflected(obj interface{}) ([]byte, error) {\n\tif obj == nil {\n\t\treturn nullLiteralBytes, nil\n\t}\n\tenc.resetReflectBuf()\n\tif err := enc.reflectEnc.Encode(obj); err != nil {\n\t\treturn nil, err\n\t}\n\tenc.reflectBuf.TrimNewline()\n\treturn enc.reflectBuf.Bytes(), nil\n}\n"},{"path":"zapcore/json_encoder.go","start_line":188,"end_line":207,"code":"\nfunc (enc *jsonEncoder) OpenNamespace(key string) {\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).Write","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).encodeReflected","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddReflected","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddReflected","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).OpenNamespace","signature":"func (enc *jsonEncoder) OpenNamespace(key string)","start_line":189,"end_line":193,"code":"func (enc *jsonEncoder) OpenNamespace(key string) {\n\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":169,"end_line":188,"code":"\t\treturn nullLiteralBytes, nil\n\t}\n\tenc.resetReflectBuf()\n\tif err := enc.reflectEnc.Encode(obj); err != nil {\n\t\treturn nil, err\n\t}\n\tenc.reflectBuf.TrimNewline()\n\treturn enc.reflectBuf.Bytes(), nil\n}\n\nfunc (enc *jsonEncoder) AddReflected(key string, obj interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addKey(key)\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n"},{"path":"zapcore/json_encoder.go","start_line":194,"end_line":213,"code":"\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n\nfunc (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).OpenNamespace","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).OpenNamespace","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddString","signature":"func (enc *jsonEncoder) AddString(key, val string)","start_line":195,"end_line":198,"code":"func (enc *jsonEncoder) AddString(key, val string) {\n\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":175,"end_line":194,"code":"\tenc.reflectBuf.TrimNewline()\n\treturn enc.reflectBuf.Bytes(), nil\n}\n\nfunc (enc *jsonEncoder) AddReflected(key string, obj interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addKey(key)\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) OpenNamespace(key string) {\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n"},{"path":"zapcore/json_encoder.go","start_line":199,"end_line":218,"code":"\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n\nfunc (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.69},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddBinary","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"encodeError","path":"zapcore/error.go"},{"symbol":"encodeError$1","path":"zapcore/error.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"encodeStringer$1","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddTime","signature":"func (enc *jsonEncoder) AddTime(key string, val time.Time)","start_line":200,"end_line":203,"code":"func (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":180,"end_line":199,"code":"\tvalueBytes, err := enc.encodeReflected(obj)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addKey(key)\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) OpenNamespace(key string) {\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":204,"end_line":223,"code":"\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n\nfunc (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\t// Close ONLY new openNamespaces that are created during\n\t// AppendObject().\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddTime","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUint64","signature":"func (enc *jsonEncoder) AddUint64(key string, val uint64)","start_line":205,"end_line":208,"code":"func (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":185,"end_line":204,"code":"\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) OpenNamespace(key string) {\n\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":209,"end_line":228,"code":"\nfunc (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\t// Close ONLY new openNamespaces that are created during\n\t// AppendObject().\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('{')\n\terr := obj.MarshalLogObject(enc)\n\tenc.buf.AppendByte('}')\n\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint16","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint8","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendArray","signature":"func (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error","start_line":210,"end_line":216,"code":"func (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":190,"end_line":209,"code":"\tenc.addKey(key)\n\tenc.buf.AppendByte('{')\n\tenc.openNamespaces++\n}\n\nfunc (enc *jsonEncoder) AddString(key, val string) {\n\tenc.addKey(key)\n\tenc.AppendString(val)\n}\n\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":217,"end_line":236,"code":"\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\t// Close ONLY new openNamespaces that are created during\n\t// AppendObject().\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('{')\n\terr := obj.MarshalLogObject(enc)\n\tenc.buf.AppendByte('}')\n\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendBool(val bool) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendBool(val)\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*errArrayElem).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(ArrayMarshalerFunc).MarshalLogArray","path":"zapcore/marshaler.go"},{"symbol":"(bools).MarshalLogArray","path":"array.go"},{"symbol":"(byteStringsArray).MarshalLogArray","path":"array.go"},{"symbol":"(complex128s).MarshalLogArray","path":"array.go"},{"symbol":"(complex64s).MarshalLogArray","path":"array.go"},{"symbol":"(durations).MarshalLogArray","path":"array.go"},{"symbol":"(errArray).MarshalLogArray","path":"error.go"},{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(float32s).MarshalLogArray","path":"array.go"},{"symbol":"(float64s).MarshalLogArray","path":"array.go"},{"symbol":"(int16s).MarshalLogArray","path":"array.go"},{"symbol":"(int32s).MarshalLogArray","path":"array.go"},{"symbol":"(int64s).MarshalLogArray","path":"array.go"},{"symbol":"(int8s).MarshalLogArray","path":"array.go"},{"symbol":"(ints).MarshalLogArray","path":"array.go"},{"symbol":"(invalidPairs).MarshalLogArray","path":"sugar.go"},{"symbol":"(stringArray).MarshalLogArray","path":"array.go"},{"symbol":"(times).MarshalLogArray","path":"array.go"},{"symbol":"(uint16s).MarshalLogArray","path":"array.go"},{"symbol":"(uint32s).MarshalLogArray","path":"array.go"},{"symbol":"(uint64s).MarshalLogArray","path":"array.go"},{"symbol":"(uint8s).MarshalLogArray","path":"array.go"},{"symbol":"(uintptrs).MarshalLogArray","path":"array.go"},{"symbol":"(uints).MarshalLogArray","path":"array.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendArray","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendObject","signature":"func (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error","start_line":218,"end_line":230,"code":"func (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\n\t\n\t\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('{')\n\terr := obj.MarshalLogObject(enc)\n\tenc.buf.AppendByte('}')\n\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old\n\treturn err\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":198,"end_line":217,"code":"}\n\nfunc (enc *jsonEncoder) AddTime(key string, val time.Time) {\n\tenc.addKey(key)\n\tenc.AppendTime(val)\n}\n\nfunc (enc *jsonEncoder) AddUint64(key string, val uint64) {\n\tenc.addKey(key)\n\tenc.AppendUint64(val)\n}\n\nfunc (enc *jsonEncoder) AppendArray(arr ArrayMarshaler) error {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n"},{"path":"zapcore/json_encoder.go","start_line":231,"end_line":250,"code":"\nfunc (enc *jsonEncoder) AppendBool(val bool) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AppendByteString(val []byte) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddByteString(val)\n\tenc.buf.AppendByte('\"')\n}\n\n// appendComplex appends the encoded form of the provided complex128 value.\n// precision specifies the encoding precision for the real and imaginary\n// components of the complex number.\nfunc (enc *jsonEncoder) appendComplex(val complex128, precision int) {\n\tenc.addElementSeparator()\n\t// Cast to a platform-independent, fixed-size type.\n\tr, i := float64(real(val)), float64(imag(val))"}],"selection":{"visibility":"exported","reason":"encoder","score":0.78},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"zapcore/error.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(ObjectMarshalerFunc).MarshalLogObject","path":"zapcore/marshaler.go"},{"symbol":"(dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*errArrayElem).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(*jsonEncoder).AddObject","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(errArray).MarshalLogArray","path":"error.go"},{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(invalidPairs).MarshalLogArray","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendBool","signature":"func (enc *jsonEncoder) AppendBool(val bool)","start_line":232,"end_line":235,"code":"func (enc *jsonEncoder) AppendBool(val bool) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendBool(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":212,"end_line":231,"code":"\tenc.buf.AppendByte('[')\n\terr := arr.MarshalLogArray(enc)\n\tenc.buf.AppendByte(']')\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\t// Close ONLY new openNamespaces that are created during\n\t// AppendObject().\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('{')\n\terr := obj.MarshalLogObject(enc)\n\tenc.buf.AppendByte('}')\n\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old\n\treturn err\n}\n"},{"path":"zapcore/json_encoder.go","start_line":236,"end_line":255,"code":"\nfunc (enc *jsonEncoder) AppendByteString(val []byte) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddByteString(val)\n\tenc.buf.AppendByte('\"')\n}\n\n// appendComplex appends the encoded form of the provided complex128 value.\n// precision specifies the encoding precision for the real and imaginary\n// components of the complex number.\nfunc (enc *jsonEncoder) appendComplex(val complex128, precision int) {\n\tenc.addElementSeparator()\n\t// Cast to a platform-independent, fixed-size type.\n\tr, i := float64(real(val)), float64(imag(val))\n\tenc.buf.AppendByte('\"')\n\t// Because we're always in a quoted string, we can use strconv without\n\t// special-casing NaN and +/-Inf.\n\tenc.buf.AppendFloat(r, precision)\n\t// If imaginary part is less than 0, minus (-) sign is added by default"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendBool","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendBool","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddBool","path":"zapcore/json_encoder.go"},{"symbol":"(bools).MarshalLogArray","path":"array.go"},{"symbol":"(consoleEncoder).AppendBool","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendByteString","signature":"func (enc *jsonEncoder) AppendByteString(val []byte)","start_line":237,"end_line":242,"code":"func (enc *jsonEncoder) AppendByteString(val []byte) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddByteString(val)\n\tenc.buf.AppendByte('\"')\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":217,"end_line":236,"code":"\nfunc (enc *jsonEncoder) AppendObject(obj ObjectMarshaler) error {\n\t// Close ONLY new openNamespaces that are created during\n\t// AppendObject().\n\told := enc.openNamespaces\n\tenc.openNamespaces = 0\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('{')\n\terr := obj.MarshalLogObject(enc)\n\tenc.buf.AppendByte('}')\n\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendBool(val bool) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendBool(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":243,"end_line":262,"code":"\n// appendComplex appends the encoded form of the provided complex128 value.\n// precision specifies the encoding precision for the real and imaginary\n// components of the complex number.\nfunc (enc *jsonEncoder) appendComplex(val complex128, precision int) {\n\tenc.addElementSeparator()\n\t// Cast to a platform-independent, fixed-size type.\n\tr, i := float64(real(val)), float64(imag(val))\n\tenc.buf.AppendByte('\"')\n\t// Because we're always in a quoted string, we can use strconv without\n\t// special-casing NaN and +/-Inf.\n\tenc.buf.AppendFloat(r, precision)\n\t// If imaginary part is less than 0, minus (-) sign is added by default\n\t// by AppendFloat.\n\tif i \u003e= 0 {\n\t\tenc.buf.AppendByte('+')\n\t}\n\tenc.buf.AppendFloat(i, precision)\n\tenc.buf.AppendByte('i')\n\tenc.buf.AppendByte('\"')"}],"selection":{"visibility":"exported","reason":"encoder","score":0.76},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).safeAddByteString","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddByteString","path":"zapcore/json_encoder.go"},{"symbol":"(byteStringsArray).MarshalLogArray","path":"array.go"},{"symbol":"(consoleEncoder).AppendByteString","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).appendComplex","signature":"func (enc *jsonEncoder) appendComplex(val complex128, precision int)","start_line":247,"end_line":263,"code":"func (enc *jsonEncoder) appendComplex(val complex128, precision int) {\n\n\tenc.addElementSeparator()\n\t\n\tr, i := float64(real(val)), float64(imag(val))\n\tenc.buf.AppendByte('\"')\n\t\n\t\n\tenc.buf.AppendFloat(r, precision)\n\t\n\t\n\tif i \u003e= 0 {\n\t\tenc.buf.AppendByte('+')\n\t}\n\tenc.buf.AppendFloat(i, precision)\n\tenc.buf.AppendByte('i')\n\tenc.buf.AppendByte('\"')\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":227,"end_line":246,"code":"\tenc.closeOpenNamespaces()\n\tenc.openNamespaces = old\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendBool(val bool) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendBool(val)\n}\n\nfunc (enc *jsonEncoder) AppendByteString(val []byte) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddByteString(val)\n\tenc.buf.AppendByte('\"')\n}\n\n// appendComplex appends the encoded form of the provided complex128 value.\n// precision specifies the encoding precision for the real and imaginary\n// components of the complex number."},{"path":"zapcore/json_encoder.go","start_line":264,"end_line":283,"code":"\nfunc (enc *jsonEncoder) AppendDuration(val time.Duration) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeDuration; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeDuration is a no-op. Fall back to nanoseconds to keep\n\t\t// JSON valid.\n\t\tenc.AppendInt64(int64(val))\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendInt64(val int64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendInt(val)\n}\n\nfunc (enc *jsonEncoder) AppendReflected(val interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(val)"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendFloat","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).appendComplex","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).appendComplex","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendDuration","signature":"func (enc *jsonEncoder) AppendDuration(val time.Duration)","start_line":265,"end_line":275,"code":"func (enc *jsonEncoder) AppendDuration(val time.Duration) {\n\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeDuration; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t\n\t\t\n\t\tenc.AppendInt64(int64(val))\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":245,"end_line":264,"code":"// precision specifies the encoding precision for the real and imaginary\n// components of the complex number.\nfunc (enc *jsonEncoder) appendComplex(val complex128, precision int) {\n\tenc.addElementSeparator()\n\t// Cast to a platform-independent, fixed-size type.\n\tr, i := float64(real(val)), float64(imag(val))\n\tenc.buf.AppendByte('\"')\n\t// Because we're always in a quoted string, we can use strconv without\n\t// special-casing NaN and +/-Inf.\n\tenc.buf.AppendFloat(r, precision)\n\t// If imaginary part is less than 0, minus (-) sign is added by default\n\t// by AppendFloat.\n\tif i \u003e= 0 {\n\t\tenc.buf.AppendByte('+')\n\t}\n\tenc.buf.AppendFloat(i, precision)\n\tenc.buf.AppendByte('i')\n\tenc.buf.AppendByte('\"')\n}\n"},{"path":"zapcore/json_encoder.go","start_line":276,"end_line":295,"code":"\nfunc (enc *jsonEncoder) AppendInt64(val int64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendInt(val)\n}\n\nfunc (enc *jsonEncoder) AppendReflected(val interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendString(val string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)"}],"selection":{"visibility":"exported","reason":"encoder","score":0.76},"call_graph":{"callees":[{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"MillisDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"NanosDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"SecondsDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"StringDurationEncoder","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddDuration","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(durations).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendInt64","signature":"func (enc *jsonEncoder) AppendInt64(val int64)","start_line":277,"end_line":280,"code":"func (enc *jsonEncoder) AppendInt64(val int64) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendInt(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":257,"end_line":276,"code":"\tif i \u003e= 0 {\n\t\tenc.buf.AppendByte('+')\n\t}\n\tenc.buf.AppendFloat(i, precision)\n\tenc.buf.AppendByte('i')\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendDuration(val time.Duration) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeDuration; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeDuration is a no-op. Fall back to nanoseconds to keep\n\t\t// JSON valid.\n\t\tenc.AppendInt64(int64(val))\n\t}\n}\n"},{"path":"zapcore/json_encoder.go","start_line":281,"end_line":300,"code":"\nfunc (enc *jsonEncoder) AppendReflected(val interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendString(val string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\tenc.addElementSeparator()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.69},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendInt","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendInt","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendInt16","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendInt32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendInt8","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(int64s).MarshalLogArray","path":"array.go"},{"symbol":"EpochNanosTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"MillisDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"NanosDurationEncoder","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendReflected","signature":"func (enc *jsonEncoder) AppendReflected(val interface{}) error","start_line":282,"end_line":290,"code":"func (enc *jsonEncoder) AppendReflected(val interface{\n}) error {\n\tvalueBytes, err := enc.encodeReflected(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":262,"end_line":281,"code":"\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendDuration(val time.Duration) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeDuration; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeDuration is a no-op. Fall back to nanoseconds to keep\n\t\t// JSON valid.\n\t\tenc.AppendInt64(int64(val))\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendInt64(val int64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendInt(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":291,"end_line":310,"code":"\nfunc (enc *jsonEncoder) AppendString(val string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendTime(time, layout)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).Write","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).encodeReflected","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendReflected","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendReflected","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendString","signature":"func (enc *jsonEncoder) AppendString(val string)","start_line":292,"end_line":297,"code":"func (enc *jsonEncoder) AppendString(val string) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)\n\tenc.buf.AppendByte('\"')\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":272,"end_line":291,"code":"\t\t// JSON valid.\n\t\tenc.AppendInt64(int64(val))\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendInt64(val int64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendInt(val)\n}\n\nfunc (enc *jsonEncoder) AppendReflected(val interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n"},{"path":"zapcore/json_encoder.go","start_line":298,"end_line":317,"code":"\nfunc (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendTime(time, layout)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.89},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).safeAddString","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(stringArray).MarshalLogArray","path":"array.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"CapitalLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"FullCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"FullNameEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"ShortCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"StringDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendTimeLayout","signature":"func (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string)","start_line":299,"end_line":304,"code":"func (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendTime(time, layout)\n\tenc.buf.AppendByte('\"')\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":279,"end_line":298,"code":"\tenc.buf.AppendInt(val)\n}\n\nfunc (enc *jsonEncoder) AppendReflected(val interface{}) error {\n\tvalueBytes, err := enc.encodeReflected(val)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendString(val string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)\n\tenc.buf.AppendByte('\"')\n}\n"},{"path":"zapcore/json_encoder.go","start_line":305,"end_line":324,"code":"\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendTime","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"},{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendTime","signature":"func (enc *jsonEncoder) AppendTime(val time.Time)","start_line":306,"end_line":316,"code":"func (enc *jsonEncoder) AppendTime(val time.Time) {\n\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t\n\t\t\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":286,"end_line":305,"code":"\t}\n\tenc.addElementSeparator()\n\t_, err = enc.buf.Write(valueBytes)\n\treturn err\n}\n\nfunc (enc *jsonEncoder) AppendString(val string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(val)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendTime(time, layout)\n\tenc.buf.AppendByte('\"')\n}\n"},{"path":"zapcore/json_encoder.go","start_line":317,"end_line":336,"code":"\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.76},"call_graph":{"callees":[{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"EpochMillisTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochNanosTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"ISO8601TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"RFC3339NanoTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"RFC3339TimeEncoder","path":"zapcore/encoder.go"},{"symbol":"TimeEncoderOfLayout$1","path":"zapcore/encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddTime","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendTime","path":"zapcore/json_encoder.go"},{"symbol":"(times).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUint64","signature":"func (enc *jsonEncoder) AppendUint64(val uint64)","start_line":318,"end_line":321,"code":"func (enc *jsonEncoder) AppendUint64(val uint64) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":298,"end_line":317,"code":"\nfunc (enc *jsonEncoder) AppendTimeLayout(time time.Time, layout string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendTime(time, layout)\n\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n"},{"path":"zapcore/json_encoder.go","start_line":322,"end_line":341,"code":"\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.68},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendUint","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUint","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUint16","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUint32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUint8","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUint64","path":"zapcore/json_encoder.go"},{"symbol":"(uint64s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddInt","signature":"func (enc *jsonEncoder) AddInt(k string, v int)","start_line":323,"end_line":323,"code":"func (enc *jsonEncoder) AddInt(k string, v int)         {\n enc.AddInt64(k, int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":303,"end_line":322,"code":"\tenc.buf.AppendByte('\"')\n}\n\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n"},{"path":"zapcore/json_encoder.go","start_line":324,"end_line":343,"code":"func (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddInt","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AddInt","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddInt32","signature":"func (enc *jsonEncoder) AddInt32(k string, v int32)","start_line":324,"end_line":324,"code":"func (enc *jsonEncoder) AddInt32(k string, v int32)     {\n enc.AddInt64(k, int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":304,"end_line":323,"code":"}\n\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":325,"end_line":344,"code":"func (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddInt32","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddInt32","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddInt16","signature":"func (enc *jsonEncoder) AddInt16(k string, v int16)","start_line":325,"end_line":325,"code":"func (enc *jsonEncoder) AddInt16(k string, v int16)     {\n enc.AddInt64(k, int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":305,"end_line":324,"code":"\nfunc (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":326,"end_line":345,"code":"func (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddInt16","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddInt16","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddInt8","signature":"func (enc *jsonEncoder) AddInt8(k string, v int8)","start_line":326,"end_line":326,"code":"func (enc *jsonEncoder) AddInt8(k string, v int8)       {\n enc.AddInt64(k, int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":306,"end_line":325,"code":"func (enc *jsonEncoder) AppendTime(val time.Time) {\n\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":327,"end_line":346,"code":"func (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddInt8","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddInt8","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUint","signature":"func (enc *jsonEncoder) AddUint(k string, v uint)","start_line":327,"end_line":327,"code":"func (enc *jsonEncoder) AddUint(k string, v uint)       {\n enc.AddUint64(k, uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":307,"end_line":326,"code":"\tcur := enc.buf.Len()\n\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":328,"end_line":347,"code":"func (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUint","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AddUint","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUint32","signature":"func (enc *jsonEncoder) AddUint32(k string, v uint32)","start_line":328,"end_line":328,"code":"func (enc *jsonEncoder) AddUint32(k string, v uint32)   {\n enc.AddUint64(k, uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":308,"end_line":327,"code":"\tif e := enc.EncodeTime; e != nil {\n\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":329,"end_line":348,"code":"func (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUint32","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddUint32","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUint16","signature":"func (enc *jsonEncoder) AddUint16(k string, v uint16)","start_line":329,"end_line":329,"code":"func (enc *jsonEncoder) AddUint16(k string, v uint16)   {\n enc.AddUint64(k, uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":309,"end_line":328,"code":"\t\te(val, enc)\n\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":330,"end_line":349,"code":"func (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUint16","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddUint16","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUint8","signature":"func (enc *jsonEncoder) AddUint8(k string, v uint8)","start_line":330,"end_line":330,"code":"func (enc *jsonEncoder) AddUint8(k string, v uint8)     {\n enc.AddUint64(k, uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":310,"end_line":329,"code":"\t}\n\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":331,"end_line":350,"code":"func (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUint8","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddUint8","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AddUintptr","signature":"func (enc *jsonEncoder) AddUintptr(k string, v uintptr)","start_line":331,"end_line":331,"code":"func (enc *jsonEncoder) AddUintptr(k string, v uintptr) {\n enc.AddUint64(k, uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":311,"end_line":330,"code":"\tif cur == enc.buf.Len() {\n\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":332,"end_line":351,"code":"func (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AddUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(consoleEncoder).AddUintptr","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendComplex64","signature":"func (enc *jsonEncoder) AppendComplex64(v complex64)","start_line":332,"end_line":332,"code":"func (enc *jsonEncoder) AppendComplex64(v complex64)    {\n enc.appendComplex(complex128(v), 32) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":312,"end_line":331,"code":"\t\t// User-supplied EncodeTime is a no-op. Fall back to nanos since epoch to keep\n\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":333,"end_line":352,"code":"func (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).appendComplex","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(complex64s).MarshalLogArray","path":"array.go"},{"symbol":"(consoleEncoder).AppendComplex64","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendComplex128","signature":"func (enc *jsonEncoder) AppendComplex128(v complex128)","start_line":333,"end_line":333,"code":"func (enc *jsonEncoder) AppendComplex128(v complex128)  {\n enc.appendComplex(complex128(v), 64) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":313,"end_line":332,"code":"\t\t// output JSON valid.\n\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }"},{"path":"zapcore/json_encoder.go","start_line":334,"end_line":353,"code":"func (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).appendComplex","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(complex128s).MarshalLogArray","path":"array.go"},{"symbol":"(consoleEncoder).AppendComplex128","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendFloat64","signature":"func (enc *jsonEncoder) AppendFloat64(v float64)","start_line":334,"end_line":334,"code":"func (enc *jsonEncoder) AppendFloat64(v float64)        {\n enc.appendFloat(v, 64) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":314,"end_line":333,"code":"\t\tenc.AppendInt64(val.UnixNano())\n\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }"},{"path":"zapcore/json_encoder.go","start_line":335,"end_line":354,"code":"func (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).appendFloat","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(float64s).MarshalLogArray","path":"array.go"},{"symbol":"EpochMillisTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"SecondsDurationEncoder","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendFloat32","signature":"func (enc *jsonEncoder) AppendFloat32(v float32)","start_line":335,"end_line":335,"code":"func (enc *jsonEncoder) AppendFloat32(v float32)        {\n enc.appendFloat(float64(v), 32) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":315,"end_line":334,"code":"\t}\n}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }"},{"path":"zapcore/json_encoder.go","start_line":336,"end_line":355,"code":"func (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).appendFloat","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(float32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendInt","signature":"func (enc *jsonEncoder) AppendInt(v int)","start_line":336,"end_line":336,"code":"func (enc *jsonEncoder) AppendInt(v int)                {\n enc.AppendInt64(int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":316,"end_line":335,"code":"}\n\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }"},{"path":"zapcore/json_encoder.go","start_line":337,"end_line":356,"code":"func (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendInt","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendInt","path":"zapcore/json_encoder.go"},{"symbol":"(ints).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendInt32","signature":"func (enc *jsonEncoder) AppendInt32(v int32)","start_line":337,"end_line":337,"code":"func (enc *jsonEncoder) AppendInt32(v int32)            {\n enc.AppendInt64(int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":317,"end_line":336,"code":"\nfunc (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":338,"end_line":357,"code":"func (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendInt32","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendInt32","path":"zapcore/json_encoder.go"},{"symbol":"(int32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendInt16","signature":"func (enc *jsonEncoder) AppendInt16(v int16)","start_line":338,"end_line":338,"code":"func (enc *jsonEncoder) AppendInt16(v int16)            {\n enc.AppendInt64(int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":318,"end_line":337,"code":"func (enc *jsonEncoder) AppendUint64(val uint64) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":339,"end_line":358,"code":"func (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendInt16","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendInt16","path":"zapcore/json_encoder.go"},{"symbol":"(int16s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendInt8","signature":"func (enc *jsonEncoder) AppendInt8(v int8)","start_line":339,"end_line":339,"code":"func (enc *jsonEncoder) AppendInt8(v int8)              {\n enc.AppendInt64(int64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":319,"end_line":338,"code":"\tenc.addElementSeparator()\n\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":340,"end_line":359,"code":"func (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendInt8","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendInt8","path":"zapcore/json_encoder.go"},{"symbol":"(int8s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUint","signature":"func (enc *jsonEncoder) AppendUint(v uint)","start_line":340,"end_line":340,"code":"func (enc *jsonEncoder) AppendUint(v uint)              {\n enc.AppendUint64(uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":320,"end_line":339,"code":"\tenc.buf.AppendUint(val)\n}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":341,"end_line":360,"code":"func (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUint","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUint","path":"zapcore/json_encoder.go"},{"symbol":"(uints).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUint32","signature":"func (enc *jsonEncoder) AppendUint32(v uint32)","start_line":341,"end_line":341,"code":"func (enc *jsonEncoder) AppendUint32(v uint32)          {\n enc.AppendUint64(uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":321,"end_line":340,"code":"}\n\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":342,"end_line":361,"code":"func (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUint32","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUint32","path":"zapcore/json_encoder.go"},{"symbol":"(uint32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUint16","signature":"func (enc *jsonEncoder) AppendUint16(v uint16)","start_line":342,"end_line":342,"code":"func (enc *jsonEncoder) AppendUint16(v uint16)          {\n enc.AppendUint64(uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":322,"end_line":341,"code":"\nfunc (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":343,"end_line":362,"code":"func (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tfinal := enc.clone()"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUint16","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUint16","path":"zapcore/json_encoder.go"},{"symbol":"(uint16s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUint8","signature":"func (enc *jsonEncoder) AppendUint8(v uint8)","start_line":343,"end_line":343,"code":"func (enc *jsonEncoder) AppendUint8(v uint8)            {\n enc.AppendUint64(uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":323,"end_line":342,"code":"func (enc *jsonEncoder) AddInt(k string, v int)         { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":344,"end_line":363,"code":"func (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tfinal := enc.clone()\n\tfinal.buf.AppendByte('{')"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUint8","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUint8","path":"zapcore/json_encoder.go"},{"symbol":"(uint8s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).AppendUintptr","signature":"func (enc *jsonEncoder) AppendUintptr(v uintptr)","start_line":344,"end_line":344,"code":"func (enc *jsonEncoder) AppendUintptr(v uintptr)        {\n enc.AppendUint64(uint64(v)) }\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":324,"end_line":343,"code":"func (enc *jsonEncoder) AddInt32(k string, v int32)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt16(k string, v int16)     { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }"},{"path":"zapcore/json_encoder.go","start_line":345,"end_line":364,"code":"\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tfinal := enc.clone()\n\tfinal.buf.AppendByte('{')\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":[{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).AppendUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).AppendUintptr","path":"zapcore/json_encoder.go"},{"symbol":"(uintptrs).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).Clone","signature":"func (enc *jsonEncoder) Clone() Encoder","start_line":346,"end_line":350,"code":"func (enc *jsonEncoder) Clone() Encoder {\n\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":326,"end_line":345,"code":"func (enc *jsonEncoder) AddInt8(k string, v int8)       { enc.AddInt64(k, int64(v)) }\nfunc (enc *jsonEncoder) AddUint(k string, v uint)       { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint32(k string, v uint32)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint16(k string, v uint16)   { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUint8(k string, v uint8)     { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AddUintptr(k string, v uintptr) { enc.AddUint64(k, uint64(v)) }\nfunc (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n"},{"path":"zapcore/json_encoder.go","start_line":351,"end_line":370,"code":"\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tfinal := enc.clone()\n\tfinal.buf.AppendByte('{')\n\n\tif final.LevelKey != \"\" \u0026\u0026 final.EncodeLevel != nil {\n\t\tfinal.addKey(final.LevelKey)\n\t\tcur := final.buf.Len()\n\t\tfinal.EncodeLevel(ent.Level, final)\n\t\tif cur == final.buf.Len() {\n\t\t\t// User-supplied EncodeLevel was a no-op. Fall back to strings to keep"}],"selection":{"visibility":"exported","reason":"encoder","score":0.76},"call_graph":{"callees":[{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Write","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).clone","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*ioCore).clone","path":"zapcore/core.go"},{"symbol":"(consoleEncoder).Clone","path":"zapcore/console_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).clone","signature":"func (enc *jsonEncoder) clone() *jsonEncoder","start_line":352,"end_line":359,"code":"func (enc *jsonEncoder) clone() *jsonEncoder {\n\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":332,"end_line":351,"code":"func (enc *jsonEncoder) AppendComplex64(v complex64)    { enc.appendComplex(complex128(v), 32) }\nfunc (enc *jsonEncoder) AppendComplex128(v complex128)  { enc.appendComplex(complex128(v), 64) }\nfunc (enc *jsonEncoder) AppendFloat64(v float64)        { enc.appendFloat(v, 64) }\nfunc (enc *jsonEncoder) AppendFloat32(v float32)        { enc.appendFloat(float64(v), 32) }\nfunc (enc *jsonEncoder) AppendInt(v int)                { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt32(v int32)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt16(v int16)            { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendInt8(v int8)              { enc.AppendInt64(int64(v)) }\nfunc (enc *jsonEncoder) AppendUint(v uint)              { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n"},{"path":"zapcore/json_encoder.go","start_line":360,"end_line":379,"code":"\nfunc (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\tfinal := enc.clone()\n\tfinal.buf.AppendByte('{')\n\n\tif final.LevelKey != \"\" \u0026\u0026 final.EncodeLevel != nil {\n\t\tfinal.addKey(final.LevelKey)\n\t\tcur := final.buf.Len()\n\t\tfinal.EncodeLevel(ent.Level, final)\n\t\tif cur == final.buf.Len() {\n\t\t\t// User-supplied EncodeLevel was a no-op. Fall back to strings to keep\n\t\t\t// output JSON valid.\n\t\t\tfinal.AppendString(ent.Level.String())\n\t\t}\n\t}\n\tif final.TimeKey != \"\" \u0026\u0026 !ent.Time.IsZero() {\n\t\tfinal.AddTime(final.TimeKey, ent.Time)\n\t}\n\tif ent.LoggerName != \"\" \u0026\u0026 final.NameKey != \"\" {\n\t\tfinal.addKey(final.NameKey)"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.59},"call_graph":{"callees":[{"symbol":"(*Pool).Get[*go.uber.org/zap/zapcore.jsonEncoder]","path":"internal/pool/pool.go"},{"symbol":"(Pool).Get","path":"buffer/pool.go"},{"symbol":"NewPool$1","path":"buffer/pool.go"}],"callers":[{"symbol":"(*consoleEncoder).clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).Clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).clone","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).EncodeEntry","signature":"func (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error)","start_line":361,"end_line":431,"code":"func (enc *jsonEncoder) EncodeEntry(ent Entry, fields []Field) (*buffer.Buffer, error) {\n\n\tfinal := enc.clone()\n\tfinal.buf.AppendByte('{')\n\n\tif final.LevelKey != \"\" \u0026\u0026 final.EncodeLevel != nil {\n\t\tfinal.addKey(final.LevelKey)\n\t\tcur := final.buf.Len()\n\t\tfinal.EncodeLevel(ent.Level, final)\n\t\tif cur == final.buf.Len() {\n\t\t\t\n\t\t\t\n\t\t\tfinal.AppendString(ent.Level.String())\n\t\t}\n\t}\n\tif final.TimeKey != \"\" \u0026\u0026 !ent.Time.IsZero() {\n\t\tfinal.AddTime(final.TimeKey, ent.Time)\n\t}\n\tif ent.LoggerName != \"\" \u0026\u0026 final.NameKey != \"\" {\n\t\tfinal.addKey(final.NameKey)\n\t\tcur := final.buf.Len()\n\t\tnameEncoder := final.EncodeName\n\n\t\t\n\t\t\n\t\tif nameEncoder == nil {\n\t\t\tnameEncoder = FullNameEncoder\n\t\t}\n\n\t\tnameEncoder(ent.LoggerName, final)\n\t\tif cur == final.buf.Len() {\n\t\t\t\n\t\t\t\n\t\t\tfinal.AppendString(ent.LoggerName)\n\t\t}\n\t}\n\tif ent.Caller.Defined {\n\t\tif final.CallerKey != \"\" {\n\t\t\tfinal.addKey(final.CallerKey)\n\t\t\tcur := final.buf.Len()\n\t\t\tfinal.EncodeCaller(ent.Caller, final)\n\t\t\tif cur == final.buf.Len() {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfinal.AppendString(ent.Caller.String())\n\t\t\t}\n\t\t}\n\t\tif final.FunctionKey != \"\" {\n\t\t\tfinal.addKey(final.FunctionKey)\n\t\t\tfinal.AppendString(ent.Caller.Function)\n\t\t}\n\t}\n\tif final.MessageKey != \"\" {\n\t\tfinal.addKey(enc.MessageKey)\n\t\tfinal.AppendString(ent.Message)\n\t}\n\tif enc.buf.Len() \u003e 0 {\n\t\tfinal.addElementSeparator()\n\t\tfinal.buf.Write(enc.buf.Bytes())\n\t}\n\taddFields(final, fields)\n\tfinal.closeOpenNamespaces()\n\tif ent.Stack != \"\" \u0026\u0026 final.StacktraceKey != \"\" {\n\t\tfinal.AddString(final.StacktraceKey, ent.Stack)\n\t}\n\tfinal.buf.AppendByte('}')\n\tfinal.buf.AppendString(final.LineEnding)\n\n\tret := final.buf\n\tputJSONEncoder(final)\n\treturn ret, nil\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":341,"end_line":360,"code":"func (enc *jsonEncoder) AppendUint32(v uint32)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint16(v uint16)          { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUint8(v uint8)            { enc.AppendUint64(uint64(v)) }\nfunc (enc *jsonEncoder) AppendUintptr(v uintptr)        { enc.AppendUint64(uint64(v)) }\n\nfunc (enc *jsonEncoder) Clone() Encoder {\n\tclone := enc.clone()\n\tclone.buf.Write(enc.buf.Bytes())\n\treturn clone\n}\n\nfunc (enc *jsonEncoder) clone() *jsonEncoder {\n\tclone := _jsonPool.Get()\n\tclone.EncoderConfig = enc.EncoderConfig\n\tclone.spaced = enc.spaced\n\tclone.openNamespaces = enc.openNamespaces\n\tclone.buf = bufferpool.Get()\n\treturn clone\n}\n"},{"path":"zapcore/json_encoder.go","start_line":432,"end_line":451,"code":"\nfunc (enc *jsonEncoder) truncate() {\n\tenc.buf.Reset()\n}\n\nfunc (enc *jsonEncoder) closeOpenNamespaces() {\n\tfor i := 0; i \u003c enc.openNamespaces; i++ {\n\t\tenc.buf.AppendByte('}')\n\t}\n\tenc.openNamespaces = 0\n}\n\nfunc (enc *jsonEncoder) addKey(key string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(key)\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendByte(':')\n\tif enc.spaced {\n\t\tenc.buf.AppendByte(' ')"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Write","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).clone","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(EntryCaller).String","path":"zapcore/entry.go"},{"symbol":"(Level).String","path":"zapcore/level.go"},{"symbol":"(Time).IsZero","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"CapitalLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"FullCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"FullNameEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"ShortCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"addFields","path":"zapcore/field.go"},{"symbol":"putJSONEncoder","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*ioCore).Write","path":"zapcore/core.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).truncate","signature":"func (enc *jsonEncoder) truncate()","start_line":433,"end_line":435,"code":"func (enc *jsonEncoder) truncate() {\n\n\tenc.buf.Reset()\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":413,"end_line":432,"code":"\t\tfinal.addKey(enc.MessageKey)\n\t\tfinal.AppendString(ent.Message)\n\t}\n\tif enc.buf.Len() \u003e 0 {\n\t\tfinal.addElementSeparator()\n\t\tfinal.buf.Write(enc.buf.Bytes())\n\t}\n\taddFields(final, fields)\n\tfinal.closeOpenNamespaces()\n\tif ent.Stack != \"\" \u0026\u0026 final.StacktraceKey != \"\" {\n\t\tfinal.AddString(final.StacktraceKey, ent.Stack)\n\t}\n\tfinal.buf.AppendByte('}')\n\tfinal.buf.AppendString(final.LineEnding)\n\n\tret := final.buf\n\tputJSONEncoder(final)\n\treturn ret, nil\n}\n"},{"path":"zapcore/json_encoder.go","start_line":436,"end_line":455,"code":"\nfunc (enc *jsonEncoder) closeOpenNamespaces() {\n\tfor i := 0; i \u003c enc.openNamespaces; i++ {\n\t\tenc.buf.AppendByte('}')\n\t}\n\tenc.openNamespaces = 0\n}\n\nfunc (enc *jsonEncoder) addKey(key string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(key)\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendByte(':')\n\tif enc.spaced {\n\t\tenc.buf.AppendByte(' ')\n\t}\n}\n\nfunc (enc *jsonEncoder) addElementSeparator() {"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.45},"call_graph":{"callees":[{"symbol":"(*Buffer).Reset","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*consoleEncoder).truncate","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).truncate","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).closeOpenNamespaces","signature":"func (enc *jsonEncoder) closeOpenNamespaces()","start_line":437,"end_line":442,"code":"func (enc *jsonEncoder) closeOpenNamespaces() {\n\n\tfor i := 0; i \u003c enc.openNamespaces; i++ {\n\t\tenc.buf.AppendByte('}')\n\t}\n\tenc.openNamespaces = 0\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":417,"end_line":436,"code":"\t\tfinal.addElementSeparator()\n\t\tfinal.buf.Write(enc.buf.Bytes())\n\t}\n\taddFields(final, fields)\n\tfinal.closeOpenNamespaces()\n\tif ent.Stack != \"\" \u0026\u0026 final.StacktraceKey != \"\" {\n\t\tfinal.AddString(final.StacktraceKey, ent.Stack)\n\t}\n\tfinal.buf.AppendByte('}')\n\tfinal.buf.AppendString(final.LineEnding)\n\n\tret := final.buf\n\tputJSONEncoder(final)\n\treturn ret, nil\n}\n\nfunc (enc *jsonEncoder) truncate() {\n\tenc.buf.Reset()\n}\n"},{"path":"zapcore/json_encoder.go","start_line":443,"end_line":462,"code":"\nfunc (enc *jsonEncoder) addKey(key string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(key)\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendByte(':')\n\tif enc.spaced {\n\t\tenc.buf.AppendByte(' ')\n\t}\n}\n\nfunc (enc *jsonEncoder) addElementSeparator() {\n\tlast := enc.buf.Len() - 1\n\tif last \u003c 0 {\n\t\treturn\n\t}\n\tswitch enc.buf.Bytes()[last] {\n\tcase '{', '[', ':', ',', ' ':\n\t\treturn"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*consoleEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).closeOpenNamespaces","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).writeContext","path":"zapcore/console_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).addKey","signature":"func (enc *jsonEncoder) addKey(key string)","start_line":444,"end_line":453,"code":"func (enc *jsonEncoder) addKey(key string) {\n\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(key)\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendByte(':')\n\tif enc.spaced {\n\t\tenc.buf.AppendByte(' ')\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":424,"end_line":443,"code":"\t}\n\tfinal.buf.AppendByte('}')\n\tfinal.buf.AppendString(final.LineEnding)\n\n\tret := final.buf\n\tputJSONEncoder(final)\n\treturn ret, nil\n}\n\nfunc (enc *jsonEncoder) truncate() {\n\tenc.buf.Reset()\n}\n\nfunc (enc *jsonEncoder) closeOpenNamespaces() {\n\tfor i := 0; i \u003c enc.openNamespaces; i++ {\n\t\tenc.buf.AppendByte('}')\n\t}\n\tenc.openNamespaces = 0\n}\n"},{"path":"zapcore/json_encoder.go","start_line":454,"end_line":473,"code":"\nfunc (enc *jsonEncoder) addElementSeparator() {\n\tlast := enc.buf.Len() - 1\n\tif last \u003c 0 {\n\t\treturn\n\t}\n\tswitch enc.buf.Bytes()[last] {\n\tcase '{', '[', ':', ',', ' ':\n\t\treturn\n\tdefault:\n\t\tenc.buf.AppendByte(',')\n\t\tif enc.spaced {\n\t\t\tenc.buf.AppendByte(' ')\n\t\t}\n\t}\n}\n\nfunc (enc *jsonEncoder) appendFloat(val float64, bitSize int) {\n\tenc.addElementSeparator()\n\tswitch {"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.63},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).safeAddString","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddBool","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddComplex128","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddComplex64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddDuration","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddTime","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AddUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).OpenNamespace","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).addKey","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).addElementSeparator","signature":"func (enc *jsonEncoder) addElementSeparator()","start_line":455,"end_line":469,"code":"func (enc *jsonEncoder) addElementSeparator() {\n\n\tlast := enc.buf.Len() - 1\n\tif last \u003c 0 {\n\t\treturn\n\t}\n\tswitch enc.buf.Bytes()[last] {\n\tcase '{', '[', ':', ',', ' ':\n\t\treturn\n\tdefault:\n\t\tenc.buf.AppendByte(',')\n\t\tif enc.spaced {\n\t\t\tenc.buf.AppendByte(' ')\n\t\t}\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":435,"end_line":454,"code":"}\n\nfunc (enc *jsonEncoder) closeOpenNamespaces() {\n\tfor i := 0; i \u003c enc.openNamespaces; i++ {\n\t\tenc.buf.AppendByte('}')\n\t}\n\tenc.openNamespaces = 0\n}\n\nfunc (enc *jsonEncoder) addKey(key string) {\n\tenc.addElementSeparator()\n\tenc.buf.AppendByte('\"')\n\tenc.safeAddString(key)\n\tenc.buf.AppendByte('\"')\n\tenc.buf.AppendByte(':')\n\tif enc.spaced {\n\t\tenc.buf.AppendByte(' ')\n\t}\n}\n"},{"path":"zapcore/json_encoder.go","start_line":470,"end_line":489,"code":"\nfunc (enc *jsonEncoder) appendFloat(val float64, bitSize int) {\n\tenc.addElementSeparator()\n\tswitch {\n\tcase math.IsNaN(val):\n\t\tenc.buf.AppendString(`\"NaN\"`)\n\tcase math.IsInf(val, 1):\n\t\tenc.buf.AppendString(`\"+Inf\"`)\n\tcase math.IsInf(val, -1):\n\t\tenc.buf.AppendString(`\"-Inf\"`)\n\tdefault:\n\t\tenc.buf.AppendFloat(val, bitSize)\n\t}\n}\n\n// safeAddString JSON-escapes a string and appends it to the internal buffer.\n// Unlike the standard library's encoder, it doesn't attempt to protect the\n// user from browser vulnerabilities or JSONP-related problems.\nfunc (enc *jsonEncoder) safeAddString(s string) {\n\tsafeAppendStringLike("}],"selection":{"visibility":"unexported","reason":"encoder","score":0.6},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Bytes","path":"buffer/buffer.go"},{"symbol":"(*Buffer).Len","path":"buffer/buffer.go"}],"callers":[{"symbol":"(*consoleEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendBool","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendInt64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendReflected","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendTimeLayout","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendUint64","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).appendComplex","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).appendFloat","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).addElementSeparator","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).appendFloat","signature":"func (enc *jsonEncoder) appendFloat(val float64, bitSize int)","start_line":471,"end_line":483,"code":"func (enc *jsonEncoder) appendFloat(val float64, bitSize int) {\n\n\tenc.addElementSeparator()\n\tswitch {\n\tcase math.IsNaN(val):\n\t\tenc.buf.AppendString(`\"NaN\"`)\n\tcase math.IsInf(val, 1):\n\t\tenc.buf.AppendString(`\"+Inf\"`)\n\tcase math.IsInf(val, -1):\n\t\tenc.buf.AppendString(`\"-Inf\"`)\n\tdefault:\n\t\tenc.buf.AppendFloat(val, bitSize)\n\t}\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":451,"end_line":470,"code":"\t\tenc.buf.AppendByte(' ')\n\t}\n}\n\nfunc (enc *jsonEncoder) addElementSeparator() {\n\tlast := enc.buf.Len() - 1\n\tif last \u003c 0 {\n\t\treturn\n\t}\n\tswitch enc.buf.Bytes()[last] {\n\tcase '{', '[', ':', ',', ' ':\n\t\treturn\n\tdefault:\n\t\tenc.buf.AppendByte(',')\n\t\tif enc.spaced {\n\t\t\tenc.buf.AppendByte(' ')\n\t\t}\n\t}\n}\n"},{"path":"zapcore/json_encoder.go","start_line":484,"end_line":503,"code":"\n// safeAddString JSON-escapes a string and appends it to the internal buffer.\n// Unlike the standard library's encoder, it doesn't attempt to protect the\n// user from browser vulnerabilities or JSONP-related problems.\nfunc (enc *jsonEncoder) safeAddString(s string) {\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendString,\n\t\tutf8.DecodeRuneInString,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n\n// safeAddByteString is no-alloc equivalent of safeAddString(string(s)) for s []byte.\nfunc (enc *jsonEncoder) safeAddByteString(s []byte) {\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendBytes,\n\t\tutf8.DecodeRune,\n\t\tenc.buf,\n\t\ts,"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendFloat","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"},{"symbol":"(*jsonEncoder).addElementSeparator","path":"zapcore/json_encoder.go"},{"symbol":"IsInf","path":"../../../../usr/local/go/src/math/bits.go"},{"symbol":"IsNaN","path":"../../../../usr/local/go/src/math/bits.go"}],"callers":[{"symbol":"(*consoleEncoder).appendFloat","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendFloat32","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendFloat64","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).appendFloat","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).safeAddString","signature":"func (enc *jsonEncoder) safeAddString(s string)","start_line":488,"end_line":495,"code":"func (enc *jsonEncoder) safeAddString(s string) {\n\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendString,\n\t\tutf8.DecodeRuneInString,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":468,"end_line":487,"code":"\t}\n}\n\nfunc (enc *jsonEncoder) appendFloat(val float64, bitSize int) {\n\tenc.addElementSeparator()\n\tswitch {\n\tcase math.IsNaN(val):\n\t\tenc.buf.AppendString(`\"NaN\"`)\n\tcase math.IsInf(val, 1):\n\t\tenc.buf.AppendString(`\"+Inf\"`)\n\tcase math.IsInf(val, -1):\n\t\tenc.buf.AppendString(`\"-Inf\"`)\n\tdefault:\n\t\tenc.buf.AppendFloat(val, bitSize)\n\t}\n}\n\n// safeAddString JSON-escapes a string and appends it to the internal buffer.\n// Unlike the standard library's encoder, it doesn't attempt to protect the\n// user from browser vulnerabilities or JSONP-related problems."},{"path":"zapcore/json_encoder.go","start_line":496,"end_line":515,"code":"\n// safeAddByteString is no-alloc equivalent of safeAddString(string(s)) for s []byte.\nfunc (enc *jsonEncoder) safeAddByteString(s []byte) {\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendBytes,\n\t\tutf8.DecodeRune,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n\n// safeAppendStringLike is a generic implementation of safeAddString and safeAddByteString.\n// It appends a string or byte slice to the buffer, escaping all special characters.\nfunc safeAppendStringLike[S []byte | string](\n\t// appendTo appends this string-like object to the buffer.\n\tappendTo func(*buffer.Buffer, S),\n\t// decodeRune decodes the next rune from the string-like object\n\t// and returns its value and width in bytes.\n\tdecodeRune func(S) (rune, int),\n\tbuf *buffer.Buffer,"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"safeAppendStringLike[string]","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).safeAddString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).addKey","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).safeAddString","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"(*jsonEncoder).safeAddByteString","signature":"func (enc *jsonEncoder) safeAddByteString(s []byte)","start_line":498,"end_line":505,"code":"func (enc *jsonEncoder) safeAddByteString(s []byte) {\n\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendBytes,\n\t\tutf8.DecodeRune,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":478,"end_line":497,"code":"\tcase math.IsInf(val, -1):\n\t\tenc.buf.AppendString(`\"-Inf\"`)\n\tdefault:\n\t\tenc.buf.AppendFloat(val, bitSize)\n\t}\n}\n\n// safeAddString JSON-escapes a string and appends it to the internal buffer.\n// Unlike the standard library's encoder, it doesn't attempt to protect the\n// user from browser vulnerabilities or JSONP-related problems.\nfunc (enc *jsonEncoder) safeAddString(s string) {\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendString,\n\t\tutf8.DecodeRuneInString,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n\n// safeAddByteString is no-alloc equivalent of safeAddString(string(s)) for s []byte."},{"path":"zapcore/json_encoder.go","start_line":506,"end_line":525,"code":"\n// safeAppendStringLike is a generic implementation of safeAddString and safeAddByteString.\n// It appends a string or byte slice to the buffer, escaping all special characters.\nfunc safeAppendStringLike[S []byte | string](\n\t// appendTo appends this string-like object to the buffer.\n\tappendTo func(*buffer.Buffer, S),\n\t// decodeRune decodes the next rune from the string-like object\n\t// and returns its value and width in bytes.\n\tdecodeRune func(S) (rune, int),\n\tbuf *buffer.Buffer,\n\ts S,\n) {\n\t// The encoding logic below works by skipping over characters\n\t// that can be safely copied as-is,\n\t// until a character is found that needs special handling.\n\t// At that point, we copy everything we've seen so far,\n\t// and then handle that special character.\n\t//\n\t// last is the index of the last byte that was copied to the buffer.\n\tlast := 0"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.55},"call_graph":{"callees":[{"symbol":"safeAppendStringLike[[]byte]","path":"zapcore/json_encoder.go"}],"callers":[{"symbol":"(*consoleEncoder).safeAddByteString","path":"zapcore/json_encoder.go"},{"symbol":"(*jsonEncoder).AppendByteString","path":"zapcore/json_encoder.go"},{"symbol":"(consoleEncoder).safeAddByteString","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/json_encoder.go","symbol":"safeAppendStringLike","signature":"func safeAppendStringLike[S []byte | string](\n\t// appendTo appends this string-like object to the buffer.\n\tappendTo func(*buffer.Buffer, S),\n\t// decodeRune decodes the next rune from the string-like object\n\t// and returns its value and width in bytes.\n\tdecodeRune func(S) (rune, int),\n\tbuf *buffer.Buffer,\n\ts S,\n)","start_line":509,"end_line":583,"code":"func safeAppendStringLike[S []byte | string](\n\t// appendTo appends this string-like object to the buffer.\n\tappendTo func(*buffer.Buffer, S),\n\t// decodeRune decodes the next rune from the string-like object\n\t// and returns its value and width in bytes.\n\tdecodeRune func(S) (rune, int),\n\tbuf *buffer.Buffer,\n\ts S,\n) {\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tlast := 0\n\tfor i := 0; i \u003c len(s); {\n\t\tif s[i] \u003e= utf8.RuneSelf {\n\t\t\t\n\t\t\t\n\t\t\tr, size := decodeRune(s[i:])\n\t\t\tif r != utf8.RuneError || size != 1 {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\ti += size\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tappendTo(buf, s[last:i])\n\t\t\tbuf.AppendString(`\\ufffd`)\n\n\t\t\ti++\n\t\t\tlast = i\n\t\t} else {\n\t\t\t\n\t\t\tif s[i] \u003e= 0x20 \u0026\u0026 s[i] != '\\\\' \u0026\u0026 s[i] != '\"' {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\ti++\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t\n\t\t\tappendTo(buf, s[last:i])\n\t\t\tswitch s[i] {\n\t\t\tcase '\\\\', '\"':\n\t\t\t\tbuf.AppendByte('\\\\')\n\t\t\t\tbuf.AppendByte(s[i])\n\t\t\tcase '\\n':\n\t\t\t\tbuf.AppendByte('\\\\')\n\t\t\t\tbuf.AppendByte('n')\n\t\t\tcase '\\r':\n\t\t\t\tbuf.AppendByte('\\\\')\n\t\t\t\tbuf.AppendByte('r')\n\t\t\tcase '\\t':\n\t\t\t\tbuf.AppendByte('\\\\')\n\t\t\t\tbuf.AppendByte('t')\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tbuf.AppendString(`\\u00`)\n\t\t\t\tbuf.AppendByte(_hex[s[i]\u003e\u003e4])\n\t\t\t\tbuf.AppendByte(_hex[s[i]\u00260xF])\n\t\t\t}\n\n\t\t\ti++\n\t\t\tlast = i\n\t\t}\n\t}\n\n\t\n\tappendTo(buf, s[last:])\n}\n","neighbors":[{"path":"zapcore/json_encoder.go","start_line":489,"end_line":508,"code":"\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendString,\n\t\tutf8.DecodeRuneInString,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n\n// safeAddByteString is no-alloc equivalent of safeAddString(string(s)) for s []byte.\nfunc (enc *jsonEncoder) safeAddByteString(s []byte) {\n\tsafeAppendStringLike(\n\t\t(*buffer.Buffer).AppendBytes,\n\t\tutf8.DecodeRune,\n\t\tenc.buf,\n\t\ts,\n\t)\n}\n\n// safeAppendStringLike is a generic implementation of safeAddString and safeAddByteString.\n// It appends a string or byte slice to the buffer, escaping all special characters."}],"selection":{"visibility":"unexported","reason":"encoder","score":0.56},"call_graph":{"callees":[{"symbol":"(*Buffer).AppendByte","path":"buffer/buffer.go"},{"symbol":"(*Buffer).AppendString","path":"buffer/buffer.go"}],"callers":[{"symbol":"safeAppendStringLike[[]byte]","path":"zapcore/json_encoder.go"},{"symbol":"safeAppendStringLike[string]","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/lazy_with.go","symbol":"NewLazyWith","signature":"func NewLazyWith(core Core, fields []Field) Core","start_line":33,"end_line":38,"code":"func NewLazyWith(core Core, fields []Field) Core {\n\n\treturn \u0026lazyWithCore{\n\t\tCore:   core,\n\t\tfields: fields,\n\t}\n}\n","neighbors":[{"path":"zapcore/lazy_with.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zapcore\n\nimport \"sync\"\n\ntype lazyWithCore struct {\n\tCore\n\tsync.Once\n\tfields []Field\n}\n\n// NewLazyWith wraps a Core with a \"lazy\" Core that will only encode fields if\n// the logger is written to (or is further chained in a lon-lazy manner)."},{"path":"zapcore/lazy_with.go","start_line":39,"end_line":55,"code":"\nfunc (d *lazyWithCore) initOnce() {\n\td.Once.Do(func() {\n\t\td.Core = d.Core.With(d.fields)\n\t})\n}\n\nfunc (d *lazyWithCore) With(fields []Field) Core {\n\td.initOnce()\n\treturn d.Core.With(fields)\n}\n\nfunc (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry {\n\td.initOnce()\n\treturn d.Core.Check(e, ce)\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"WithLazy$1","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/lazy_with.go","symbol":"(*lazyWithCore).initOnce","signature":"func (d *lazyWithCore) initOnce()","start_line":40,"end_line":44,"code":"func (d *lazyWithCore) initOnce() {\n\n\td.Once.Do(func() {\n\t\td.Core = d.Core.With(d.fields)\n\t})\n}\n","neighbors":[{"path":"zapcore/lazy_with.go","start_line":20,"end_line":39,"code":"\npackage zapcore\n\nimport \"sync\"\n\ntype lazyWithCore struct {\n\tCore\n\tsync.Once\n\tfields []Field\n}\n\n// NewLazyWith wraps a Core with a \"lazy\" Core that will only encode fields if\n// the logger is written to (or is further chained in a lon-lazy manner).\nfunc NewLazyWith(core Core, fields []Field) Core {\n\treturn \u0026lazyWithCore{\n\t\tCore:   core,\n\t\tfields: fields,\n\t}\n}\n"},{"path":"zapcore/lazy_with.go","start_line":45,"end_line":55,"code":"\nfunc (d *lazyWithCore) With(fields []Field) Core {\n\td.initOnce()\n\treturn d.Core.With(fields)\n}\n\nfunc (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry {\n\td.initOnce()\n\treturn d.Core.Check(e, ce)\n}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.51},"call_graph":{"callees":[{"symbol":"(*Once).Do","path":"../../../../usr/local/go/src/sync/once.go"}],"callers":[{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/lazy_with.go","symbol":"(*lazyWithCore).With","signature":"func (d *lazyWithCore) With(fields []Field) Core","start_line":46,"end_line":49,"code":"func (d *lazyWithCore) With(fields []Field) Core {\n\n\td.initOnce()\n\treturn d.Core.With(fields)\n}\n","neighbors":[{"path":"zapcore/lazy_with.go","start_line":26,"end_line":45,"code":"\tCore\n\tsync.Once\n\tfields []Field\n}\n\n// NewLazyWith wraps a Core with a \"lazy\" Core that will only encode fields if\n// the logger is written to (or is further chained in a lon-lazy manner).\nfunc NewLazyWith(core Core, fields []Field) Core {\n\treturn \u0026lazyWithCore{\n\t\tCore:   core,\n\t\tfields: fields,\n\t}\n}\n\nfunc (d *lazyWithCore) initOnce() {\n\td.Once.Do(func() {\n\t\td.Core = d.Core.With(d.fields)\n\t})\n}\n"},{"path":"zapcore/lazy_with.go","start_line":50,"end_line":55,"code":"\nfunc (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry {\n\td.initOnce()\n\treturn d.Core.Check(e, ce)\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.79},"call_graph":{"callees":[{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*lazyWithCore).initOnce","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/lazy_with.go","symbol":"(*lazyWithCore).Check","signature":"func (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry","start_line":51,"end_line":54,"code":"func (d *lazyWithCore) Check(e Entry, ce *CheckedEntry) *CheckedEntry {\n\n\td.initOnce()\n\treturn d.Core.Check(e, ce)\n}\n","neighbors":[{"path":"zapcore/lazy_with.go","start_line":31,"end_line":50,"code":"// NewLazyWith wraps a Core with a \"lazy\" Core that will only encode fields if\n// the logger is written to (or is further chained in a lon-lazy manner).\nfunc NewLazyWith(core Core, fields []Field) Core {\n\treturn \u0026lazyWithCore{\n\t\tCore:   core,\n\t\tfields: fields,\n\t}\n}\n\nfunc (d *lazyWithCore) initOnce() {\n\td.Once.Do(func() {\n\t\td.Core = d.Core.With(d.fields)\n\t})\n}\n\nfunc (d *lazyWithCore) With(fields []Field) Core {\n\td.initOnce()\n\treturn d.Core.With(fields)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.64},"call_graph":{"callees":[{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*lazyWithCore).initOnce","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"ParseLevel","signature":"func ParseLevel(text string) (Level, error)","start_line":69,"end_line":73,"code":"func ParseLevel(text string) (Level, error) {\n\n\tvar level Level\n\terr := level.UnmarshalText([]byte(text))\n\treturn level, err\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":49,"end_line":68,"code":"\t// PanicLevel logs a message, then panics.\n\tPanicLevel\n\t// FatalLevel logs a message, then calls os.Exit(1).\n\tFatalLevel\n\n\t_minLevel = DebugLevel\n\t_maxLevel = FatalLevel\n\n\t// InvalidLevel is an invalid value for Level.\n\t//\n\t// Core implementations may panic if they see messages of this level.\n\tInvalidLevel = _maxLevel + 1\n)\n\n// ParseLevel parses a level based on the lower-case or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels."},{"path":"zapcore/level.go","start_line":74,"end_line":93,"code":"\ntype leveledEnabler interface {\n\tLevelEnabler\n\n\tLevel() Level\n}\n\n// LevelOf reports the minimum enabled log level for the given LevelEnabler\n// from Zap's supported log levels, or [InvalidLevel] if none of them are\n// enabled.\n//\n// A LevelEnabler may implement a 'Level() Level' method to override the\n// behavior of this function.\n//\n//\tfunc (c *core) Level() Level {\n//\t\treturn c.currentLevel\n//\t}\n//\n// It is recommended that [Core] implementations that wrap other cores use\n// LevelOf to retrieve the level of the wrapped core. For example,"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"(*Level).UnmarshalText","path":"zapcore/level.go"}],"callers":[{"symbol":"ParseAtomicLevel","path":"level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"LevelOf","signature":"func LevelOf(enab LevelEnabler) Level","start_line":98,"end_line":110,"code":"func LevelOf(enab LevelEnabler) Level {\n\n\tif lvler, ok := enab.(leveledEnabler); ok {\n\t\treturn lvler.Level()\n\t}\n\n\tfor lvl := _minLevel; lvl \u003c= _maxLevel; lvl++ {\n\t\tif enab.Enabled(lvl) {\n\t\t\treturn lvl\n\t\t}\n\t}\n\n\treturn InvalidLevel\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":78,"end_line":97,"code":"\tLevel() Level\n}\n\n// LevelOf reports the minimum enabled log level for the given LevelEnabler\n// from Zap's supported log levels, or [InvalidLevel] if none of them are\n// enabled.\n//\n// A LevelEnabler may implement a 'Level() Level' method to override the\n// behavior of this function.\n//\n//\tfunc (c *core) Level() Level {\n//\t\treturn c.currentLevel\n//\t}\n//\n// It is recommended that [Core] implementations that wrap other cores use\n// LevelOf to retrieve the level of the wrapped core. For example,\n//\n//\tfunc (c *coreWrapper) Level() Level {\n//\t\treturn zapcore.LevelOf(c.wrappedCore)\n//\t}"},{"path":"zapcore/level.go","start_line":111,"end_line":130,"code":"\n// String returns a lower-case ASCII representation of the log level.\nfunc (l Level) String() string {\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"debug\"\n\tcase InfoLevel:\n\t\treturn \"info\"\n\tcase WarnLevel:\n\t\treturn \"warn\"\n\tcase ErrorLevel:\n\t\treturn \"error\"\n\tcase DPanicLevel:\n\t\treturn \"dpanic\"\n\tcase PanicLevel:\n\t\treturn \"panic\"\n\tcase FatalLevel:\n\t\treturn \"fatal\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"Level(%d)\", l)"}],"selection":{"visibility":"exported","reason":"core","score":0.73},"call_graph":{"callees":[{"symbol":"(*contextObserver).Level","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Level","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Level","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*levelFilterCore).Level","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Level","path":"zapcore/sampler.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(AtomicLevel).Level","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(multiCore).Level","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).Level","path":"logger.go"},{"symbol":"(*SugaredLogger).Level","path":"sugar.go"},{"symbol":"(*contextObserver).Level","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Level","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Level","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Level","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Level","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Level","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(Level).String","signature":"func (l Level) String() string","start_line":113,"end_line":132,"code":"func (l Level) String() string {\n\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"debug\"\n\tcase InfoLevel:\n\t\treturn \"info\"\n\tcase WarnLevel:\n\t\treturn \"warn\"\n\tcase ErrorLevel:\n\t\treturn \"error\"\n\tcase DPanicLevel:\n\t\treturn \"dpanic\"\n\tcase PanicLevel:\n\t\treturn \"panic\"\n\tcase FatalLevel:\n\t\treturn \"fatal\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"Level(%d)\", l)\n\t}\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":93,"end_line":112,"code":"// LevelOf to retrieve the level of the wrapped core. For example,\n//\n//\tfunc (c *coreWrapper) Level() Level {\n//\t\treturn zapcore.LevelOf(c.wrappedCore)\n//\t}\nfunc LevelOf(enab LevelEnabler) Level {\n\tif lvler, ok := enab.(leveledEnabler); ok {\n\t\treturn lvler.Level()\n\t}\n\n\tfor lvl := _minLevel; lvl \u003c= _maxLevel; lvl++ {\n\t\tif enab.Enabled(lvl) {\n\t\t\treturn lvl\n\t\t}\n\t}\n\n\treturn InvalidLevel\n}\n\n// String returns a lower-case ASCII representation of the log level."},{"path":"zapcore/level.go","start_line":133,"end_line":152,"code":"\n// CapitalString returns an all-caps ASCII representation of the log level.\nfunc (l Level) CapitalString() string {\n\t// Printing levels in all-caps is common enough that we should export this\n\t// functionality.\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"DEBUG\"\n\tcase InfoLevel:\n\t\treturn \"INFO\"\n\tcase WarnLevel:\n\t\treturn \"WARN\"\n\tcase ErrorLevel:\n\t\treturn \"ERROR\"\n\tcase DPanicLevel:\n\t\treturn \"DPANIC\"\n\tcase PanicLevel:\n\t\treturn \"PANIC\"\n\tcase FatalLevel:\n\t\treturn \"FATAL\""}],"selection":{"visibility":"exported","reason":"core","score":0.78},"call_graph":{"callees":[{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*FlagSet).Var","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"(*Level).String","path":"zapcore/level.go"},{"symbol":"(*jsonEncoder).EncodeEntry","path":"zapcore/json_encoder.go"},{"symbol":"(*pp).handleMethods","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"(AtomicLevel).String","path":"level.go"},{"symbol":"(Level).MarshalText","path":"zapcore/level.go"},{"symbol":"(http2FrameWriteRequest).String","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"contextName","path":"../../../../usr/local/go/src/context/context.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"init#1","path":"zapcore/level_strings.go"},{"symbol":"isZeroValue","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"preprintpanics","path":"../../../../usr/local/go/src/runtime/panic.go"},{"symbol":"stringify","path":"../../../../usr/local/go/src/context/context.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(Level).CapitalString","signature":"func (l Level) CapitalString() string","start_line":135,"end_line":156,"code":"func (l Level) CapitalString() string {\n\n\t\n\t\n\tswitch l {\n\tcase DebugLevel:\n\t\treturn \"DEBUG\"\n\tcase InfoLevel:\n\t\treturn \"INFO\"\n\tcase WarnLevel:\n\t\treturn \"WARN\"\n\tcase ErrorLevel:\n\t\treturn \"ERROR\"\n\tcase DPanicLevel:\n\t\treturn \"DPANIC\"\n\tcase PanicLevel:\n\t\treturn \"PANIC\"\n\tcase FatalLevel:\n\t\treturn \"FATAL\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"LEVEL(%d)\", l)\n\t}\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":115,"end_line":134,"code":"\tcase DebugLevel:\n\t\treturn \"debug\"\n\tcase InfoLevel:\n\t\treturn \"info\"\n\tcase WarnLevel:\n\t\treturn \"warn\"\n\tcase ErrorLevel:\n\t\treturn \"error\"\n\tcase DPanicLevel:\n\t\treturn \"dpanic\"\n\tcase PanicLevel:\n\t\treturn \"panic\"\n\tcase FatalLevel:\n\t\treturn \"fatal\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"Level(%d)\", l)\n\t}\n}\n\n// CapitalString returns an all-caps ASCII representation of the log level."},{"path":"zapcore/level.go","start_line":157,"end_line":176,"code":"\n// MarshalText marshals the Level to text. Note that the text representation\n// drops the -Level suffix (see example).\nfunc (l Level) MarshalText() ([]byte, error) {\n\treturn []byte(l.String()), nil\n}\n\n// UnmarshalText unmarshals text to a level. Like MarshalText, UnmarshalText\n// expects the text representation of a Level to drop the -Level suffix (see\n// example).\n//\n// In particular, this makes it easy to configure logging levels using YAML,\n// TOML, or JSON files.\nfunc (l *Level) UnmarshalText(text []byte) error {\n\tif l == nil {\n\t\treturn errUnmarshalNilLevel\n\t}\n\tif !l.unmarshalText(text) \u0026\u0026 !l.unmarshalText(bytes.ToLower(text)) {\n\t\treturn fmt.Errorf(\"unrecognized level: %q\", text)\n\t}"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":[{"symbol":"Sprintf","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*Level).CapitalString","path":"zapcore/level.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"CapitalLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"init#1","path":"zapcore/level_strings.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(Level).MarshalText","signature":"func (l Level) MarshalText() ([]byte, error)","start_line":160,"end_line":162,"code":"func (l Level) MarshalText() ([]byte, error) {\n\n\treturn []byte(l.String()), nil\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":140,"end_line":159,"code":"\t\treturn \"DEBUG\"\n\tcase InfoLevel:\n\t\treturn \"INFO\"\n\tcase WarnLevel:\n\t\treturn \"WARN\"\n\tcase ErrorLevel:\n\t\treturn \"ERROR\"\n\tcase DPanicLevel:\n\t\treturn \"DPANIC\"\n\tcase PanicLevel:\n\t\treturn \"PANIC\"\n\tcase FatalLevel:\n\t\treturn \"FATAL\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"LEVEL(%d)\", l)\n\t}\n}\n\n// MarshalText marshals the Level to text. Note that the text representation\n// drops the -Level suffix (see example)."},{"path":"zapcore/level.go","start_line":163,"end_line":182,"code":"\n// UnmarshalText unmarshals text to a level. Like MarshalText, UnmarshalText\n// expects the text representation of a Level to drop the -Level suffix (see\n// example).\n//\n// In particular, this makes it easy to configure logging levels using YAML,\n// TOML, or JSON files.\nfunc (l *Level) UnmarshalText(text []byte) error {\n\tif l == nil {\n\t\treturn errUnmarshalNilLevel\n\t}\n\tif !l.unmarshalText(text) \u0026\u0026 !l.unmarshalText(bytes.ToLower(text)) {\n\t\treturn fmt.Errorf(\"unrecognized level: %q\", text)\n\t}\n\treturn nil\n}\n\nfunc (l *Level) unmarshalText(text []byte) bool {\n\tswitch string(text) {\n\tcase \"debug\":"}],"selection":{"visibility":"exported","reason":"core","score":0.6},"call_graph":{"callees":[{"symbol":"(Level).String","path":"zapcore/level.go"}],"callers":[{"symbol":"(*Level).MarshalText","path":"zapcore/level.go"},{"symbol":"(AtomicLevel).MarshalText","path":"level.go"},{"symbol":"(textValue).String","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"addrTextMarshalerEncoder","path":"../../../../usr/local/go/src/encoding/json/encode.go"},{"symbol":"resolveKeyName","path":"../../../../usr/local/go/src/encoding/json/encode.go"},{"symbol":"textMarshalerEncoder","path":"../../../../usr/local/go/src/encoding/json/encode.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(*Level).UnmarshalText","signature":"func (l *Level) UnmarshalText(text []byte) error","start_line":170,"end_line":178,"code":"func (l *Level) UnmarshalText(text []byte) error {\n\n\tif l == nil {\n\t\treturn errUnmarshalNilLevel\n\t}\n\tif !l.unmarshalText(text) \u0026\u0026 !l.unmarshalText(bytes.ToLower(text)) {\n\t\treturn fmt.Errorf(\"unrecognized level: %q\", text)\n\t}\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":150,"end_line":169,"code":"\t\treturn \"PANIC\"\n\tcase FatalLevel:\n\t\treturn \"FATAL\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"LEVEL(%d)\", l)\n\t}\n}\n\n// MarshalText marshals the Level to text. Note that the text representation\n// drops the -Level suffix (see example).\nfunc (l Level) MarshalText() ([]byte, error) {\n\treturn []byte(l.String()), nil\n}\n\n// UnmarshalText unmarshals text to a level. Like MarshalText, UnmarshalText\n// expects the text representation of a Level to drop the -Level suffix (see\n// example).\n//\n// In particular, this makes it easy to configure logging levels using YAML,\n// TOML, or JSON files."},{"path":"zapcore/level.go","start_line":179,"end_line":198,"code":"\nfunc (l *Level) unmarshalText(text []byte) bool {\n\tswitch string(text) {\n\tcase \"debug\":\n\t\t*l = DebugLevel\n\tcase \"info\", \"\": // make the zero value useful\n\t\t*l = InfoLevel\n\tcase \"warn\", \"warning\":\n\t\t*l = WarnLevel\n\tcase \"error\":\n\t\t*l = ErrorLevel\n\tcase \"dpanic\":\n\t\t*l = DPanicLevel\n\tcase \"panic\":\n\t\t*l = PanicLevel\n\tcase \"fatal\":\n\t\t*l = FatalLevel\n\tdefault:\n\t\treturn false\n\t}"}],"selection":{"visibility":"exported","reason":"core","score":0.72},"call_graph":{"callees":[{"symbol":"(*Level).unmarshalText","path":"zapcore/level.go"},{"symbol":"Errorf","path":"../../../../usr/local/go/src/fmt/errors.go"},{"symbol":"ToLower","path":"../../../../usr/local/go/src/bytes/bytes.go"}],"callers":[{"symbol":"(*AtomicLevel).UnmarshalText","path":"level.go"},{"symbol":"(*Level).Set","path":"zapcore/level.go"},{"symbol":"(*decodeState).literalStore","path":"../../../../usr/local/go/src/encoding/json/decode.go"},{"symbol":"(textValue).Set","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"ParseLevel","path":"zapcore/level.go"},{"symbol":"decodePutURL","path":"http_handler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(*Level).unmarshalText","signature":"func (l *Level) unmarshalText(text []byte) bool","start_line":180,"end_line":200,"code":"func (l *Level) unmarshalText(text []byte) bool {\n\n\tswitch string(text) {\n\tcase \"debug\":\n\t\t*l = DebugLevel\n\tcase \"info\", \"\": \n\t\t*l = InfoLevel\n\tcase \"warn\", \"warning\":\n\t\t*l = WarnLevel\n\tcase \"error\":\n\t\t*l = ErrorLevel\n\tcase \"dpanic\":\n\t\t*l = DPanicLevel\n\tcase \"panic\":\n\t\t*l = PanicLevel\n\tcase \"fatal\":\n\t\t*l = FatalLevel\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":160,"end_line":179,"code":"func (l Level) MarshalText() ([]byte, error) {\n\treturn []byte(l.String()), nil\n}\n\n// UnmarshalText unmarshals text to a level. Like MarshalText, UnmarshalText\n// expects the text representation of a Level to drop the -Level suffix (see\n// example).\n//\n// In particular, this makes it easy to configure logging levels using YAML,\n// TOML, or JSON files.\nfunc (l *Level) UnmarshalText(text []byte) error {\n\tif l == nil {\n\t\treturn errUnmarshalNilLevel\n\t}\n\tif !l.unmarshalText(text) \u0026\u0026 !l.unmarshalText(bytes.ToLower(text)) {\n\t\treturn fmt.Errorf(\"unrecognized level: %q\", text)\n\t}\n\treturn nil\n}\n"},{"path":"zapcore/level.go","start_line":201,"end_line":220,"code":"\n// Set sets the level for the flag.Value interface.\nfunc (l *Level) Set(s string) error {\n\treturn l.UnmarshalText([]byte(s))\n}\n\n// Get gets the level for the flag.Getter interface.\nfunc (l *Level) Get() interface{} {\n\treturn *l\n}\n\n// Enabled returns true if the given level is at or above this level.\nfunc (l Level) Enabled(lvl Level) bool {\n\treturn lvl \u003e= l\n}\n\n// LevelEnabler decides whether a given logging level is enabled when logging a\n// message.\n//\n// Enablers are intended to be used to implement deterministic filters;"}],"selection":{"visibility":"unexported","reason":"core","score":0.51},"call_graph":{"callees":null,"callers":[{"symbol":"(*Level).UnmarshalText","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(*Level).Set","signature":"func (l *Level) Set(s string) error","start_line":203,"end_line":205,"code":"func (l *Level) Set(s string) error {\n\n\treturn l.UnmarshalText([]byte(s))\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":183,"end_line":202,"code":"\t\t*l = DebugLevel\n\tcase \"info\", \"\": // make the zero value useful\n\t\t*l = InfoLevel\n\tcase \"warn\", \"warning\":\n\t\t*l = WarnLevel\n\tcase \"error\":\n\t\t*l = ErrorLevel\n\tcase \"dpanic\":\n\t\t*l = DPanicLevel\n\tcase \"panic\":\n\t\t*l = PanicLevel\n\tcase \"fatal\":\n\t\t*l = FatalLevel\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Set sets the level for the flag.Value interface."},{"path":"zapcore/level.go","start_line":206,"end_line":225,"code":"\n// Get gets the level for the flag.Getter interface.\nfunc (l *Level) Get() interface{} {\n\treturn *l\n}\n\n// Enabled returns true if the given level is at or above this level.\nfunc (l Level) Enabled(lvl Level) bool {\n\treturn lvl \u003e= l\n}\n\n// LevelEnabler decides whether a given logging level is enabled when logging a\n// message.\n//\n// Enablers are intended to be used to implement deterministic filters;\n// concerns like sampling are better implemented as a Core.\n//\n// Each concrete Level value implements a static LevelEnabler which returns\n// true for itself and all higher logging levels. For example WarnLevel.Enabled()\n// will return true for WarnLevel, ErrorLevel, DPanicLevel, PanicLevel, and"}],"selection":{"visibility":"exported","reason":"core","score":0.6},"call_graph":{"callees":[{"symbol":"(*Level).UnmarshalText","path":"zapcore/level.go"}],"callers":[{"symbol":"(*FlagSet).parseOne","path":"../../../../usr/local/go/src/flag/flag.go"},{"symbol":"(*FlagSet).set","path":"../../../../usr/local/go/src/flag/flag.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(*Level).Get","signature":"func (l *Level) Get() interface{}","start_line":208,"end_line":210,"code":"func (l *Level) Get() interface{\n} {\n\treturn *l\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":188,"end_line":207,"code":"\tcase \"error\":\n\t\t*l = ErrorLevel\n\tcase \"dpanic\":\n\t\t*l = DPanicLevel\n\tcase \"panic\":\n\t\t*l = PanicLevel\n\tcase \"fatal\":\n\t\t*l = FatalLevel\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Set sets the level for the flag.Value interface.\nfunc (l *Level) Set(s string) error {\n\treturn l.UnmarshalText([]byte(s))\n}\n\n// Get gets the level for the flag.Getter interface."},{"path":"zapcore/level.go","start_line":211,"end_line":230,"code":"\n// Enabled returns true if the given level is at or above this level.\nfunc (l Level) Enabled(lvl Level) bool {\n\treturn lvl \u003e= l\n}\n\n// LevelEnabler decides whether a given logging level is enabled when logging a\n// message.\n//\n// Enablers are intended to be used to implement deterministic filters;\n// concerns like sampling are better implemented as a Core.\n//\n// Each concrete Level value implements a static LevelEnabler which returns\n// true for itself and all higher logging levels. For example WarnLevel.Enabled()\n// will return true for WarnLevel, ErrorLevel, DPanicLevel, PanicLevel, and\n// FatalLevel, but return false for InfoLevel and DebugLevel.\ntype LevelEnabler interface {\n\tEnabled(Level) bool\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.67},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level.go","symbol":"(Level).Enabled","signature":"func (l Level) Enabled(lvl Level) bool","start_line":213,"end_line":215,"code":"func (l Level) Enabled(lvl Level) bool {\n\n\treturn lvl \u003e= l\n}\n","neighbors":[{"path":"zapcore/level.go","start_line":193,"end_line":212,"code":"\t\t*l = PanicLevel\n\tcase \"fatal\":\n\t\t*l = FatalLevel\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Set sets the level for the flag.Value interface.\nfunc (l *Level) Set(s string) error {\n\treturn l.UnmarshalText([]byte(s))\n}\n\n// Get gets the level for the flag.Getter interface.\nfunc (l *Level) Get() interface{} {\n\treturn *l\n}\n\n// Enabled returns true if the given level is at or above this level."},{"path":"zapcore/level.go","start_line":216,"end_line":230,"code":"\n// LevelEnabler decides whether a given logging level is enabled when logging a\n// message.\n//\n// Enablers are intended to be used to implement deterministic filters;\n// concerns like sampling are better implemented as a Core.\n//\n// Each concrete Level value implements a static LevelEnabler which returns\n// true for itself and all higher logging levels. For example WarnLevel.Enabled()\n// will return true for WarnLevel, ErrorLevel, DPanicLevel, PanicLevel, and\n// FatalLevel, but return false for InfoLevel and DebugLevel.\ntype LevelEnabler interface {\n\tEnabled(Level) bool\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.68},"call_graph":{"callees":null,"callers":[{"symbol":"(*Level).Enabled","path":"zapcore/level.go"},{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/level_strings.go","symbol":"init","signature":"func init()","start_line":41,"end_line":46,"code":"func init() {\n\n\tfor level, color := range _levelToColor {\n\t\t_levelToLowercaseColorString[level] = color.Add(level.String())\n\t\t_levelToCapitalColorString[level] = color.Add(level.CapitalString())\n\t}\n}\n","neighbors":[{"path":"zapcore/level_strings.go","start_line":21,"end_line":40,"code":"package zapcore\n\nimport \"go.uber.org/zap/internal/color\"\n\nvar (\n\t_levelToColor = map[Level]color.Color{\n\t\tDebugLevel:  color.Magenta,\n\t\tInfoLevel:   color.Blue,\n\t\tWarnLevel:   color.Yellow,\n\t\tErrorLevel:  color.Red,\n\t\tDPanicLevel: color.Red,\n\t\tPanicLevel:  color.Red,\n\t\tFatalLevel:  color.Red,\n\t}\n\t_unknownLevelColor = color.Red\n\n\t_levelToLowercaseColorString = make(map[Level]string, len(_levelToColor))\n\t_levelToCapitalColorString   = make(map[Level]string, len(_levelToColor))\n)\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/marshaler.go","symbol":"(ObjectMarshalerFunc).MarshalLogObject","signature":"func (f ObjectMarshalerFunc) MarshalLogObject(enc ObjectEncoder) error","start_line":39,"end_line":41,"code":"func (f ObjectMarshalerFunc) MarshalLogObject(enc ObjectEncoder) error {\n\n\treturn f(enc)\n}\n","neighbors":[{"path":"zapcore/marshaler.go","start_line":19,"end_line":38,"code":"// THE SOFTWARE.\n\npackage zapcore\n\n// ObjectMarshaler allows user-defined types to efficiently add themselves to the\n// logging context, and to selectively omit information which shouldn't be\n// included in logs (e.g., passwords).\n//\n// Note: ObjectMarshaler is only used when zap.Object is used or when\n// passed directly to zap.Any. It is not used when reflection-based\n// encoding is used.\ntype ObjectMarshaler interface {\n\tMarshalLogObject(ObjectEncoder) error\n}\n\n// ObjectMarshalerFunc is a type adapter that turns a function into an\n// ObjectMarshaler.\ntype ObjectMarshalerFunc func(ObjectEncoder) error\n\n// MarshalLogObject calls the underlying function."},{"path":"zapcore/marshaler.go","start_line":42,"end_line":61,"code":"\n// ArrayMarshaler allows user-defined types to efficiently add themselves to the\n// logging context, and to selectively omit information which shouldn't be\n// included in logs (e.g., passwords).\n//\n// Note: ArrayMarshaler is only used when zap.Array is used or when\n// passed directly to zap.Any. It is not used when reflection-based\n// encoding is used.\ntype ArrayMarshaler interface {\n\tMarshalLogArray(ArrayEncoder) error\n}\n\n// ArrayMarshalerFunc is a type adapter that turns a function into an\n// ArrayMarshaler.\ntype ArrayMarshalerFunc func(ArrayEncoder) error\n\n// MarshalLogArray calls the underlying function.\nfunc (f ArrayMarshalerFunc) MarshalLogArray(enc ArrayEncoder) error {\n\treturn f(enc)\n}"}],"selection":{"visibility":"exported","reason":"core","score":0.62},"call_graph":{"callees":null,"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*ObjectMarshalerFunc).MarshalLogObject","path":"zapcore/marshaler.go"},{"symbol":"(*jsonEncoder).AppendObject","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/marshaler.go","symbol":"(ArrayMarshalerFunc).MarshalLogArray","signature":"func (f ArrayMarshalerFunc) MarshalLogArray(enc ArrayEncoder) error","start_line":59,"end_line":61,"code":"func (f ArrayMarshalerFunc) MarshalLogArray(enc ArrayEncoder) error {\n\n\treturn f(enc)\n}\n","neighbors":[{"path":"zapcore/marshaler.go","start_line":39,"end_line":58,"code":"func (f ObjectMarshalerFunc) MarshalLogObject(enc ObjectEncoder) error {\n\treturn f(enc)\n}\n\n// ArrayMarshaler allows user-defined types to efficiently add themselves to the\n// logging context, and to selectively omit information which shouldn't be\n// included in logs (e.g., passwords).\n//\n// Note: ArrayMarshaler is only used when zap.Array is used or when\n// passed directly to zap.Any. It is not used when reflection-based\n// encoding is used.\ntype ArrayMarshaler interface {\n\tMarshalLogArray(ArrayEncoder) error\n}\n\n// ArrayMarshalerFunc is a type adapter that turns a function into an\n// ArrayMarshaler.\ntype ArrayMarshalerFunc func(ArrayEncoder) error\n\n// MarshalLogArray calls the underlying function."}],"selection":{"visibility":"exported","reason":"core","score":0.61},"call_graph":{"callees":null,"callers":[{"symbol":"(*ArrayMarshalerFunc).MarshalLogArray","path":"zapcore/marshaler.go"},{"symbol":"(*MapObjectEncoder).AddArray","path":"zapcore/memory_encoder.go"},{"symbol":"(*jsonEncoder).AppendArray","path":"zapcore/json_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendArray","path":"zapcore/memory_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"NewMapObjectEncoder","signature":"func NewMapObjectEncoder() *MapObjectEncoder","start_line":36,"end_line":42,"code":"func NewMapObjectEncoder() *MapObjectEncoder {\n\n\tm := make(map[string]interface{})\n\treturn \u0026MapObjectEncoder{\n\t\tFields: m,\n\t\tcur:    m,\n\t}\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":16,"end_line":35,"code":"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zapcore\n\nimport \"time\"\n\n// MapObjectEncoder is an ObjectEncoder backed by a simple\n// map[string]interface{}. It's not fast enough for production use, but it's\n// helpful in tests.\ntype MapObjectEncoder struct {\n\t// Fields contains the entire encoded log context.\n\tFields map[string]interface{}\n\t// cur is a pointer to the namespace we're currently writing to.\n\tcur map[string]interface{}\n}\n\n// NewMapObjectEncoder creates a new map-backed ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":43,"end_line":62,"code":"\n// AddArray implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error {\n\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"constructor","score":0.91},"call_graph":{"callees":null,"callers":[{"symbol":"(*MapObjectEncoder).AddObject","path":"zapcore/memory_encoder.go"},{"symbol":"(*sliceArrayEncoder).AppendObject","path":"zapcore/memory_encoder.go"},{"symbol":"(LoggedEntry).ContextMap","path":"zaptest/observer/logged_entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddArray","signature":"func (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error","start_line":45,"end_line":50,"code":"func (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error {\n\n\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":25,"end_line":44,"code":"// MapObjectEncoder is an ObjectEncoder backed by a simple\n// map[string]interface{}. It's not fast enough for production use, but it's\n// helpful in tests.\ntype MapObjectEncoder struct {\n\t// Fields contains the entire encoded log context.\n\tFields map[string]interface{}\n\t// cur is a pointer to the namespace we're currently writing to.\n\tcur map[string]interface{}\n}\n\n// NewMapObjectEncoder creates a new map-backed ObjectEncoder.\nfunc NewMapObjectEncoder() *MapObjectEncoder {\n\tm := make(map[string]interface{})\n\treturn \u0026MapObjectEncoder{\n\t\tFields: m,\n\t\tcur:    m,\n\t}\n}\n\n// AddArray implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":51,"end_line":70,"code":"\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.76},"call_graph":{"callees":[{"symbol":"(*errArrayElem).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(ArrayMarshalerFunc).MarshalLogArray","path":"zapcore/marshaler.go"},{"symbol":"(bools).MarshalLogArray","path":"array.go"},{"symbol":"(byteStringsArray).MarshalLogArray","path":"array.go"},{"symbol":"(complex128s).MarshalLogArray","path":"array.go"},{"symbol":"(complex64s).MarshalLogArray","path":"array.go"},{"symbol":"(durations).MarshalLogArray","path":"array.go"},{"symbol":"(errArray).MarshalLogArray","path":"error.go"},{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(float32s).MarshalLogArray","path":"array.go"},{"symbol":"(float64s).MarshalLogArray","path":"array.go"},{"symbol":"(int16s).MarshalLogArray","path":"array.go"},{"symbol":"(int32s).MarshalLogArray","path":"array.go"},{"symbol":"(int64s).MarshalLogArray","path":"array.go"},{"symbol":"(int8s).MarshalLogArray","path":"array.go"},{"symbol":"(ints).MarshalLogArray","path":"array.go"},{"symbol":"(invalidPairs).MarshalLogArray","path":"sugar.go"},{"symbol":"(stringArray).MarshalLogArray","path":"array.go"},{"symbol":"(times).MarshalLogArray","path":"array.go"},{"symbol":"(uint16s).MarshalLogArray","path":"array.go"},{"symbol":"(uint32s).MarshalLogArray","path":"array.go"},{"symbol":"(uint64s).MarshalLogArray","path":"array.go"},{"symbol":"(uint8s).MarshalLogArray","path":"array.go"},{"symbol":"(uintptrs).MarshalLogArray","path":"array.go"},{"symbol":"(uints).MarshalLogArray","path":"array.go"}],"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"encodeError","path":"zapcore/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddObject","signature":"func (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error","start_line":53,"end_line":57,"code":"func (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":33,"end_line":52,"code":"}\n\n// NewMapObjectEncoder creates a new map-backed ObjectEncoder.\nfunc NewMapObjectEncoder() *MapObjectEncoder {\n\tm := make(map[string]interface{})\n\treturn \u0026MapObjectEncoder{\n\t\tFields: m,\n\t\tcur:    m,\n\t}\n}\n\n// AddArray implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error {\n\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n\n// AddObject implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":58,"end_line":77,"code":"\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"zapcore/error.go"},{"symbol":"(ObjectMarshalerFunc).MarshalLogObject","path":"zapcore/marshaler.go"},{"symbol":"(dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"},{"symbol":"NewMapObjectEncoder","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddBinary","signature":"func (m *MapObjectEncoder) AddBinary(k string, v []byte)","start_line":60,"end_line":60,"code":"func (m *MapObjectEncoder) AddBinary(k string, v []byte) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":40,"end_line":59,"code":"\t\tcur:    m,\n\t}\n}\n\n// AddArray implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error {\n\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":61,"end_line":80,"code":"\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddByteString","signature":"func (m *MapObjectEncoder) AddByteString(k string, v []byte)","start_line":63,"end_line":63,"code":"func (m *MapObjectEncoder) AddByteString(k string, v []byte) {\n m.cur[k] = string(v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":43,"end_line":62,"code":"\n// AddArray implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddArray(key string, v ArrayMarshaler) error {\n\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":64,"end_line":83,"code":"\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddBool","signature":"func (m *MapObjectEncoder) AddBool(k string, v bool)","start_line":66,"end_line":66,"code":"func (m *MapObjectEncoder) AddBool(k string, v bool) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":46,"end_line":65,"code":"\tarr := \u0026sliceArrayEncoder{elems: make([]interface{}, 0)}\n\terr := v.MarshalLogArray(arr)\n\tm.cur[key] = arr.elems\n\treturn err\n}\n\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":67,"end_line":86,"code":"\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(MapObjectEncoder).AddDuration","signature":"func (m MapObjectEncoder) AddDuration(k string, v time.Duration)","start_line":69,"end_line":69,"code":"func (m MapObjectEncoder) AddDuration(k string, v time.Duration) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":49,"end_line":68,"code":"\treturn err\n}\n\n// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":70,"end_line":89,"code":"\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(*MapObjectEncoder).AddDuration","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddComplex128","signature":"func (m *MapObjectEncoder) AddComplex128(k string, v complex128)","start_line":72,"end_line":72,"code":"func (m *MapObjectEncoder) AddComplex128(k string, v complex128) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":52,"end_line":71,"code":"// AddObject implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddObject(k string, v ObjectMarshaler) error {\n\tnewMap := NewMapObjectEncoder()\n\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":73,"end_line":92,"code":"\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddComplex64","signature":"func (m *MapObjectEncoder) AddComplex64(k string, v complex64)","start_line":75,"end_line":75,"code":"func (m *MapObjectEncoder) AddComplex64(k string, v complex64) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":55,"end_line":74,"code":"\tm.cur[k] = newMap.Fields\n\treturn v.MarshalLogObject(newMap)\n}\n\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":76,"end_line":95,"code":"\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddFloat64","signature":"func (m *MapObjectEncoder) AddFloat64(k string, v float64)","start_line":78,"end_line":78,"code":"func (m *MapObjectEncoder) AddFloat64(k string, v float64) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":58,"end_line":77,"code":"\n// AddBinary implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBinary(k string, v []byte) { m.cur[k] = v }\n\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":79,"end_line":98,"code":"\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddFloat32","signature":"func (m *MapObjectEncoder) AddFloat32(k string, v float32)","start_line":81,"end_line":81,"code":"func (m *MapObjectEncoder) AddFloat32(k string, v float32) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":61,"end_line":80,"code":"\n// AddByteString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddByteString(k string, v []byte) { m.cur[k] = string(v) }\n\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":82,"end_line":101,"code":"\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddInt","signature":"func (m *MapObjectEncoder) AddInt(k string, v int)","start_line":84,"end_line":84,"code":"func (m *MapObjectEncoder) AddInt(k string, v int) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":64,"end_line":83,"code":"\n// AddBool implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddBool(k string, v bool) { m.cur[k] = v }\n\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":85,"end_line":104,"code":"\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddInt64","signature":"func (m *MapObjectEncoder) AddInt64(k string, v int64)","start_line":87,"end_line":87,"code":"func (m *MapObjectEncoder) AddInt64(k string, v int64) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":67,"end_line":86,"code":"\n// AddDuration implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddDuration(k string, v time.Duration) { m.cur[k] = v }\n\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":88,"end_line":107,"code":"\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddInt32","signature":"func (m *MapObjectEncoder) AddInt32(k string, v int32)","start_line":90,"end_line":90,"code":"func (m *MapObjectEncoder) AddInt32(k string, v int32) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":70,"end_line":89,"code":"\n// AddComplex128 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex128(k string, v complex128) { m.cur[k] = v }\n\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":91,"end_line":110,"code":"\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddInt16","signature":"func (m *MapObjectEncoder) AddInt16(k string, v int16)","start_line":93,"end_line":93,"code":"func (m *MapObjectEncoder) AddInt16(k string, v int16) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":73,"end_line":92,"code":"\n// AddComplex64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddComplex64(k string, v complex64) { m.cur[k] = v }\n\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":94,"end_line":113,"code":"\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddInt8","signature":"func (m *MapObjectEncoder) AddInt8(k string, v int8)","start_line":96,"end_line":96,"code":"func (m *MapObjectEncoder) AddInt8(k string, v int8) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":76,"end_line":95,"code":"\n// AddFloat64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat64(k string, v float64) { m.cur[k] = v }\n\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":97,"end_line":116,"code":"\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddString","signature":"func (m *MapObjectEncoder) AddString(k string, v string)","start_line":99,"end_line":99,"code":"func (m *MapObjectEncoder) AddString(k string, v string) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":79,"end_line":98,"code":"\n// AddFloat32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddFloat32(k string, v float32) { m.cur[k] = v }\n\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":100,"end_line":119,"code":"\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.69},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"encodeError","path":"zapcore/error.go"},{"symbol":"encodeError$1","path":"zapcore/error.go"},{"symbol":"encodeStringer","path":"zapcore/field.go"},{"symbol":"encodeStringer$1","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(MapObjectEncoder).AddTime","signature":"func (m MapObjectEncoder) AddTime(k string, v time.Time)","start_line":102,"end_line":102,"code":"func (m MapObjectEncoder) AddTime(k string, v time.Time) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":82,"end_line":101,"code":"\n// AddInt implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt(k string, v int) { m.cur[k] = v }\n\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":103,"end_line":122,"code":"\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(*MapObjectEncoder).AddTime","path":"zapcore/memory_encoder.go"},{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUint","signature":"func (m *MapObjectEncoder) AddUint(k string, v uint)","start_line":105,"end_line":105,"code":"func (m *MapObjectEncoder) AddUint(k string, v uint) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":85,"end_line":104,"code":"\n// AddInt64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt64(k string, v int64) { m.cur[k] = v }\n\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":106,"end_line":125,"code":"\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUint64","signature":"func (m *MapObjectEncoder) AddUint64(k string, v uint64)","start_line":108,"end_line":108,"code":"func (m *MapObjectEncoder) AddUint64(k string, v uint64) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":88,"end_line":107,"code":"\n// AddInt32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt32(k string, v int32) { m.cur[k] = v }\n\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":109,"end_line":128,"code":"\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder."}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUint32","signature":"func (m *MapObjectEncoder) AddUint32(k string, v uint32)","start_line":111,"end_line":111,"code":"func (m *MapObjectEncoder) AddUint32(k string, v uint32) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":91,"end_line":110,"code":"\n// AddInt16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt16(k string, v int16) { m.cur[k] = v }\n\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":112,"end_line":131,"code":"\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUint16","signature":"func (m *MapObjectEncoder) AddUint16(k string, v uint16)","start_line":114,"end_line":114,"code":"func (m *MapObjectEncoder) AddUint16(k string, v uint16) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":94,"end_line":113,"code":"\n// AddInt8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddInt8(k string, v int8) { m.cur[k] = v }\n\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":115,"end_line":134,"code":"\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUint8","signature":"func (m *MapObjectEncoder) AddUint8(k string, v uint8)","start_line":117,"end_line":117,"code":"func (m *MapObjectEncoder) AddUint8(k string, v uint8) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":97,"end_line":116,"code":"\n// AddString implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddString(k string, v string) { m.cur[k] = v }\n\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":118,"end_line":137,"code":"\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddUintptr","signature":"func (m *MapObjectEncoder) AddUintptr(k string, v uintptr)","start_line":120,"end_line":120,"code":"func (m *MapObjectEncoder) AddUintptr(k string, v uintptr) {\n m.cur[k] = v }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":100,"end_line":119,"code":"\n// AddTime implements ObjectEncoder.\nfunc (m MapObjectEncoder) AddTime(k string, v time.Time) { m.cur[k] = v }\n\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":121,"end_line":140,"code":"\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).AddReflected","signature":"func (m *MapObjectEncoder) AddReflected(k string, v interface{}) error","start_line":123,"end_line":126,"code":"func (m *MapObjectEncoder) AddReflected(k string, v interface{\n}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":103,"end_line":122,"code":"\n// AddUint implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint(k string, v uint) { m.cur[k] = v }\n\n// AddUint64 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint64(k string, v uint64) { m.cur[k] = v }\n\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":127,"end_line":146,"code":"\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n\nfunc (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*MapObjectEncoder).OpenNamespace","signature":"func (m *MapObjectEncoder) OpenNamespace(k string)","start_line":129,"end_line":133,"code":"func (m *MapObjectEncoder) OpenNamespace(k string) {\n\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":109,"end_line":128,"code":"\n// AddUint32 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint32(k string, v uint32) { m.cur[k] = v }\n\n// AddUint16 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint16(k string, v uint16) { m.cur[k] = v }\n\n// AddUint8 implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUint8(k string, v uint8) { m.cur[k] = v }\n\n// AddUintptr implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddUintptr(k string, v uintptr) { m.cur[k] = v }\n\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder."},{"path":"zapcore/memory_encoder.go","start_line":134,"end_line":153,"code":"\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n\nfunc (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":null,"callers":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendArray","signature":"func (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error","start_line":141,"end_line":146,"code":"func (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":121,"end_line":140,"code":"\n// AddReflected implements ObjectEncoder.\nfunc (m *MapObjectEncoder) AddReflected(k string, v interface{}) error {\n\tm.cur[k] = v\n\treturn nil\n}\n\n// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n"},{"path":"zapcore/memory_encoder.go","start_line":147,"end_line":166,"code":"\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.75},"call_graph":{"callees":[{"symbol":"(*errArrayElem).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(ArrayMarshalerFunc).MarshalLogArray","path":"zapcore/marshaler.go"},{"symbol":"(bools).MarshalLogArray","path":"array.go"},{"symbol":"(byteStringsArray).MarshalLogArray","path":"array.go"},{"symbol":"(complex128s).MarshalLogArray","path":"array.go"},{"symbol":"(complex64s).MarshalLogArray","path":"array.go"},{"symbol":"(durations).MarshalLogArray","path":"array.go"},{"symbol":"(errArray).MarshalLogArray","path":"error.go"},{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(float32s).MarshalLogArray","path":"array.go"},{"symbol":"(float64s).MarshalLogArray","path":"array.go"},{"symbol":"(int16s).MarshalLogArray","path":"array.go"},{"symbol":"(int32s).MarshalLogArray","path":"array.go"},{"symbol":"(int64s).MarshalLogArray","path":"array.go"},{"symbol":"(int8s).MarshalLogArray","path":"array.go"},{"symbol":"(ints).MarshalLogArray","path":"array.go"},{"symbol":"(invalidPairs).MarshalLogArray","path":"sugar.go"},{"symbol":"(stringArray).MarshalLogArray","path":"array.go"},{"symbol":"(times).MarshalLogArray","path":"array.go"},{"symbol":"(uint16s).MarshalLogArray","path":"array.go"},{"symbol":"(uint32s).MarshalLogArray","path":"array.go"},{"symbol":"(uint64s).MarshalLogArray","path":"array.go"},{"symbol":"(uint8s).MarshalLogArray","path":"array.go"},{"symbol":"(uintptrs).MarshalLogArray","path":"array.go"},{"symbol":"(uints).MarshalLogArray","path":"array.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendObject","signature":"func (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error","start_line":148,"end_line":153,"code":"func (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":128,"end_line":147,"code":"// OpenNamespace implements ObjectEncoder.\nfunc (m *MapObjectEncoder) OpenNamespace(k string) {\n\tns := make(map[string]interface{})\n\tm.cur[k] = ns\n\tm.cur = ns\n}\n\n// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n\nfunc (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n"},{"path":"zapcore/memory_encoder.go","start_line":154,"end_line":173,"code":"\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.78},"call_graph":{"callees":[{"symbol":"(*errArrayElem).MarshalLogObject","path":"error.go"},{"symbol":"(*errArrayElem).MarshalLogObject","path":"zapcore/error.go"},{"symbol":"(ObjectMarshalerFunc).MarshalLogObject","path":"zapcore/marshaler.go"},{"symbol":"(dictObject).MarshalLogObject","path":"field.go"},{"symbol":"(invalidPair).MarshalLogObject","path":"sugar.go"},{"symbol":"NewMapObjectEncoder","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*errArrayElem).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(errArray).MarshalLogArray","path":"error.go"},{"symbol":"(errArray).MarshalLogArray","path":"zapcore/error.go"},{"symbol":"(invalidPairs).MarshalLogArray","path":"sugar.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendReflected","signature":"func (s *sliceArrayEncoder) AppendReflected(v interface{}) error","start_line":155,"end_line":158,"code":"func (s *sliceArrayEncoder) AppendReflected(v interface{\n}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":135,"end_line":154,"code":"// sliceArrayEncoder is an ArrayEncoder backed by a simple []interface{}. Like\n// the MapObjectEncoder, it's not designed for production use.\ntype sliceArrayEncoder struct {\n\telems []interface{}\n}\n\nfunc (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n"},{"path":"zapcore/memory_encoder.go","start_line":159,"end_line":178,"code":"\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendBool","signature":"func (s *sliceArrayEncoder) AppendBool(v bool)","start_line":160,"end_line":160,"code":"func (s *sliceArrayEncoder) AppendBool(v bool)              {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":140,"end_line":159,"code":"\nfunc (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n"},{"path":"zapcore/memory_encoder.go","start_line":161,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(bools).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendByteString","signature":"func (s *sliceArrayEncoder) AppendByteString(v []byte)","start_line":161,"end_line":161,"code":"func (s *sliceArrayEncoder) AppendByteString(v []byte)      {\n s.elems = append(s.elems, string(v)) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":141,"end_line":160,"code":"func (s *sliceArrayEncoder) AppendArray(v ArrayMarshaler) error {\n\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":162,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(byteStringsArray).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendComplex128","signature":"func (s *sliceArrayEncoder) AppendComplex128(v complex128)","start_line":162,"end_line":162,"code":"func (s *sliceArrayEncoder) AppendComplex128(v complex128)  {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":142,"end_line":161,"code":"\tenc := \u0026sliceArrayEncoder{}\n\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }"},{"path":"zapcore/memory_encoder.go","start_line":163,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(complex128s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendComplex64","signature":"func (s *sliceArrayEncoder) AppendComplex64(v complex64)","start_line":163,"end_line":163,"code":"func (s *sliceArrayEncoder) AppendComplex64(v complex64)    {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":143,"end_line":162,"code":"\terr := v.MarshalLogArray(enc)\n\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":164,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(complex64s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendDuration","signature":"func (s *sliceArrayEncoder) AppendDuration(v time.Duration)","start_line":164,"end_line":164,"code":"func (s *sliceArrayEncoder) AppendDuration(v time.Duration) {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":144,"end_line":163,"code":"\ts.elems = append(s.elems, enc.elems)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":165,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(durations).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendFloat64","signature":"func (s *sliceArrayEncoder) AppendFloat64(v float64)","start_line":165,"end_line":165,"code":"func (s *sliceArrayEncoder) AppendFloat64(v float64)        {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":145,"end_line":164,"code":"\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":166,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(float64s).MarshalLogArray","path":"array.go"},{"symbol":"EpochMillisTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"EpochTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"SecondsDurationEncoder","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendFloat32","signature":"func (s *sliceArrayEncoder) AppendFloat32(v float32)","start_line":166,"end_line":166,"code":"func (s *sliceArrayEncoder) AppendFloat32(v float32)        {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":146,"end_line":165,"code":"}\n\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":167,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(float32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendInt","signature":"func (s *sliceArrayEncoder) AppendInt(v int)","start_line":167,"end_line":167,"code":"func (s *sliceArrayEncoder) AppendInt(v int)                {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":147,"end_line":166,"code":"\nfunc (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":168,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.67},"call_graph":{"callees":null,"callers":[{"symbol":"(ints).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendInt64","signature":"func (s *sliceArrayEncoder) AppendInt64(v int64)","start_line":168,"end_line":168,"code":"func (s *sliceArrayEncoder) AppendInt64(v int64)            {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":148,"end_line":167,"code":"func (s *sliceArrayEncoder) AppendObject(v ObjectMarshaler) error {\n\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":169,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.69},"call_graph":{"callees":null,"callers":[{"symbol":"(int64s).MarshalLogArray","path":"array.go"},{"symbol":"EpochNanosTimeEncoder","path":"zapcore/encoder.go"},{"symbol":"MillisDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"NanosDurationEncoder","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendInt32","signature":"func (s *sliceArrayEncoder) AppendInt32(v int32)","start_line":169,"end_line":169,"code":"func (s *sliceArrayEncoder) AppendInt32(v int32)            {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":149,"end_line":168,"code":"\tm := NewMapObjectEncoder()\n\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":170,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(int32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendInt16","signature":"func (s *sliceArrayEncoder) AppendInt16(v int16)","start_line":170,"end_line":170,"code":"func (s *sliceArrayEncoder) AppendInt16(v int16)            {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":150,"end_line":169,"code":"\terr := v.MarshalLogObject(m)\n\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":171,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(int16s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendInt8","signature":"func (s *sliceArrayEncoder) AppendInt8(v int8)","start_line":171,"end_line":171,"code":"func (s *sliceArrayEncoder) AppendInt8(v int8)              {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":151,"end_line":170,"code":"\ts.elems = append(s.elems, m.Fields)\n\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":172,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(int8s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendString","signature":"func (s *sliceArrayEncoder) AppendString(v string)","start_line":172,"end_line":172,"code":"func (s *sliceArrayEncoder) AppendString(v string)          {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":152,"end_line":171,"code":"\treturn err\n}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":173,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.79},"call_graph":{"callees":null,"callers":[{"symbol":"(consoleEncoder).EncodeEntry","path":"zapcore/console_encoder.go"},{"symbol":"(stringArray).MarshalLogArray","path":"array.go"},{"symbol":"CapitalColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"CapitalLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"FullCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"FullNameEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseColorLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"LowercaseLevelEncoder","path":"zapcore/encoder.go"},{"symbol":"ShortCallerEncoder","path":"zapcore/encoder.go"},{"symbol":"StringDurationEncoder","path":"zapcore/encoder.go"},{"symbol":"encodeTimeLayout","path":"zapcore/encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendTime","signature":"func (s *sliceArrayEncoder) AppendTime(v time.Time)","start_line":173,"end_line":173,"code":"func (s *sliceArrayEncoder) AppendTime(v time.Time)         {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":153,"end_line":172,"code":"}\n\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":174,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(times).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUint","signature":"func (s *sliceArrayEncoder) AppendUint(v uint)","start_line":174,"end_line":174,"code":"func (s *sliceArrayEncoder) AppendUint(v uint)              {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":154,"end_line":173,"code":"\nfunc (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":175,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(uints).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUint64","signature":"func (s *sliceArrayEncoder) AppendUint64(v uint64)","start_line":175,"end_line":175,"code":"func (s *sliceArrayEncoder) AppendUint64(v uint64)          {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":155,"end_line":174,"code":"func (s *sliceArrayEncoder) AppendReflected(v interface{}) error {\n\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":176,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.68},"call_graph":{"callees":null,"callers":[{"symbol":"(uint64s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUint32","signature":"func (s *sliceArrayEncoder) AppendUint32(v uint32)","start_line":176,"end_line":176,"code":"func (s *sliceArrayEncoder) AppendUint32(v uint32)          {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":156,"end_line":175,"code":"\ts.elems = append(s.elems, v)\n\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":177,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(uint32s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUint16","signature":"func (s *sliceArrayEncoder) AppendUint16(v uint16)","start_line":177,"end_line":177,"code":"func (s *sliceArrayEncoder) AppendUint16(v uint16)          {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":157,"end_line":176,"code":"\treturn nil\n}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":178,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(uint16s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUint8","signature":"func (s *sliceArrayEncoder) AppendUint8(v uint8)","start_line":178,"end_line":178,"code":"func (s *sliceArrayEncoder) AppendUint8(v uint8)            {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":158,"end_line":177,"code":"}\n\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }"},{"path":"zapcore/memory_encoder.go","start_line":179,"end_line":180,"code":"func (s *sliceArrayEncoder) AppendUintptr(v uintptr)        { s.elems = append(s.elems, v) }\n"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(uint8s).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/memory_encoder.go","symbol":"(*sliceArrayEncoder).AppendUintptr","signature":"func (s *sliceArrayEncoder) AppendUintptr(v uintptr)","start_line":179,"end_line":179,"code":"func (s *sliceArrayEncoder) AppendUintptr(v uintptr)        {\n s.elems = append(s.elems, v) }\n","neighbors":[{"path":"zapcore/memory_encoder.go","start_line":159,"end_line":178,"code":"\nfunc (s *sliceArrayEncoder) AppendBool(v bool)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendByteString(v []byte)      { s.elems = append(s.elems, string(v)) }\nfunc (s *sliceArrayEncoder) AppendComplex128(v complex128)  { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendComplex64(v complex64)    { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendDuration(v time.Duration) { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat64(v float64)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendFloat32(v float32)        { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt(v int)                { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt64(v int64)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt32(v int32)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt16(v int16)            { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendInt8(v int8)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendString(v string)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendTime(v time.Time)         { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint(v uint)              { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint64(v uint64)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint32(v uint32)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint16(v uint16)          { s.elems = append(s.elems, v) }\nfunc (s *sliceArrayEncoder) AppendUint8(v uint8)            { s.elems = append(s.elems, v) }"}],"selection":{"visibility":"exported","reason":"encoder","score":0.65},"call_graph":{"callees":null,"callers":[{"symbol":"(uintptrs).MarshalLogArray","path":"array.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/reflected_encoder.go","symbol":"defaultReflectedEncoder","signature":"func defaultReflectedEncoder(w io.Writer) ReflectedEncoder","start_line":36,"end_line":41,"code":"func defaultReflectedEncoder(w io.Writer) ReflectedEncoder {\n\n\tenc := json.NewEncoder(w)\n\t\n\tenc.SetEscapeHTML(false)\n\treturn enc\n}\n","neighbors":[{"path":"zapcore/reflected_encoder.go","start_line":16,"end_line":35,"code":"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zapcore\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\n// ReflectedEncoder serializes log fields that can't be serialized with Zap's\n// JSON encoder. These have the ReflectType field type.\n// Use EncoderConfig.NewReflectedEncoder to set this.\ntype ReflectedEncoder interface {\n\t// Encode encodes and writes to the underlying data stream.\n\tEncode(interface{}) error\n}\n"}],"selection":{"visibility":"unexported","reason":"encoder","score":0.55},"call_graph":{"callees":[{"symbol":"(*Encoder).SetEscapeHTML","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"NewEncoder","path":"../../../../usr/local/go/src/encoding/json/stream.go"}],"callers":[{"symbol":"(*jsonEncoder).resetReflectBuf","path":"zapcore/json_encoder.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"newCounters","signature":"func newCounters() *counters","start_line":40,"end_line":42,"code":"func newCounters() *counters {\n\n\treturn \u0026counters{}\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":20,"end_line":39,"code":"\npackage zapcore\n\nimport (\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\t_numLevels        = _maxLevel - _minLevel + 1\n\t_countersPerLevel = 4096\n)\n\ntype counter struct {\n\tresetAt atomic.Int64\n\tcounter atomic.Uint64\n}\n\ntype counters [_numLevels][_countersPerLevel]counter\n"},{"path":"zapcore/sampler.go","start_line":43,"end_line":62,"code":"\nfunc (cs *counters) get(lvl Level, key string) *counter {\n\ti := lvl - _minLevel\n\tj := fnv32a(key) % _countersPerLevel\n\treturn \u0026cs[i][j]\n}\n\n// fnv32a, adapted from \"hash/fnv\", but without a []byte(string) alloc\nfunc fnv32a(s string) uint32 {\n\tconst (\n\t\toffset32 = 2166136261\n\t\tprime32  = 16777619\n\t)\n\thash := uint32(offset32)\n\tfor i := 0; i \u003c len(s); i++ {\n\t\thash ^= uint32(s[i])\n\t\thash *= prime32\n\t}\n\treturn hash\n}"}],"selection":{"visibility":"unexported","reason":"core","score":0.4},"call_graph":{"callees":null,"callers":[{"symbol":"NewSamplerWithOptions","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(*counters).get","signature":"func (cs *counters) get(lvl Level, key string) *counter","start_line":44,"end_line":48,"code":"func (cs *counters) get(lvl Level, key string) *counter {\n\n\ti := lvl - _minLevel\n\tj := fnv32a(key) % _countersPerLevel\n\treturn \u0026cs[i][j]\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":24,"end_line":43,"code":"\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\t_numLevels        = _maxLevel - _minLevel + 1\n\t_countersPerLevel = 4096\n)\n\ntype counter struct {\n\tresetAt atomic.Int64\n\tcounter atomic.Uint64\n}\n\ntype counters [_numLevels][_countersPerLevel]counter\n\nfunc newCounters() *counters {\n\treturn \u0026counters{}\n}\n"},{"path":"zapcore/sampler.go","start_line":49,"end_line":68,"code":"\n// fnv32a, adapted from \"hash/fnv\", but without a []byte(string) alloc\nfunc fnv32a(s string) uint32 {\n\tconst (\n\t\toffset32 = 2166136261\n\t\tprime32  = 16777619\n\t)\n\thash := uint32(offset32)\n\tfor i := 0; i \u003c len(s); i++ {\n\t\thash ^= uint32(s[i])\n\t\thash *= prime32\n\t}\n\treturn hash\n}\n\nfunc (c *counter) IncCheckReset(t time.Time, tick time.Duration) uint64 {\n\ttn := t.UnixNano()\n\tresetAfter := c.resetAt.Load()\n\tif resetAfter \u003e tn {\n\t\treturn c.counter.Add(1)"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":[{"symbol":"fnv32a","path":"zapcore/sampler.go"}],"callers":[{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"fnv32a","signature":"func fnv32a(s string) uint32","start_line":51,"end_line":62,"code":"func fnv32a(s string) uint32 {\n\n\tconst (\n\t\toffset32 = 2166136261\n\t\tprime32  = 16777619\n\t)\n\thash := uint32(offset32)\n\tfor i := 0; i \u003c len(s); i++ {\n\t\thash ^= uint32(s[i])\n\t\thash *= prime32\n\t}\n\treturn hash\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":31,"end_line":50,"code":")\n\ntype counter struct {\n\tresetAt atomic.Int64\n\tcounter atomic.Uint64\n}\n\ntype counters [_numLevels][_countersPerLevel]counter\n\nfunc newCounters() *counters {\n\treturn \u0026counters{}\n}\n\nfunc (cs *counters) get(lvl Level, key string) *counter {\n\ti := lvl - _minLevel\n\tj := fnv32a(key) % _countersPerLevel\n\treturn \u0026cs[i][j]\n}\n\n// fnv32a, adapted from \"hash/fnv\", but without a []byte(string) alloc"},{"path":"zapcore/sampler.go","start_line":63,"end_line":82,"code":"\nfunc (c *counter) IncCheckReset(t time.Time, tick time.Duration) uint64 {\n\ttn := t.UnixNano()\n\tresetAfter := c.resetAt.Load()\n\tif resetAfter \u003e tn {\n\t\treturn c.counter.Add(1)\n\t}\n\n\tc.counter.Store(1)\n\n\tnewResetAfter := tn + tick.Nanoseconds()\n\tif !c.resetAt.CompareAndSwap(resetAfter, newResetAfter) {\n\t\t// We raced with another goroutine trying to reset, and it also reset\n\t\t// the counter to 1, so we need to reincrement the counter.\n\t\treturn c.counter.Add(1)\n\t}\n\n\treturn 1\n}\n"}],"selection":{"visibility":"unexported","reason":"core","score":0.5},"call_graph":{"callees":null,"callers":[{"symbol":"(*counters).get","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(*counter).IncCheckReset","signature":"func (c *counter) IncCheckReset(t time.Time, tick time.Duration) uint64","start_line":64,"end_line":81,"code":"func (c *counter) IncCheckReset(t time.Time, tick time.Duration) uint64 {\n\n\ttn := t.UnixNano()\n\tresetAfter := c.resetAt.Load()\n\tif resetAfter \u003e tn {\n\t\treturn c.counter.Add(1)\n\t}\n\n\tc.counter.Store(1)\n\n\tnewResetAfter := tn + tick.Nanoseconds()\n\tif !c.resetAt.CompareAndSwap(resetAfter, newResetAfter) {\n\t\t\n\t\t\n\t\treturn c.counter.Add(1)\n\t}\n\n\treturn 1\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":44,"end_line":63,"code":"func (cs *counters) get(lvl Level, key string) *counter {\n\ti := lvl - _minLevel\n\tj := fnv32a(key) % _countersPerLevel\n\treturn \u0026cs[i][j]\n}\n\n// fnv32a, adapted from \"hash/fnv\", but without a []byte(string) alloc\nfunc fnv32a(s string) uint32 {\n\tconst (\n\t\toffset32 = 2166136261\n\t\tprime32  = 16777619\n\t)\n\thash := uint32(offset32)\n\tfor i := 0; i \u003c len(s); i++ {\n\t\thash ^= uint32(s[i])\n\t\thash *= prime32\n\t}\n\treturn hash\n}\n"},{"path":"zapcore/sampler.go","start_line":82,"end_line":101,"code":"\n// SamplingDecision is a decision represented as a bit field made by sampler.\n// More decisions may be added in the future.\ntype SamplingDecision uint32\n\nconst (\n\t// LogDropped indicates that the Sampler dropped a log entry.\n\tLogDropped SamplingDecision = 1 \u003c\u003c iota\n\t// LogSampled indicates that the Sampler sampled a log entry.\n\tLogSampled\n)\n\n// optionFunc wraps a func so it satisfies the SamplerOption interface.\ntype optionFunc func(*sampler)\n\nfunc (f optionFunc) apply(s *sampler) {\n\tf(s)\n}\n\n// SamplerOption configures a Sampler."}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":[{"symbol":"(*Int64).CompareAndSwap","path":"../../../../usr/local/go/src/sync/atomic/type.go"},{"symbol":"(*Int64).Load","path":"../../../../usr/local/go/src/sync/atomic/type.go"},{"symbol":"(*Uint64).Add","path":"../../../../usr/local/go/src/sync/atomic/type.go"},{"symbol":"(*Uint64).Store","path":"../../../../usr/local/go/src/sync/atomic/type.go"},{"symbol":"(Duration).Nanoseconds","path":"../../../../usr/local/go/src/time/time.go"},{"symbol":"(Time).UnixNano","path":"../../../../usr/local/go/src/time/time.go"}],"callers":[{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(optionFunc).apply","signature":"func (f optionFunc) apply(s *sampler)","start_line":97,"end_line":99,"code":"func (f optionFunc) apply(s *sampler) {\n\n\tf(s)\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":77,"end_line":96,"code":"\t\treturn c.counter.Add(1)\n\t}\n\n\treturn 1\n}\n\n// SamplingDecision is a decision represented as a bit field made by sampler.\n// More decisions may be added in the future.\ntype SamplingDecision uint32\n\nconst (\n\t// LogDropped indicates that the Sampler dropped a log entry.\n\tLogDropped SamplingDecision = 1 \u003c\u003c iota\n\t// LogSampled indicates that the Sampler sampled a log entry.\n\tLogSampled\n)\n\n// optionFunc wraps a func so it satisfies the SamplerOption interface.\ntype optionFunc func(*sampler)\n"},{"path":"zapcore/sampler.go","start_line":100,"end_line":119,"code":"\n// SamplerOption configures a Sampler.\ntype SamplerOption interface {\n\tapply(*sampler)\n}\n\n// nopSamplingHook is the default hook used by sampler.\nfunc nopSamplingHook(Entry, SamplingDecision) {}\n\n// SamplerHook registers a function  which will be called when Sampler makes a\n// decision.\n//\n// This hook may be used to get visibility into the performance of the sampler.\n// For example, use it to track metrics of dropped versus sampled logs.\n//\n//\tvar dropped atomic.Int64\n//\tzapcore.SamplerHook(func(ent zapcore.Entry, dec zapcore.SamplingDecision) {\n//\t  if dec\u0026zapcore.LogDropped \u003e 0 {\n//\t    dropped.Inc()\n//\t  }"}],"selection":{"visibility":"unexported","reason":"core","score":0.42},"call_graph":{"callees":[{"symbol":"SamplerHook$1","path":"zapcore/sampler.go"}],"callers":[{"symbol":"(*optionFunc).apply","path":"zapcore/sampler.go"},{"symbol":"NewSamplerWithOptions","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"nopSamplingHook","signature":"func nopSamplingHook(Entry, SamplingDecision)","start_line":107,"end_line":107,"code":"func nopSamplingHook(Entry, SamplingDecision) {\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":87,"end_line":106,"code":"const (\n\t// LogDropped indicates that the Sampler dropped a log entry.\n\tLogDropped SamplingDecision = 1 \u003c\u003c iota\n\t// LogSampled indicates that the Sampler sampled a log entry.\n\tLogSampled\n)\n\n// optionFunc wraps a func so it satisfies the SamplerOption interface.\ntype optionFunc func(*sampler)\n\nfunc (f optionFunc) apply(s *sampler) {\n\tf(s)\n}\n\n// SamplerOption configures a Sampler.\ntype SamplerOption interface {\n\tapply(*sampler)\n}\n\n// nopSamplingHook is the default hook used by sampler."},{"path":"zapcore/sampler.go","start_line":108,"end_line":127,"code":"\n// SamplerHook registers a function  which will be called when Sampler makes a\n// decision.\n//\n// This hook may be used to get visibility into the performance of the sampler.\n// For example, use it to track metrics of dropped versus sampled logs.\n//\n//\tvar dropped atomic.Int64\n//\tzapcore.SamplerHook(func(ent zapcore.Entry, dec zapcore.SamplingDecision) {\n//\t  if dec\u0026zapcore.LogDropped \u003e 0 {\n//\t    dropped.Inc()\n//\t  }\n//\t})\nfunc SamplerHook(hook func(entry Entry, dec SamplingDecision)) SamplerOption {\n\treturn optionFunc(func(s *sampler) {\n\t\ts.hook = hook\n\t})\n}\n\n// NewSamplerWithOptions creates a Core that samples incoming entries, which"}],"selection":{"visibility":"unexported","reason":"core","score":0.4},"call_graph":{"callees":null,"callers":[{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"SamplerHook","signature":"func SamplerHook(hook func(entry Entry, dec SamplingDecision)) SamplerOption","start_line":121,"end_line":125,"code":"func SamplerHook(hook func(entry Entry, dec SamplingDecision)) SamplerOption {\n\n\treturn optionFunc(func(s *sampler) {\n\t\ts.hook = hook\n\t})\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":101,"end_line":120,"code":"// SamplerOption configures a Sampler.\ntype SamplerOption interface {\n\tapply(*sampler)\n}\n\n// nopSamplingHook is the default hook used by sampler.\nfunc nopSamplingHook(Entry, SamplingDecision) {}\n\n// SamplerHook registers a function  which will be called when Sampler makes a\n// decision.\n//\n// This hook may be used to get visibility into the performance of the sampler.\n// For example, use it to track metrics of dropped versus sampled logs.\n//\n//\tvar dropped atomic.Int64\n//\tzapcore.SamplerHook(func(ent zapcore.Entry, dec zapcore.SamplingDecision) {\n//\t  if dec\u0026zapcore.LogDropped \u003e 0 {\n//\t    dropped.Inc()\n//\t  }\n//\t})"},{"path":"zapcore/sampler.go","start_line":126,"end_line":145,"code":"\n// NewSamplerWithOptions creates a Core that samples incoming entries, which\n// caps the CPU and I/O load of logging while attempting to preserve a\n// representative subset of your logs.\n//\n// Zap samples by logging the first N entries with a given level and message\n// each tick. If more Entries with the same level and message are seen during\n// the same interval, every Mth message is logged and the rest are dropped.\n//\n// For example,\n//\n//\tcore = NewSamplerWithOptions(core, time.Second, 10, 5)\n//\n// This will log the first 10 log entries with the same level and message\n// in a one second interval as-is. Following that, it will allow through\n// every 5th log entry with the same level and message in that interval.\n//\n// If thereafter is zero, the Core will drop all log entries after the first N\n// in that interval.\n//"}],"selection":{"visibility":"exported","reason":"core","score":0.7},"call_graph":{"callees":null,"callers":[{"symbol":"buildOptions$1","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"NewSamplerWithOptions","signature":"func NewSamplerWithOptions(core Core, tick time.Duration, first, thereafter int, opts ...SamplerOption) Core","start_line":152,"end_line":166,"code":"func NewSamplerWithOptions(core Core, tick time.Duration, first, thereafter int, opts ...SamplerOption) Core {\n\n\ts := \u0026sampler{\n\t\tCore:       core,\n\t\ttick:       tick,\n\t\tcounts:     newCounters(),\n\t\tfirst:      uint64(first),\n\t\tthereafter: uint64(thereafter),\n\t\thook:       nopSamplingHook,\n\t}\n\tfor _, opt := range opts {\n\t\topt.apply(s)\n\t}\n\n\treturn s\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":132,"end_line":151,"code":"// each tick. If more Entries with the same level and message are seen during\n// the same interval, every Mth message is logged and the rest are dropped.\n//\n// For example,\n//\n//\tcore = NewSamplerWithOptions(core, time.Second, 10, 5)\n//\n// This will log the first 10 log entries with the same level and message\n// in a one second interval as-is. Following that, it will allow through\n// every 5th log entry with the same level and message in that interval.\n//\n// If thereafter is zero, the Core will drop all log entries after the first N\n// in that interval.\n//\n// Sampler can be configured to report sampling decisions with the SamplerHook\n// option.\n//\n// Keep in mind that Zap's sampling implementation is optimized for speed over\n// absolute precision; under load, each tick may be slightly over- or\n// under-sampled."},{"path":"zapcore/sampler.go","start_line":167,"end_line":186,"code":"\ntype sampler struct {\n\tCore\n\n\tcounts            *counters\n\ttick              time.Duration\n\tfirst, thereafter uint64\n\thook              func(Entry, SamplingDecision)\n}\n\nvar (\n\t_ Core           = (*sampler)(nil)\n\t_ leveledEnabler = (*sampler)(nil)\n)\n\n// NewSampler creates a Core that samples incoming entries, which\n// caps the CPU and I/O load of logging while attempting to preserve a\n// representative subset of your logs.\n//\n// Zap samples by logging the first N entries with a given level and message"}],"selection":{"visibility":"exported","reason":"constructor","score":0.86},"call_graph":{"callees":[{"symbol":"(optionFunc).apply","path":"zapcore/sampler.go"},{"symbol":"newCounters","path":"zapcore/sampler.go"}],"callers":[{"symbol":"NewSampler","path":"zapcore/sampler.go"},{"symbol":"buildOptions$1","path":"config.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"NewSampler","signature":"func NewSampler(core Core, tick time.Duration, first, thereafter int) Core","start_line":195,"end_line":197,"code":"func NewSampler(core Core, tick time.Duration, first, thereafter int) Core {\n\n\treturn NewSamplerWithOptions(core, tick, first, thereafter)\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":175,"end_line":194,"code":"}\n\nvar (\n\t_ Core           = (*sampler)(nil)\n\t_ leveledEnabler = (*sampler)(nil)\n)\n\n// NewSampler creates a Core that samples incoming entries, which\n// caps the CPU and I/O load of logging while attempting to preserve a\n// representative subset of your logs.\n//\n// Zap samples by logging the first N entries with a given level and message\n// each tick. If more Entries with the same level and message are seen during\n// the same interval, every Mth message is logged and the rest are dropped.\n//\n// Keep in mind that zap's sampling implementation is optimized for speed over\n// absolute precision; under load, each tick may be slightly over- or\n// under-sampled.\n//\n// Deprecated: use NewSamplerWithOptions."},{"path":"zapcore/sampler.go","start_line":198,"end_line":217,"code":"\nfunc (s *sampler) Level() Level {\n\treturn LevelOf(s.Core)\n}\n\nfunc (s *sampler) With(fields []Field) Core {\n\treturn \u0026sampler{\n\t\tCore:       s.Core.With(fields),\n\t\ttick:       s.tick,\n\t\tcounts:     s.counts,\n\t\tfirst:      s.first,\n\t\tthereafter: s.thereafter,\n\t\thook:       s.hook,\n\t}\n}\n\nfunc (s *sampler) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !s.Enabled(ent.Level) {\n\t\treturn ce\n\t}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.75},"call_graph":{"callees":[{"symbol":"NewSamplerWithOptions","path":"zapcore/sampler.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(*sampler).Level","signature":"func (s *sampler) Level() Level","start_line":199,"end_line":201,"code":"func (s *sampler) Level() Level {\n\n\treturn LevelOf(s.Core)\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":179,"end_line":198,"code":"\t_ leveledEnabler = (*sampler)(nil)\n)\n\n// NewSampler creates a Core that samples incoming entries, which\n// caps the CPU and I/O load of logging while attempting to preserve a\n// representative subset of your logs.\n//\n// Zap samples by logging the first N entries with a given level and message\n// each tick. If more Entries with the same level and message are seen during\n// the same interval, every Mth message is logged and the rest are dropped.\n//\n// Keep in mind that zap's sampling implementation is optimized for speed over\n// absolute precision; under load, each tick may be slightly over- or\n// under-sampled.\n//\n// Deprecated: use NewSamplerWithOptions.\nfunc NewSampler(core Core, tick time.Duration, first, thereafter int) Core {\n\treturn NewSamplerWithOptions(core, tick, first, thereafter)\n}\n"},{"path":"zapcore/sampler.go","start_line":202,"end_line":221,"code":"\nfunc (s *sampler) With(fields []Field) Core {\n\treturn \u0026sampler{\n\t\tCore:       s.Core.With(fields),\n\t\ttick:       s.tick,\n\t\tcounts:     s.counts,\n\t\tfirst:      s.first,\n\t\tthereafter: s.thereafter,\n\t\thook:       s.hook,\n\t}\n}\n\nfunc (s *sampler) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !s.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\tif ent.Level \u003e= _minLevel \u0026\u0026 ent.Level \u003c= _maxLevel {\n\t\tcounter := s.counts.get(ent.Level, ent.Message)\n\t\tn := counter.IncCheckReset(ent.Time, s.tick)"}],"selection":{"visibility":"exported","reason":"core","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(*sampler).With","signature":"func (s *sampler) With(fields []Field) Core","start_line":203,"end_line":212,"code":"func (s *sampler) With(fields []Field) Core {\n\n\treturn \u0026sampler{\n\t\tCore:       s.Core.With(fields),\n\t\ttick:       s.tick,\n\t\tcounts:     s.counts,\n\t\tfirst:      s.first,\n\t\tthereafter: s.thereafter,\n\t\thook:       s.hook,\n\t}\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":183,"end_line":202,"code":"// caps the CPU and I/O load of logging while attempting to preserve a\n// representative subset of your logs.\n//\n// Zap samples by logging the first N entries with a given level and message\n// each tick. If more Entries with the same level and message are seen during\n// the same interval, every Mth message is logged and the rest are dropped.\n//\n// Keep in mind that zap's sampling implementation is optimized for speed over\n// absolute precision; under load, each tick may be slightly over- or\n// under-sampled.\n//\n// Deprecated: use NewSamplerWithOptions.\nfunc NewSampler(core Core, tick time.Duration, first, thereafter int) Core {\n\treturn NewSamplerWithOptions(core, tick, first, thereafter)\n}\n\nfunc (s *sampler) Level() Level {\n\treturn LevelOf(s.Core)\n}\n"},{"path":"zapcore/sampler.go","start_line":213,"end_line":230,"code":"\nfunc (s *sampler) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tif !s.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\tif ent.Level \u003e= _minLevel \u0026\u0026 ent.Level \u003c= _maxLevel {\n\t\tcounter := s.counts.get(ent.Level, ent.Message)\n\t\tn := counter.IncCheckReset(ent.Time, s.tick)\n\t\tif n \u003e s.first \u0026\u0026 (s.thereafter == 0 || (n-s.first)%s.thereafter != 0) {\n\t\t\ts.hook(ent, LogDropped)\n\t\t\treturn ce\n\t\t}\n\t\ts.hook(ent, LogSampled)\n\t}\n\treturn s.Core.Check(ent, ce)\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.89},"call_graph":{"callees":[{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/sampler.go","symbol":"(*sampler).Check","signature":"func (s *sampler) Check(ent Entry, ce *CheckedEntry) *CheckedEntry","start_line":214,"end_line":229,"code":"func (s *sampler) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\n\tif !s.Enabled(ent.Level) {\n\t\treturn ce\n\t}\n\n\tif ent.Level \u003e= _minLevel \u0026\u0026 ent.Level \u003c= _maxLevel {\n\t\tcounter := s.counts.get(ent.Level, ent.Message)\n\t\tn := counter.IncCheckReset(ent.Time, s.tick)\n\t\tif n \u003e s.first \u0026\u0026 (s.thereafter == 0 || (n-s.first)%s.thereafter != 0) {\n\t\t\ts.hook(ent, LogDropped)\n\t\t\treturn ce\n\t\t}\n\t\ts.hook(ent, LogSampled)\n\t}\n\treturn s.Core.Check(ent, ce)\n}\n","neighbors":[{"path":"zapcore/sampler.go","start_line":194,"end_line":213,"code":"// Deprecated: use NewSamplerWithOptions.\nfunc NewSampler(core Core, tick time.Duration, first, thereafter int) Core {\n\treturn NewSamplerWithOptions(core, tick, first, thereafter)\n}\n\nfunc (s *sampler) Level() Level {\n\treturn LevelOf(s.Core)\n}\n\nfunc (s *sampler) With(fields []Field) Core {\n\treturn \u0026sampler{\n\t\tCore:       s.Core.With(fields),\n\t\ttick:       s.tick,\n\t\tcounts:     s.counts,\n\t\tfirst:      s.first,\n\t\tthereafter: s.thereafter,\n\t\thook:       s.hook,\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.74},"call_graph":{"callees":[{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*counter).IncCheckReset","path":"zapcore/sampler.go"},{"symbol":"(*counters).get","path":"zapcore/sampler.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"nopSamplingHook","path":"zapcore/sampler.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"NewTee","signature":"func NewTee(cores ...Core) Core","start_line":37,"end_line":46,"code":"func NewTee(cores ...Core) Core {\n\n\tswitch len(cores) {\n\tcase 0:\n\t\treturn NewNopCore()\n\tcase 1:\n\t\treturn cores[0]\n\tdefault:\n\t\treturn multiCore(cores)\n\t}\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":17,"end_line":36,"code":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zapcore\n\nimport \"go.uber.org/multierr\"\n\ntype multiCore []Core\n\nvar (\n\t_ leveledEnabler = multiCore(nil)\n\t_ Core           = multiCore(nil)\n)\n\n// NewTee creates a Core that duplicates log entries into two or more\n// underlying Cores.\n//\n// Calling it with a single Core returns the input unchanged, and calling\n// it with no input returns a no-op Core."},{"path":"zapcore/tee.go","start_line":47,"end_line":66,"code":"\nfunc (mc multiCore) With(fields []Field) Core {\n\tclone := make(multiCore, len(mc))\n\tfor i := range mc {\n\t\tclone[i] = mc[i].With(fields)\n\t}\n\treturn clone\n}\n\nfunc (mc multiCore) Level() Level {\n\tminLvl := _maxLevel // mc is never empty\n\tfor i := range mc {\n\t\tif lvl := LevelOf(mc[i]); lvl \u003c minLvl {\n\t\t\tminLvl = lvl\n\t\t}\n\t}\n\treturn minLvl\n}\n\nfunc (mc multiCore) Enabled(lvl Level) bool {"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"NewNopCore","path":"zapcore/core.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).With","signature":"func (mc multiCore) With(fields []Field) Core","start_line":48,"end_line":54,"code":"func (mc multiCore) With(fields []Field) Core {\n\n\tclone := make(multiCore, len(mc))\n\tfor i := range mc {\n\t\tclone[i] = mc[i].With(fields)\n\t}\n\treturn clone\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":28,"end_line":47,"code":"\t_ leveledEnabler = multiCore(nil)\n\t_ Core           = multiCore(nil)\n)\n\n// NewTee creates a Core that duplicates log entries into two or more\n// underlying Cores.\n//\n// Calling it with a single Core returns the input unchanged, and calling\n// it with no input returns a no-op Core.\nfunc NewTee(cores ...Core) Core {\n\tswitch len(cores) {\n\tcase 0:\n\t\treturn NewNopCore()\n\tcase 1:\n\t\treturn cores[0]\n\tdefault:\n\t\treturn multiCore(cores)\n\t}\n}\n"},{"path":"zapcore/tee.go","start_line":55,"end_line":74,"code":"\nfunc (mc multiCore) Level() Level {\n\tminLvl := _maxLevel // mc is never empty\n\tfor i := range mc {\n\t\tif lvl := LevelOf(mc[i]); lvl \u003c minLvl {\n\t\t\tminLvl = lvl\n\t\t}\n\t}\n\treturn minLvl\n}\n\nfunc (mc multiCore) Enabled(lvl Level) bool {\n\tfor i := range mc {\n\t\tif mc[i].Enabled(lvl) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.89},"call_graph":{"callees":[{"symbol":"(*contextObserver).With","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*ioCore).With","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"(nopCore).With","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*multiCore).With","path":"zapcore/tee.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).Level","signature":"func (mc multiCore) Level() Level","start_line":56,"end_line":64,"code":"func (mc multiCore) Level() Level {\n\n\tminLvl := _maxLevel \n\tfor i := range mc {\n\t\tif lvl := LevelOf(mc[i]); lvl \u003c minLvl {\n\t\t\tminLvl = lvl\n\t\t}\n\t}\n\treturn minLvl\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":36,"end_line":55,"code":"// it with no input returns a no-op Core.\nfunc NewTee(cores ...Core) Core {\n\tswitch len(cores) {\n\tcase 0:\n\t\treturn NewNopCore()\n\tcase 1:\n\t\treturn cores[0]\n\tdefault:\n\t\treturn multiCore(cores)\n\t}\n}\n\nfunc (mc multiCore) With(fields []Field) Core {\n\tclone := make(multiCore, len(mc))\n\tfor i := range mc {\n\t\tclone[i] = mc[i].With(fields)\n\t}\n\treturn clone\n}\n"},{"path":"zapcore/tee.go","start_line":65,"end_line":84,"code":"\nfunc (mc multiCore) Enabled(lvl Level) bool {\n\tfor i := range mc {\n\t\tif mc[i].Enabled(lvl) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tfor i := range mc {\n\t\tce = mc[i].Check(ent, ce)\n\t}\n\treturn ce\n}\n\nfunc (mc multiCore) Write(ent Entry, fields []Field) error {\n\tvar err error\n\tfor i := range mc {"}],"selection":{"visibility":"exported","reason":"core","score":0.73},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"(*multiCore).Level","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).Enabled","signature":"func (mc multiCore) Enabled(lvl Level) bool","start_line":66,"end_line":73,"code":"func (mc multiCore) Enabled(lvl Level) bool {\n\n\tfor i := range mc {\n\t\tif mc[i].Enabled(lvl) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":46,"end_line":65,"code":"}\n\nfunc (mc multiCore) With(fields []Field) Core {\n\tclone := make(multiCore, len(mc))\n\tfor i := range mc {\n\t\tclone[i] = mc[i].With(fields)\n\t}\n\treturn clone\n}\n\nfunc (mc multiCore) Level() Level {\n\tminLvl := _maxLevel // mc is never empty\n\tfor i := range mc {\n\t\tif lvl := LevelOf(mc[i]); lvl \u003c minLvl {\n\t\t\tminLvl = lvl\n\t\t}\n\t}\n\treturn minLvl\n}\n"},{"path":"zapcore/tee.go","start_line":74,"end_line":93,"code":"\nfunc (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tfor i := range mc {\n\t\tce = mc[i].Check(ent, ce)\n\t}\n\treturn ce\n}\n\nfunc (mc multiCore) Write(ent Entry, fields []Field) error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Write(ent, fields))\n\t}\n\treturn err\n}\n\nfunc (mc multiCore) Sync() error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Sync())"}],"selection":{"visibility":"exported","reason":"core","score":0.78},"call_graph":{"callees":[{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).V","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*SugaredLogger).log","path":"sugar.go"},{"symbol":"(*SugaredLogger).logln","path":"sugar.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(*multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"LevelOf","path":"zapcore/level.go"},{"symbol":"NewIncreaseLevelCore","path":"zapcore/increase_level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).Check","signature":"func (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry","start_line":75,"end_line":80,"code":"func (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\n\tfor i := range mc {\n\t\tce = mc[i].Check(ent, ce)\n\t}\n\treturn ce\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":55,"end_line":74,"code":"\nfunc (mc multiCore) Level() Level {\n\tminLvl := _maxLevel // mc is never empty\n\tfor i := range mc {\n\t\tif lvl := LevelOf(mc[i]); lvl \u003c minLvl {\n\t\t\tminLvl = lvl\n\t\t}\n\t}\n\treturn minLvl\n}\n\nfunc (mc multiCore) Enabled(lvl Level) bool {\n\tfor i := range mc {\n\t\tif mc[i].Enabled(lvl) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"},{"path":"zapcore/tee.go","start_line":81,"end_line":97,"code":"\nfunc (mc multiCore) Write(ent Entry, fields []Field) error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Write(ent, fields))\n\t}\n\treturn err\n}\n\nfunc (mc multiCore) Sync() error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Sync())\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.74},"call_graph":{"callees":[{"symbol":"(*contextObserver).Check","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Check","path":"zapcore/core.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(nopCore).Check","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*multiCore).Check","path":"zapcore/tee.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).Write","signature":"func (mc multiCore) Write(ent Entry, fields []Field) error","start_line":82,"end_line":88,"code":"func (mc multiCore) Write(ent Entry, fields []Field) error {\n\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Write(ent, fields))\n\t}\n\treturn err\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":62,"end_line":81,"code":"\t}\n\treturn minLvl\n}\n\nfunc (mc multiCore) Enabled(lvl Level) bool {\n\tfor i := range mc {\n\t\tif mc[i].Enabled(lvl) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tfor i := range mc {\n\t\tce = mc[i].Check(ent, ce)\n\t}\n\treturn ce\n}\n"},{"path":"zapcore/tee.go","start_line":89,"end_line":97,"code":"\nfunc (mc multiCore) Sync() error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Sync())\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"(*contextObserver).Write","path":"zaptest/observer/observer.go"},{"symbol":"(*hooked).Write","path":"zapcore/hook.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"},{"symbol":"(nopCore).Write","path":"zapcore/core.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(*multiCore).Write","path":"zapcore/tee.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/tee.go","symbol":"(multiCore).Sync","signature":"func (mc multiCore) Sync() error","start_line":90,"end_line":96,"code":"func (mc multiCore) Sync() error {\n\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Sync())\n\t}\n\treturn err\n}\n","neighbors":[{"path":"zapcore/tee.go","start_line":70,"end_line":89,"code":"\t\t}\n\t}\n\treturn false\n}\n\nfunc (mc multiCore) Check(ent Entry, ce *CheckedEntry) *CheckedEntry {\n\tfor i := range mc {\n\t\tce = mc[i].Check(ent, ce)\n\t}\n\treturn ce\n}\n\nfunc (mc multiCore) Write(ent Entry, fields []Field) error {\n\tvar err error\n\tfor i := range mc {\n\t\terr = multierr.Append(err, mc[i].Write(ent, fields))\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.76},"call_graph":{"callees":[{"symbol":"(*contextObserver).Sync","path":"zaptest/observer/observer.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"},{"symbol":"(nopCore).Sync","path":"zapcore/core.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*Logger).Sync","path":"logger.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(*multiCore).Sync","path":"zapcore/tee.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"AddSync","signature":"func AddSync(w io.Writer) WriteSyncer","start_line":40,"end_line":47,"code":"func AddSync(w io.Writer) WriteSyncer {\n\n\tswitch w := w.(type) {\n\tcase WriteSyncer:\n\t\treturn w\n\tdefault:\n\t\treturn writerWrapper{w}\n\t}\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":20,"end_line":39,"code":"\npackage zapcore\n\nimport (\n\t\"io\"\n\t\"sync\"\n\n\t\"go.uber.org/multierr\"\n)\n\n// A WriteSyncer is an io.Writer that can also flush any buffered data. Note\n// that *os.File (and thus, os.Stderr and os.Stdout) implement WriteSyncer.\ntype WriteSyncer interface {\n\tio.Writer\n\tSync() error\n}\n\n// AddSync converts an io.Writer to a WriteSyncer. It attempts to be\n// intelligent: if the concrete type of the io.Writer implements WriteSyncer,\n// we'll use the existing Sync method. If it doesn't, we'll add a no-op Sync."},{"path":"zapcore/write_syncer.go","start_line":48,"end_line":67,"code":"\ntype lockedWriteSyncer struct {\n\tsync.Mutex\n\tws WriteSyncer\n}\n\n// Lock wraps a WriteSyncer in a mutex to make it safe for concurrent use. In\n// particular, *os.Files must be locked before use.\nfunc Lock(ws WriteSyncer) WriteSyncer {\n\tif _, ok := ws.(*lockedWriteSyncer); ok {\n\t\t// no need to layer on another lock\n\t\treturn ws\n\t}\n\treturn \u0026lockedWriteSyncer{ws: ws}\n}\n\nfunc (s *lockedWriteSyncer) Write(bs []byte) (int, error) {\n\ts.Lock()\n\tn, err := s.ws.Write(bs)\n\ts.Unlock()"}],"selection":{"visibility":"exported","reason":"core","score":0.71},"call_graph":{"callees":null,"callers":[{"symbol":"CombineWriteSyncers","path":"writer.go"},{"symbol":"NewNop","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"Lock","signature":"func Lock(ws WriteSyncer) WriteSyncer","start_line":56,"end_line":62,"code":"func Lock(ws WriteSyncer) WriteSyncer {\n\n\tif _, ok := ws.(*lockedWriteSyncer); ok {\n\t\t\n\t\treturn ws\n\t}\n\treturn \u0026lockedWriteSyncer{ws: ws}\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":36,"end_line":55,"code":"\n// AddSync converts an io.Writer to a WriteSyncer. It attempts to be\n// intelligent: if the concrete type of the io.Writer implements WriteSyncer,\n// we'll use the existing Sync method. If it doesn't, we'll add a no-op Sync.\nfunc AddSync(w io.Writer) WriteSyncer {\n\tswitch w := w.(type) {\n\tcase WriteSyncer:\n\t\treturn w\n\tdefault:\n\t\treturn writerWrapper{w}\n\t}\n}\n\ntype lockedWriteSyncer struct {\n\tsync.Mutex\n\tws WriteSyncer\n}\n\n// Lock wraps a WriteSyncer in a mutex to make it safe for concurrent use. In\n// particular, *os.Files must be locked before use."},{"path":"zapcore/write_syncer.go","start_line":63,"end_line":82,"code":"\nfunc (s *lockedWriteSyncer) Write(bs []byte) (int, error) {\n\ts.Lock()\n\tn, err := s.ws.Write(bs)\n\ts.Unlock()\n\treturn n, err\n}\n\nfunc (s *lockedWriteSyncer) Sync() error {\n\ts.Lock()\n\terr := s.ws.Sync()\n\ts.Unlock()\n\treturn err\n}\n\ntype writerWrapper struct {\n\tio.Writer\n}\n\nfunc (w writerWrapper) Sync() error {"}],"selection":{"visibility":"exported","reason":"core","score":0.76},"call_graph":{"callees":null,"callers":[{"symbol":"CombineWriteSyncers","path":"writer.go"},{"symbol":"New","path":"logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"(*lockedWriteSyncer).Write","signature":"func (s *lockedWriteSyncer) Write(bs []byte) (int, error)","start_line":64,"end_line":69,"code":"func (s *lockedWriteSyncer) Write(bs []byte) (int, error) {\n\n\ts.Lock()\n\tn, err := s.ws.Write(bs)\n\ts.Unlock()\n\treturn n, err\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":44,"end_line":63,"code":"\tdefault:\n\t\treturn writerWrapper{w}\n\t}\n}\n\ntype lockedWriteSyncer struct {\n\tsync.Mutex\n\tws WriteSyncer\n}\n\n// Lock wraps a WriteSyncer in a mutex to make it safe for concurrent use. In\n// particular, *os.Files must be locked before use.\nfunc Lock(ws WriteSyncer) WriteSyncer {\n\tif _, ok := ws.(*lockedWriteSyncer); ok {\n\t\t// no need to layer on another lock\n\t\treturn ws\n\t}\n\treturn \u0026lockedWriteSyncer{ws: ws}\n}\n"},{"path":"zapcore/write_syncer.go","start_line":70,"end_line":89,"code":"\nfunc (s *lockedWriteSyncer) Sync() error {\n\ts.Lock()\n\terr := s.ws.Sync()\n\ts.Unlock()\n\treturn err\n}\n\ntype writerWrapper struct {\n\tio.Writer\n}\n\nfunc (w writerWrapper) Sync() error {\n\treturn nil\n}\n\ntype multiWriteSyncer []WriteSyncer\n\n// NewMultiWriteSyncer creates a WriteSyncer that duplicates its writes\n// and sync calls, much like io.MultiWriter."}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"(*Buffer).Write","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*BufferedWriteSyncer).Write","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*Builder).Write","path":"../../../../usr/local/go/src/strings/builder.go"},{"symbol":"(*Decoder).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/hpack.go"},{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha3/sha3.go"},{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512.go"},{"symbol":"(*Discarder).Write","path":"internal/ztest/writer.go"},{"symbol":"(*File).Write","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*SHA3).Write","path":"../../../../usr/local/go/src/crypto/sha3/sha3.go"},{"symbol":"(*SHAKE).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha3/shake.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*dictWriter).Write","path":"../../../../usr/local/go/src/compress/flate/deflate.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/crypto/sha1/sha1.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/hash/crc32/crc32.go"},{"symbol":"(*encoder).Write","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2bufferedWriterTimeoutWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2pipe).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2responseWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*lockedWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"(*loggingConn).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*netFD).Write","path":"../../../../usr/local/go/src/net/fd_posix.go"},{"symbol":"(*part).Write","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*populateResponse).Write","path":"../../../../usr/local/go/src/net/http/filetransport.go"},{"symbol":"(*prefixSuffixSaver).Write","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*response).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(TestingWriter).Write","path":"zaptest/logger.go"},{"symbol":"(http2stickyErrWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(multiWriteSyncer).Write","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"(*lockedWriteSyncer).Sync","signature":"func (s *lockedWriteSyncer) Sync() error","start_line":71,"end_line":76,"code":"func (s *lockedWriteSyncer) Sync() error {\n\n\ts.Lock()\n\terr := s.ws.Sync()\n\ts.Unlock()\n\treturn err\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":51,"end_line":70,"code":"\tws WriteSyncer\n}\n\n// Lock wraps a WriteSyncer in a mutex to make it safe for concurrent use. In\n// particular, *os.Files must be locked before use.\nfunc Lock(ws WriteSyncer) WriteSyncer {\n\tif _, ok := ws.(*lockedWriteSyncer); ok {\n\t\t// no need to layer on another lock\n\t\treturn ws\n\t}\n\treturn \u0026lockedWriteSyncer{ws: ws}\n}\n\nfunc (s *lockedWriteSyncer) Write(bs []byte) (int, error) {\n\ts.Lock()\n\tn, err := s.ws.Write(bs)\n\ts.Unlock()\n\treturn n, err\n}\n"},{"path":"zapcore/write_syncer.go","start_line":77,"end_line":96,"code":"\ntype writerWrapper struct {\n\tio.Writer\n}\n\nfunc (w writerWrapper) Sync() error {\n\treturn nil\n}\n\ntype multiWriteSyncer []WriteSyncer\n\n// NewMultiWriteSyncer creates a WriteSyncer that duplicates its writes\n// and sync calls, much like io.MultiWriter.\nfunc NewMultiWriteSyncer(ws ...WriteSyncer) WriteSyncer {\n\tif len(ws) == 1 {\n\t\treturn ws[0]\n\t}\n\treturn multiWriteSyncer(ws)\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.76},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*File).Sync","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"(*Mutex).Lock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Mutex).Unlock","path":"../../../../usr/local/go/src/sync/mutex.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(writerWrapper).Sync","path":"zapcore/write_syncer.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"(writerWrapper).Sync","signature":"func (w writerWrapper) Sync() error","start_line":82,"end_line":84,"code":"func (w writerWrapper) Sync() error {\n\n\treturn nil\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":62,"end_line":81,"code":"}\n\nfunc (s *lockedWriteSyncer) Write(bs []byte) (int, error) {\n\ts.Lock()\n\tn, err := s.ws.Write(bs)\n\ts.Unlock()\n\treturn n, err\n}\n\nfunc (s *lockedWriteSyncer) Sync() error {\n\ts.Lock()\n\terr := s.ws.Sync()\n\ts.Unlock()\n\treturn err\n}\n\ntype writerWrapper struct {\n\tio.Writer\n}\n"},{"path":"zapcore/write_syncer.go","start_line":85,"end_line":104,"code":"\ntype multiWriteSyncer []WriteSyncer\n\n// NewMultiWriteSyncer creates a WriteSyncer that duplicates its writes\n// and sync calls, much like io.MultiWriter.\nfunc NewMultiWriteSyncer(ws ...WriteSyncer) WriteSyncer {\n\tif len(ws) == 1 {\n\t\treturn ws[0]\n\t}\n\treturn multiWriteSyncer(ws)\n}\n\n// See https://golang.org/src/io/multi.go\n// When not all underlying syncers write the same number of bytes,\n// the smallest number is returned even though Write() is called on\n// all of them.\nfunc (ws multiWriteSyncer) Write(p []byte) (int, error) {\n\tvar writeErr error\n\tnWritten := 0\n\tfor _, w := range ws {"}],"selection":{"visibility":"exported","reason":"core","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(*writerWrapper).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"NewMultiWriteSyncer","signature":"func NewMultiWriteSyncer(ws ...WriteSyncer) WriteSyncer","start_line":90,"end_line":95,"code":"func NewMultiWriteSyncer(ws ...WriteSyncer) WriteSyncer {\n\n\tif len(ws) == 1 {\n\t\treturn ws[0]\n\t}\n\treturn multiWriteSyncer(ws)\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":70,"end_line":89,"code":"\nfunc (s *lockedWriteSyncer) Sync() error {\n\ts.Lock()\n\terr := s.ws.Sync()\n\ts.Unlock()\n\treturn err\n}\n\ntype writerWrapper struct {\n\tio.Writer\n}\n\nfunc (w writerWrapper) Sync() error {\n\treturn nil\n}\n\ntype multiWriteSyncer []WriteSyncer\n\n// NewMultiWriteSyncer creates a WriteSyncer that duplicates its writes\n// and sync calls, much like io.MultiWriter."},{"path":"zapcore/write_syncer.go","start_line":96,"end_line":115,"code":"\n// See https://golang.org/src/io/multi.go\n// When not all underlying syncers write the same number of bytes,\n// the smallest number is returned even though Write() is called on\n// all of them.\nfunc (ws multiWriteSyncer) Write(p []byte) (int, error) {\n\tvar writeErr error\n\tnWritten := 0\n\tfor _, w := range ws {\n\t\tn, err := w.Write(p)\n\t\twriteErr = multierr.Append(writeErr, err)\n\t\tif nWritten == 0 \u0026\u0026 n != 0 {\n\t\t\tnWritten = n\n\t\t} else if n \u003c nWritten {\n\t\t\tnWritten = n\n\t\t}\n\t}\n\treturn nWritten, writeErr\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":[{"symbol":"CombineWriteSyncers","path":"writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"(multiWriteSyncer).Write","signature":"func (ws multiWriteSyncer) Write(p []byte) (int, error)","start_line":101,"end_line":114,"code":"func (ws multiWriteSyncer) Write(p []byte) (int, error) {\n\n\tvar writeErr error\n\tnWritten := 0\n\tfor _, w := range ws {\n\t\tn, err := w.Write(p)\n\t\twriteErr = multierr.Append(writeErr, err)\n\t\tif nWritten == 0 \u0026\u0026 n != 0 {\n\t\t\tnWritten = n\n\t\t} else if n \u003c nWritten {\n\t\t\tnWritten = n\n\t\t}\n\t}\n\treturn nWritten, writeErr\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":81,"end_line":100,"code":"\nfunc (w writerWrapper) Sync() error {\n\treturn nil\n}\n\ntype multiWriteSyncer []WriteSyncer\n\n// NewMultiWriteSyncer creates a WriteSyncer that duplicates its writes\n// and sync calls, much like io.MultiWriter.\nfunc NewMultiWriteSyncer(ws ...WriteSyncer) WriteSyncer {\n\tif len(ws) == 1 {\n\t\treturn ws[0]\n\t}\n\treturn multiWriteSyncer(ws)\n}\n\n// See https://golang.org/src/io/multi.go\n// When not all underlying syncers write the same number of bytes,\n// the smallest number is returned even though Write() is called on\n// all of them."},{"path":"zapcore/write_syncer.go","start_line":115,"end_line":123,"code":"\nfunc (ws multiWriteSyncer) Sync() error {\n\tvar err error\n\tfor _, w := range ws {\n\t\terr = multierr.Append(err, w.Sync())\n\t}\n\treturn err\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.8},"call_graph":{"callees":[{"symbol":"(*Buffer).Write","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*BufferedWriteSyncer).Write","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*Builder).Write","path":"../../../../usr/local/go/src/strings/builder.go"},{"symbol":"(*Decoder).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/hpack.go"},{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha3/sha3.go"},{"symbol":"(*Digest).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha512/sha512.go"},{"symbol":"(*Discarder).Write","path":"internal/ztest/writer.go"},{"symbol":"(*File).Write","path":"../../../../usr/local/go/src/os/file.go"},{"symbol":"(*SHA3).Write","path":"../../../../usr/local/go/src/crypto/sha3/sha3.go"},{"symbol":"(*SHAKE).Write","path":"../../../../usr/local/go/src/crypto/internal/fips140/sha3/shake.go"},{"symbol":"(*Writer).Write","path":"zapio/writer.go"},{"symbol":"(*dictWriter).Write","path":"../../../../usr/local/go/src/compress/flate/deflate.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/crypto/sha1/sha1.go"},{"symbol":"(*digest).Write","path":"../../../../usr/local/go/src/hash/crc32/crc32.go"},{"symbol":"(*dotWriter).Write","path":"../../../../usr/local/go/src/net/textproto/writer.go"},{"symbol":"(*encoder).Write","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2bufferedWriterTimeoutWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2pipe).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2responseWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*lockedWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"(*loggingConn).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*netFD).Write","path":"../../../../usr/local/go/src/net/fd_posix.go"},{"symbol":"(*part).Write","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*populateResponse).Write","path":"../../../../usr/local/go/src/net/http/filetransport.go"},{"symbol":"(*prefixSuffixSaver).Write","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"(*response).Write","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(TestingWriter).Write","path":"zaptest/logger.go"},{"symbol":"(http2stickyErrWriter).Write","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(multiWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*ioCore).Write","path":"zapcore/core.go"},{"symbol":"(*multiWriteSyncer).Write","path":"zapcore/write_syncer.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapcore/write_syncer.go","symbol":"(multiWriteSyncer).Sync","signature":"func (ws multiWriteSyncer) Sync() error","start_line":116,"end_line":122,"code":"func (ws multiWriteSyncer) Sync() error {\n\n\tvar err error\n\tfor _, w := range ws {\n\t\terr = multierr.Append(err, w.Sync())\n\t}\n\treturn err\n}\n","neighbors":[{"path":"zapcore/write_syncer.go","start_line":96,"end_line":115,"code":"\n// See https://golang.org/src/io/multi.go\n// When not all underlying syncers write the same number of bytes,\n// the smallest number is returned even though Write() is called on\n// all of them.\nfunc (ws multiWriteSyncer) Write(p []byte) (int, error) {\n\tvar writeErr error\n\tnWritten := 0\n\tfor _, w := range ws {\n\t\tn, err := w.Write(p)\n\t\twriteErr = multierr.Append(writeErr, err)\n\t\tif nWritten == 0 \u0026\u0026 n != 0 {\n\t\t\tnWritten = n\n\t\t} else if n \u003c nWritten {\n\t\t\tnWritten = n\n\t\t}\n\t}\n\treturn nWritten, writeErr\n}\n"}],"selection":{"visibility":"exported","reason":"core","score":0.76},"call_graph":{"callees":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*File).Sync","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"(*Syncer).Sync","path":"internal/ztest/writer.go"},{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(writerWrapper).Sync","path":"zapcore/write_syncer.go"},{"symbol":"Append","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(*multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(optionFunc).apply","signature":"func (f optionFunc) apply(log *Logger)","start_line":55,"end_line":57,"code":"func (f optionFunc) apply(log *Logger) {\n\n\tf(log)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":35,"end_line":54,"code":"\tgrpcLvlError\n\tgrpcLvlFatal\n)\n\n// _grpcToZapLevel maps gRPC log levels to zap log levels.\n// See https://pkg.go.dev/go.uber.org/zap@v1.16.0/zapcore#Level\nvar _grpcToZapLevel = map[int]zapcore.Level{\n\tgrpcLvlInfo:  zapcore.InfoLevel,\n\tgrpcLvlWarn:  zapcore.WarnLevel,\n\tgrpcLvlError: zapcore.ErrorLevel,\n\tgrpcLvlFatal: zapcore.FatalLevel,\n}\n\n// An Option overrides a Logger's default configuration.\ntype Option interface {\n\tapply(*Logger)\n}\n\ntype optionFunc func(*Logger)\n"},{"path":"zapgrpc/zapgrpc.go","start_line":58,"end_line":77,"code":"\n// WithDebug configures a Logger to print at zap's DebugLevel instead of\n// InfoLevel.\n// It only affects the Printf, Println and Print methods, which are only used in the gRPC v1 grpclog.Logger API.\n//\n// Deprecated: use grpclog.SetLoggerV2() for v2 API.\nfunc WithDebug() Option {\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.print = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.DebugLevel,\n\t\t\tprint:  logger.delegate.Debug,\n\t\t\tprintf: logger.delegate.Debugf,\n\t\t}\n\t})\n}\n\n// withWarn redirects the fatal level to the warn level, which makes testing\n// easier. This is intentionally unexported.\nfunc withWarn() Option {"}],"selection":{"visibility":"unexported","reason":"other","score":0.42},"call_graph":{"callees":[{"symbol":"WithDebug$1","path":"zapgrpc/zapgrpc.go"},{"symbol":"withWarn$1","path":"zapgrpc/zapgrpc.go"}],"callers":[{"symbol":"(*optionFunc).apply","path":"zapgrpc/zapgrpc.go"},{"symbol":"NewLogger","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"WithDebug","signature":"func WithDebug() Option","start_line":64,"end_line":73,"code":"func WithDebug() Option {\n\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.print = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.DebugLevel,\n\t\t\tprint:  logger.delegate.Debug,\n\t\t\tprintf: logger.delegate.Debugf,\n\t\t}\n\t})\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":44,"end_line":63,"code":"\tgrpcLvlError: zapcore.ErrorLevel,\n\tgrpcLvlFatal: zapcore.FatalLevel,\n}\n\n// An Option overrides a Logger's default configuration.\ntype Option interface {\n\tapply(*Logger)\n}\n\ntype optionFunc func(*Logger)\n\nfunc (f optionFunc) apply(log *Logger) {\n\tf(log)\n}\n\n// WithDebug configures a Logger to print at zap's DebugLevel instead of\n// InfoLevel.\n// It only affects the Printf, Println and Print methods, which are only used in the gRPC v1 grpclog.Logger API.\n//\n// Deprecated: use grpclog.SetLoggerV2() for v2 API."},{"path":"zapgrpc/zapgrpc.go","start_line":74,"end_line":93,"code":"\n// withWarn redirects the fatal level to the warn level, which makes testing\n// easier. This is intentionally unexported.\nfunc withWarn() Option {\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.fatal = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.WarnLevel,\n\t\t\tprint:  logger.delegate.Warn,\n\t\t\tprintf: logger.delegate.Warnf,\n\t\t}\n\t})\n}\n\n// NewLogger returns a new Logger.\nfunc NewLogger(l *zap.Logger, options ...Option) *Logger {\n\tlogger := \u0026Logger{\n\t\tdelegate:     l.Sugar(),\n\t\tlevelEnabler: l.Core(),\n\t}"}],"selection":{"visibility":"exported","reason":"public_api","score":0.85},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"withWarn","signature":"func withWarn() Option","start_line":77,"end_line":86,"code":"func withWarn() Option {\n\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.fatal = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.WarnLevel,\n\t\t\tprint:  logger.delegate.Warn,\n\t\t\tprintf: logger.delegate.Warnf,\n\t\t}\n\t})\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":57,"end_line":76,"code":"}\n\n// WithDebug configures a Logger to print at zap's DebugLevel instead of\n// InfoLevel.\n// It only affects the Printf, Println and Print methods, which are only used in the gRPC v1 grpclog.Logger API.\n//\n// Deprecated: use grpclog.SetLoggerV2() for v2 API.\nfunc WithDebug() Option {\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.print = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.DebugLevel,\n\t\t\tprint:  logger.delegate.Debug,\n\t\t\tprintf: logger.delegate.Debugf,\n\t\t}\n\t})\n}\n\n// withWarn redirects the fatal level to the warn level, which makes testing\n// easier. This is intentionally unexported."},{"path":"zapgrpc/zapgrpc.go","start_line":87,"end_line":106,"code":"\n// NewLogger returns a new Logger.\nfunc NewLogger(l *zap.Logger, options ...Option) *Logger {\n\tlogger := \u0026Logger{\n\t\tdelegate:     l.Sugar(),\n\t\tlevelEnabler: l.Core(),\n\t}\n\tlogger.print = \u0026printer{\n\t\tenab:   logger.levelEnabler,\n\t\tlevel:  zapcore.InfoLevel,\n\t\tprint:  logger.delegate.Info,\n\t\tprintf: logger.delegate.Infof,\n\t}\n\tlogger.fatal = \u0026printer{\n\t\tenab:   logger.levelEnabler,\n\t\tlevel:  zapcore.FatalLevel,\n\t\tprint:  logger.delegate.Fatal,\n\t\tprintf: logger.delegate.Fatalf,\n\t}\n\tfor _, option := range options {"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"NewLogger","signature":"func NewLogger(l *zap.Logger, options ...Option) *Logger","start_line":89,"end_line":110,"code":"func NewLogger(l *zap.Logger, options ...Option) *Logger {\n\n\tlogger := \u0026Logger{\n\t\tdelegate:     l.Sugar(),\n\t\tlevelEnabler: l.Core(),\n\t}\n\tlogger.print = \u0026printer{\n\t\tenab:   logger.levelEnabler,\n\t\tlevel:  zapcore.InfoLevel,\n\t\tprint:  logger.delegate.Info,\n\t\tprintf: logger.delegate.Infof,\n\t}\n\tlogger.fatal = \u0026printer{\n\t\tenab:   logger.levelEnabler,\n\t\tlevel:  zapcore.FatalLevel,\n\t\tprint:  logger.delegate.Fatal,\n\t\tprintf: logger.delegate.Fatalf,\n\t}\n\tfor _, option := range options {\n\t\toption.apply(logger)\n\t}\n\treturn logger\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":69,"end_line":88,"code":"\t\t\tprint:  logger.delegate.Debug,\n\t\t\tprintf: logger.delegate.Debugf,\n\t\t}\n\t})\n}\n\n// withWarn redirects the fatal level to the warn level, which makes testing\n// easier. This is intentionally unexported.\nfunc withWarn() Option {\n\treturn optionFunc(func(logger *Logger) {\n\t\tlogger.fatal = \u0026printer{\n\t\t\tenab:   logger.levelEnabler,\n\t\t\tlevel:  zapcore.WarnLevel,\n\t\t\tprint:  logger.delegate.Warn,\n\t\t\tprintf: logger.delegate.Warnf,\n\t\t}\n\t})\n}\n\n// NewLogger returns a new Logger."},{"path":"zapgrpc/zapgrpc.go","start_line":111,"end_line":130,"code":"\n// printer implements Print, Printf, and Println operations for a Zap level.\n//\n// We use it to customize Debug vs Info, and Warn vs Fatal for Print and Fatal\n// respectively.\ntype printer struct {\n\tenab   zapcore.LevelEnabler\n\tlevel  zapcore.Level\n\tprint  func(...interface{})\n\tprintf func(string, ...interface{})\n}\n\nfunc (v *printer) Print(args ...interface{}) {\n\tv.print(args...)\n}\n\nfunc (v *printer) Printf(format string, args ...interface{}) {\n\tv.printf(format, args...)\n}\n"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(*Logger).Core","path":"logger.go"},{"symbol":"(*Logger).Sugar","path":"logger.go"},{"symbol":"(optionFunc).apply","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*printer).Print","signature":"func (v *printer) Print(args ...interface{})","start_line":123,"end_line":125,"code":"func (v *printer) Print(args ...interface{\n}) {\n\tv.print(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":103,"end_line":122,"code":"\t\tprint:  logger.delegate.Fatal,\n\t\tprintf: logger.delegate.Fatalf,\n\t}\n\tfor _, option := range options {\n\t\toption.apply(logger)\n\t}\n\treturn logger\n}\n\n// printer implements Print, Printf, and Println operations for a Zap level.\n//\n// We use it to customize Debug vs Info, and Warn vs Fatal for Print and Fatal\n// respectively.\ntype printer struct {\n\tenab   zapcore.LevelEnabler\n\tlevel  zapcore.Level\n\tprint  func(...interface{})\n\tprintf func(string, ...interface{})\n}\n"},{"path":"zapgrpc/zapgrpc.go","start_line":126,"end_line":145,"code":"\nfunc (v *printer) Printf(format string, args ...interface{}) {\n\tv.printf(format, args...)\n}\n\nfunc (v *printer) Println(args ...interface{}) {\n\tif v.enab.Enabled(v.level) {\n\t\tv.print(sprintln(args))\n\t}\n}\n\n// Logger adapts zap's Logger to be compatible with grpclog.LoggerV2 and the deprecated grpclog.Logger.\ntype Logger struct {\n\tdelegate     *zap.SugaredLogger\n\tlevelEnabler zapcore.LevelEnabler\n\tprint        *printer\n\tfatal        *printer\n\t// printToDebug bool\n\t// fatalToWarn  bool\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Debug","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatal","path":"sugar.go"},{"symbol":"(*SugaredLogger).Info","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warn","path":"sugar.go"},{"symbol":"Fatal","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Fatalln","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Panic","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Panicln","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Print","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Println","path":"../../../../usr/local/go/src/log/log.go"}],"callers":[{"symbol":"(*Logger).Fatal","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Print","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*printer).Printf","signature":"func (v *printer) Printf(format string, args ...interface{})","start_line":127,"end_line":129,"code":"func (v *printer) Printf(format string, args ...interface{\n}) {\n\tv.printf(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":107,"end_line":126,"code":"\t\toption.apply(logger)\n\t}\n\treturn logger\n}\n\n// printer implements Print, Printf, and Println operations for a Zap level.\n//\n// We use it to customize Debug vs Info, and Warn vs Fatal for Print and Fatal\n// respectively.\ntype printer struct {\n\tenab   zapcore.LevelEnabler\n\tlevel  zapcore.Level\n\tprint  func(...interface{})\n\tprintf func(string, ...interface{})\n}\n\nfunc (v *printer) Print(args ...interface{}) {\n\tv.print(args...)\n}\n"},{"path":"zapgrpc/zapgrpc.go","start_line":130,"end_line":149,"code":"\nfunc (v *printer) Println(args ...interface{}) {\n\tif v.enab.Enabled(v.level) {\n\t\tv.print(sprintln(args))\n\t}\n}\n\n// Logger adapts zap's Logger to be compatible with grpclog.LoggerV2 and the deprecated grpclog.Logger.\ntype Logger struct {\n\tdelegate     *zap.SugaredLogger\n\tlevelEnabler zapcore.LevelEnabler\n\tprint        *printer\n\tfatal        *printer\n\t// printToDebug bool\n\t// fatalToWarn  bool\n}\n\n// Print implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info]."}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Debugf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatalf","path":"sugar.go"},{"symbol":"(*SugaredLogger).Infof","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warnf","path":"sugar.go"},{"symbol":"Fatalf","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Panicf","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Printf","path":"../../../../usr/local/go/src/log/log.go"}],"callers":[{"symbol":"(*Logger).Fatalf","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Printf","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*printer).Println","signature":"func (v *printer) Println(args ...interface{})","start_line":131,"end_line":135,"code":"func (v *printer) Println(args ...interface{\n}) {\n\tif v.enab.Enabled(v.level) {\n\t\tv.print(sprintln(args))\n\t}\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":111,"end_line":130,"code":"\n// printer implements Print, Printf, and Println operations for a Zap level.\n//\n// We use it to customize Debug vs Info, and Warn vs Fatal for Print and Fatal\n// respectively.\ntype printer struct {\n\tenab   zapcore.LevelEnabler\n\tlevel  zapcore.Level\n\tprint  func(...interface{})\n\tprintf func(string, ...interface{})\n}\n\nfunc (v *printer) Print(args ...interface{}) {\n\tv.print(args...)\n}\n\nfunc (v *printer) Printf(format string, args ...interface{}) {\n\tv.printf(format, args...)\n}\n"},{"path":"zapgrpc/zapgrpc.go","start_line":136,"end_line":155,"code":"\n// Logger adapts zap's Logger to be compatible with grpclog.LoggerV2 and the deprecated grpclog.Logger.\ntype Logger struct {\n\tdelegate     *zap.SugaredLogger\n\tlevelEnabler zapcore.LevelEnabler\n\tprint        *printer\n\tfatal        *printer\n\t// printToDebug bool\n\t// fatalToWarn  bool\n}\n\n// Print implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Print(args ...interface{}) {\n\tl.print.Print(args...)\n}\n\n// Printf implements grpclog.Logger.\n//"}],"selection":{"visibility":"exported","reason":"other","score":0.71},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Debug","path":"sugar.go"},{"symbol":"(*SugaredLogger).Fatal","path":"sugar.go"},{"symbol":"(*SugaredLogger).Info","path":"sugar.go"},{"symbol":"(*SugaredLogger).Warn","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"Fatal","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Fatalln","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Panic","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Panicln","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Print","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"Println","path":"../../../../usr/local/go/src/log/log.go"},{"symbol":"sprintln","path":"zapgrpc/zapgrpc.go"}],"callers":[{"symbol":"(*Logger).Fatalln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Print","signature":"func (l *Logger) Print(args ...interface{})","start_line":150,"end_line":152,"code":"func (l *Logger) Print(args ...interface{\n}) {\n\tl.print.Print(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":130,"end_line":149,"code":"\nfunc (v *printer) Println(args ...interface{}) {\n\tif v.enab.Enabled(v.level) {\n\t\tv.print(sprintln(args))\n\t}\n}\n\n// Logger adapts zap's Logger to be compatible with grpclog.LoggerV2 and the deprecated grpclog.Logger.\ntype Logger struct {\n\tdelegate     *zap.SugaredLogger\n\tlevelEnabler zapcore.LevelEnabler\n\tprint        *printer\n\tfatal        *printer\n\t// printToDebug bool\n\t// fatalToWarn  bool\n}\n\n// Print implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info]."},{"path":"zapgrpc/zapgrpc.go","start_line":153,"end_line":172,"code":"\n// Printf implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Infof].\nfunc (l *Logger) Printf(format string, args ...interface{}) {\n\tl.print.Printf(format, args...)\n}\n\n// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Println(args ...interface{}) {\n\tl.print.Println(args...)\n}\n\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Printf","signature":"func (l *Logger) Printf(format string, args ...interface{})","start_line":157,"end_line":159,"code":"func (l *Logger) Printf(format string, args ...interface{\n}) {\n\tl.print.Printf(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":137,"end_line":156,"code":"// Logger adapts zap's Logger to be compatible with grpclog.LoggerV2 and the deprecated grpclog.Logger.\ntype Logger struct {\n\tdelegate     *zap.SugaredLogger\n\tlevelEnabler zapcore.LevelEnabler\n\tprint        *printer\n\tfatal        *printer\n\t// printToDebug bool\n\t// fatalToWarn  bool\n}\n\n// Print implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Print(args ...interface{}) {\n\tl.print.Print(args...)\n}\n\n// Printf implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Infof]."},{"path":"zapgrpc/zapgrpc.go","start_line":160,"end_line":179,"code":"\n// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Println(args ...interface{}) {\n\tl.print.Println(args...)\n}\n\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Println","signature":"func (l *Logger) Println(args ...interface{})","start_line":164,"end_line":166,"code":"func (l *Logger) Println(args ...interface{\n}) {\n\tl.print.Println(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":144,"end_line":163,"code":"\t// fatalToWarn  bool\n}\n\n// Print implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Print(args ...interface{}) {\n\tl.print.Print(args...)\n}\n\n// Printf implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Infof].\nfunc (l *Logger) Printf(format string, args ...interface{}) {\n\tl.print.Printf(format, args...)\n}\n\n// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info]."},{"path":"zapgrpc/zapgrpc.go","start_line":167,"end_line":186,"code":"\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Info","signature":"func (l *Logger) Info(args ...interface{})","start_line":169,"end_line":171,"code":"func (l *Logger) Info(args ...interface{\n}) {\n\tl.delegate.Info(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":149,"end_line":168,"code":"// Deprecated: use [Logger.Info].\nfunc (l *Logger) Print(args ...interface{}) {\n\tl.print.Print(args...)\n}\n\n// Printf implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Infof].\nfunc (l *Logger) Printf(format string, args ...interface{}) {\n\tl.print.Printf(format, args...)\n}\n\n// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Println(args ...interface{}) {\n\tl.print.Println(args...)\n}\n\n// Info implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":172,"end_line":191,"code":"\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Info","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Infoln","signature":"func (l *Logger) Infoln(args ...interface{})","start_line":174,"end_line":178,"code":"func (l *Logger) Infoln(args ...interface{\n}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":154,"end_line":173,"code":"// Printf implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Infof].\nfunc (l *Logger) Printf(format string, args ...interface{}) {\n\tl.print.Printf(format, args...)\n}\n\n// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Println(args ...interface{}) {\n\tl.print.Println(args...)\n}\n\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n\n// Infoln implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":179,"end_line":198,"code":"\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Info","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"sprintln","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Infof","signature":"func (l *Logger) Infof(format string, args ...interface{})","start_line":181,"end_line":183,"code":"func (l *Logger) Infof(format string, args ...interface{\n}) {\n\tl.delegate.Infof(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":161,"end_line":180,"code":"// Println implements grpclog.Logger.\n//\n// Deprecated: use [Logger.Info].\nfunc (l *Logger) Println(args ...interface{}) {\n\tl.print.Println(args...)\n}\n\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n\n// Infof implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":184,"end_line":203,"code":"\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Infof","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Warning","signature":"func (l *Logger) Warning(args ...interface{})","start_line":186,"end_line":188,"code":"func (l *Logger) Warning(args ...interface{\n}) {\n\tl.delegate.Warn(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":166,"end_line":185,"code":"}\n\n// Info implements grpclog.LoggerV2.\nfunc (l *Logger) Info(args ...interface{}) {\n\tl.delegate.Info(args...)\n}\n\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":189,"end_line":208,"code":"\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Warn","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Warningln","signature":"func (l *Logger) Warningln(args ...interface{})","start_line":191,"end_line":195,"code":"func (l *Logger) Warningln(args ...interface{\n}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":171,"end_line":190,"code":"}\n\n// Infoln implements grpclog.LoggerV2.\nfunc (l *Logger) Infoln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.InfoLevel) {\n\t\tl.delegate.Info(sprintln(args))\n\t}\n}\n\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":196,"end_line":215,"code":"\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Warn","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"sprintln","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Warningf","signature":"func (l *Logger) Warningf(format string, args ...interface{})","start_line":198,"end_line":200,"code":"func (l *Logger) Warningf(format string, args ...interface{\n}) {\n\tl.delegate.Warnf(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":178,"end_line":197,"code":"}\n\n// Infof implements grpclog.LoggerV2.\nfunc (l *Logger) Infof(format string, args ...interface{}) {\n\tl.delegate.Infof(format, args...)\n}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":201,"end_line":220,"code":"\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Warnf","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Error","signature":"func (l *Logger) Error(args ...interface{})","start_line":203,"end_line":205,"code":"func (l *Logger) Error(args ...interface{\n}) {\n\tl.delegate.Error(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":183,"end_line":202,"code":"}\n\n// Warning implements grpclog.LoggerV2.\nfunc (l *Logger) Warning(args ...interface{}) {\n\tl.delegate.Warn(args...)\n}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":206,"end_line":225,"code":"\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {"}],"selection":{"visibility":"exported","reason":"other","score":0.64},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Error","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Errorln","signature":"func (l *Logger) Errorln(args ...interface{})","start_line":208,"end_line":212,"code":"func (l *Logger) Errorln(args ...interface{\n}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":188,"end_line":207,"code":"}\n\n// Warningln implements grpclog.LoggerV2.\nfunc (l *Logger) Warningln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.WarnLevel) {\n\t\tl.delegate.Warn(sprintln(args))\n\t}\n}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":213,"end_line":232,"code":"\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Error","path":"sugar.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"},{"symbol":"sprintln","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Errorf","signature":"func (l *Logger) Errorf(format string, args ...interface{})","start_line":215,"end_line":217,"code":"func (l *Logger) Errorf(format string, args ...interface{\n}) {\n\tl.delegate.Errorf(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":195,"end_line":214,"code":"}\n\n// Warningf implements grpclog.LoggerV2.\nfunc (l *Logger) Warningf(format string, args ...interface{}) {\n\tl.delegate.Warnf(format, args...)\n}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":218,"end_line":237,"code":"\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}\n\n// V implements grpclog.LoggerV2.\nfunc (l *Logger) V(level int) bool {\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.69},"call_graph":{"callees":[{"symbol":"(*SugaredLogger).Errorf","path":"sugar.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Fatal","signature":"func (l *Logger) Fatal(args ...interface{})","start_line":220,"end_line":222,"code":"func (l *Logger) Fatal(args ...interface{\n}) {\n\tl.fatal.Print(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":200,"end_line":219,"code":"}\n\n// Error implements grpclog.LoggerV2.\nfunc (l *Logger) Error(args ...interface{}) {\n\tl.delegate.Error(args...)\n}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":223,"end_line":242,"code":"\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}\n\n// V implements grpclog.LoggerV2.\nfunc (l *Logger) V(level int) bool {\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}\n\nfunc sprintln(args []interface{}) string {\n\ts := fmt.Sprintln(args...)\n\t// Drop the new line character added by Sprintln\n\treturn s[:len(s)-1]"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*printer).Print","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Fatalln","signature":"func (l *Logger) Fatalln(args ...interface{})","start_line":225,"end_line":227,"code":"func (l *Logger) Fatalln(args ...interface{\n}) {\n\tl.fatal.Println(args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":205,"end_line":224,"code":"}\n\n// Errorln implements grpclog.LoggerV2.\nfunc (l *Logger) Errorln(args ...interface{}) {\n\tif l.levelEnabler.Enabled(zapcore.ErrorLevel) {\n\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":228,"end_line":244,"code":"\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}\n\n// V implements grpclog.LoggerV2.\nfunc (l *Logger) V(level int) bool {\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}\n\nfunc sprintln(args []interface{}) string {\n\ts := fmt.Sprintln(args...)\n\t// Drop the new line character added by Sprintln\n\treturn s[:len(s)-1]\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).Fatalf","signature":"func (l *Logger) Fatalf(format string, args ...interface{})","start_line":230,"end_line":232,"code":"func (l *Logger) Fatalf(format string, args ...interface{\n}) {\n\tl.fatal.Printf(format, args...)\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":210,"end_line":229,"code":"\t\tl.delegate.Error(sprintln(args))\n\t}\n}\n\n// Errorf implements grpclog.LoggerV2.\nfunc (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":233,"end_line":244,"code":"\n// V implements grpclog.LoggerV2.\nfunc (l *Logger) V(level int) bool {\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}\n\nfunc sprintln(args []interface{}) string {\n\ts := fmt.Sprintln(args...)\n\t// Drop the new line character added by Sprintln\n\treturn s[:len(s)-1]\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*printer).Printf","path":"zapgrpc/zapgrpc.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"(*Logger).V","signature":"func (l *Logger) V(level int) bool","start_line":235,"end_line":237,"code":"func (l *Logger) V(level int) bool {\n\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":215,"end_line":234,"code":"func (l *Logger) Errorf(format string, args ...interface{}) {\n\tl.delegate.Errorf(format, args...)\n}\n\n// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}\n\n// V implements grpclog.LoggerV2."},{"path":"zapgrpc/zapgrpc.go","start_line":238,"end_line":244,"code":"\nfunc sprintln(args []interface{}) string {\n\ts := fmt.Sprintln(args...)\n\t// Drop the new line character added by Sprintln\n\treturn s[:len(s)-1]\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapgrpc/zapgrpc.go","symbol":"sprintln","signature":"func sprintln(args []interface{}) string","start_line":239,"end_line":243,"code":"func sprintln(args []interface{\n}) string {\n\ts := fmt.Sprintln(args...)\n\t\n\treturn s[:len(s)-1]\n}\n","neighbors":[{"path":"zapgrpc/zapgrpc.go","start_line":219,"end_line":238,"code":"// Fatal implements grpclog.LoggerV2.\nfunc (l *Logger) Fatal(args ...interface{}) {\n\tl.fatal.Print(args...)\n}\n\n// Fatalln implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalln(args ...interface{}) {\n\tl.fatal.Println(args...)\n}\n\n// Fatalf implements grpclog.LoggerV2.\nfunc (l *Logger) Fatalf(format string, args ...interface{}) {\n\tl.fatal.Printf(format, args...)\n}\n\n// V implements grpclog.LoggerV2.\nfunc (l *Logger) V(level int) bool {\n\treturn l.levelEnabler.Enabled(_grpcToZapLevel[level])\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.52},"call_graph":{"callees":[{"symbol":"Sprintln","path":"../../../../usr/local/go/src/fmt/print.go"}],"callers":[{"symbol":"(*Logger).Errorln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Infoln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*Logger).Warningln","path":"zapgrpc/zapgrpc.go"},{"symbol":"(*printer).Println","path":"zapgrpc/zapgrpc.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).Write","signature":"func (w *Writer) Write(bs []byte) (n int, err error)","start_line":75,"end_line":87,"code":"func (w *Writer) Write(bs []byte) (n int, err error) {\n\n\t\n\tif !w.Log.Core().Enabled(w.Level) {\n\t\treturn len(bs), nil\n\t}\n\n\tn = len(bs)\n\tfor len(bs) \u003e 0 {\n\t\tbs = w.writeLine(bs)\n\t}\n\n\treturn n, nil\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":55,"end_line":74,"code":"\tLog *zap.Logger\n\n\t// Log level for the messages written to the provided logger.\n\t//\n\t// If unspecified, defaults to Info.\n\tLevel zapcore.Level\n\n\tbuff bytes.Buffer\n}\n\nvar (\n\t_ zapcore.WriteSyncer = (*Writer)(nil)\n\t_ io.Closer           = (*Writer)(nil)\n)\n\n// Write writes the provided bytes to the underlying logger at the configured\n// log level and returns the length of the bytes.\n//\n// Write will split the input on newlines and post each line as a new log entry\n// to the logger."},{"path":"zapio/writer.go","start_line":88,"end_line":107,"code":"\n// writeLine writes a single line from the input, returning the remaining,\n// unconsumed bytes.\nfunc (w *Writer) writeLine(line []byte) (remaining []byte) {\n\tidx := bytes.IndexByte(line, '\\n')\n\tif idx \u003c 0 {\n\t\t// If there are no newlines, buffer the entire string.\n\t\tw.buff.Write(line)\n\t\treturn nil\n\t}\n\n\t// Split on the newline, buffer and flush the left.\n\tline, remaining = line[:idx], line[idx+1:]\n\n\t// Fast path: if we don't have a partial message from a previous write\n\t// in the buffer, skip the buffer and log directly.\n\tif w.buff.Len() == 0 {\n\t\tw.log(line)\n\t\treturn\n\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.8},"call_graph":{"callees":[{"symbol":"(*Logger).Core","path":"logger.go"},{"symbol":"(*Writer).writeLine","path":"zapio/writer.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Fprint","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"copyBuffer","path":"../../../../usr/local/go/src/io/io.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"},{"symbol":"writePrefixLine","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).writeLine","signature":"func (w *Writer) writeLine(line []byte) (remaining []byte)","start_line":91,"end_line":116,"code":"func (w *Writer) writeLine(line []byte) (remaining []byte) {\n\n\tidx := bytes.IndexByte(line, '\\n')\n\tif idx \u003c 0 {\n\t\t\n\t\tw.buff.Write(line)\n\t\treturn nil\n\t}\n\n\t\n\tline, remaining = line[:idx], line[idx+1:]\n\n\t\n\t\n\tif w.buff.Len() == 0 {\n\t\tw.log(line)\n\t\treturn\n\t}\n\n\tw.buff.Write(line)\n\n\t\n\t\n\tw.flush(true )\n\n\treturn remaining\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":71,"end_line":90,"code":"// log level and returns the length of the bytes.\n//\n// Write will split the input on newlines and post each line as a new log entry\n// to the logger.\nfunc (w *Writer) Write(bs []byte) (n int, err error) {\n\t// Skip all checks if the level isn't enabled.\n\tif !w.Log.Core().Enabled(w.Level) {\n\t\treturn len(bs), nil\n\t}\n\n\tn = len(bs)\n\tfor len(bs) \u003e 0 {\n\t\tbs = w.writeLine(bs)\n\t}\n\n\treturn n, nil\n}\n\n// writeLine writes a single line from the input, returning the remaining,\n// unconsumed bytes."},{"path":"zapio/writer.go","start_line":117,"end_line":136,"code":"\n// Close closes the writer, flushing any buffered data in the process.\n//\n// Always call Close once you're done with the Writer to ensure that it flushes\n// all data.\nfunc (w *Writer) Close() error {\n\treturn w.Sync()\n}\n\n// Sync flushes buffered data to the logger as a new log entry even if it\n// doesn't contain a newline.\nfunc (w *Writer) Sync() error {\n\t// Don't allow empty messages on explicit Sync calls or on Close\n\t// because we don't want an extraneous empty message at the end of the\n\t// stream -- it's common for files to end with a newline.\n\tw.flush(false /* allowEmpty */)\n\treturn nil\n}\n\n// flush flushes the buffered data to the logger, allowing empty messages only"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*Buffer).Len","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*Buffer).Write","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*Writer).flush","path":"zapio/writer.go"},{"symbol":"(*Writer).log","path":"zapio/writer.go"},{"symbol":"IndexByte","path":"../../../../usr/local/go/src/bytes/bytes.go"}],"callers":[{"symbol":"(*Writer).Write","path":"zapio/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).Close","signature":"func (w *Writer) Close() error","start_line":122,"end_line":124,"code":"func (w *Writer) Close() error {\n\n\treturn w.Sync()\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":102,"end_line":121,"code":"\t// Fast path: if we don't have a partial message from a previous write\n\t// in the buffer, skip the buffer and log directly.\n\tif w.buff.Len() == 0 {\n\t\tw.log(line)\n\t\treturn\n\t}\n\n\tw.buff.Write(line)\n\n\t// Log empty messages in the middle of the stream so that we don't lose\n\t// information when the user writes \"foo\\n\\nbar\".\n\tw.flush(true /* allowEmpty */)\n\n\treturn remaining\n}\n\n// Close closes the writer, flushing any buffered data in the process.\n//\n// Always call Close once you're done with the Writer to ensure that it flushes\n// all data."},{"path":"zapio/writer.go","start_line":125,"end_line":144,"code":"\n// Sync flushes buffered data to the logger as a new log entry even if it\n// doesn't contain a newline.\nfunc (w *Writer) Sync() error {\n\t// Don't allow empty messages on explicit Sync calls or on Close\n\t// because we don't want an extraneous empty message at the end of the\n\t// stream -- it's common for files to end with a newline.\n\tw.flush(false /* allowEmpty */)\n\treturn nil\n}\n\n// flush flushes the buffered data to the logger, allowing empty messages only\n// if the bool is set.\nfunc (w *Writer) flush(allowEmpty bool) {\n\tif allowEmpty || w.buff.Len() \u003e 0 {\n\t\tw.log(w.buff.Bytes())\n\t}\n\tw.buff.Reset()\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*Writer).Sync","path":"zapio/writer.go"}],"callers":[{"symbol":"(*Client).do","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*Reader).Close","path":"../../../../usr/local/go/src/compress/gzip/gunzip.go"},{"symbol":"(*Request).closeBody","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*Response).closeBody","path":"../../../../usr/local/go/src/net/http/response.go"},{"symbol":"(*bodyEOFSignal).Close","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*cancelTimerBody).Close","path":"../../../../usr/local/go/src/net/http/client.go"},{"symbol":"(*chunkWriter).writeHeader","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*expectContinueReader).Close","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*http2clientStream).cleanupWriteRequest","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*http2gzipReader).Close","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*maxBytesReader).Close","path":"../../../../usr/local/go/src/net/http/request.go"},{"symbol":"(*readTrackingBody).Close","path":"../../../../usr/local/go/src/net/http/transport.go"},{"symbol":"(*response).finishRequest","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"(*transferWriter).writeBody","path":"../../../../usr/local/go/src/net/http/transfer.go"},{"symbol":"(Invoke).Invoke","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(StreamWriter).Close","path":"../../../../usr/local/go/src/crypto/cipher/io.go"},{"symbol":"(WordEncoder).bEncode","path":"../../../../usr/local/go/src/mime/encodedword.go"},{"symbol":"(sectionReadCloser).Close","path":"../../../../usr/local/go/src/mime/multipart/formdata.go"},{"symbol":"CAST","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Encode","path":"../../../../usr/local/go/src/encoding/pem/pem.go"},{"symbol":"PCT","path":"../../../../usr/local/go/src/crypto/internal/fips140/cast.go"},{"symbol":"closeDescriptors","path":"../../../../usr/local/go/src/os/exec/exec.go"},{"symbol":"closeReqBodyLocked$1","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"ignoringEINTR","path":"../../../../usr/local/go/src/internal/poll/fd_posix.go"},{"symbol":"ignoringEINTR","path":"../../../../usr/local/go/src/os/file_posix.go"},{"symbol":"open$1","path":"writer.go"},{"symbol":"roundTrip$2","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"serve$1","path":"../../../../usr/local/go/src/net/http/server.go"},{"symbol":"writeBody$1","path":"../../../../usr/local/go/src/net/http/transfer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).Sync","signature":"func (w *Writer) Sync() error","start_line":128,"end_line":134,"code":"func (w *Writer) Sync() error {\n\n\t\n\t\n\t\n\tw.flush(false )\n\treturn nil\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":108,"end_line":127,"code":"\n\tw.buff.Write(line)\n\n\t// Log empty messages in the middle of the stream so that we don't lose\n\t// information when the user writes \"foo\\n\\nbar\".\n\tw.flush(true /* allowEmpty */)\n\n\treturn remaining\n}\n\n// Close closes the writer, flushing any buffered data in the process.\n//\n// Always call Close once you're done with the Writer to ensure that it flushes\n// all data.\nfunc (w *Writer) Close() error {\n\treturn w.Sync()\n}\n\n// Sync flushes buffered data to the logger as a new log entry even if it\n// doesn't contain a newline."},{"path":"zapio/writer.go","start_line":135,"end_line":150,"code":"\n// flush flushes the buffered data to the logger, allowing empty messages only\n// if the bool is set.\nfunc (w *Writer) flush(allowEmpty bool) {\n\tif allowEmpty || w.buff.Len() \u003e 0 {\n\t\tw.log(w.buff.Bytes())\n\t}\n\tw.buff.Reset()\n}\n\nfunc (w *Writer) log(b []byte) {\n\tif ce := w.Log.Check(w.Level, string(b)); ce != nil {\n\t\tce.Write()\n\t}\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.76},"call_graph":{"callees":[{"symbol":"(*Writer).flush","path":"zapio/writer.go"}],"callers":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*Writer).Close","path":"zapio/writer.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).flush","signature":"func (w *Writer) flush(allowEmpty bool)","start_line":138,"end_line":143,"code":"func (w *Writer) flush(allowEmpty bool) {\n\n\tif allowEmpty || w.buff.Len() \u003e 0 {\n\t\tw.log(w.buff.Bytes())\n\t}\n\tw.buff.Reset()\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":118,"end_line":137,"code":"// Close closes the writer, flushing any buffered data in the process.\n//\n// Always call Close once you're done with the Writer to ensure that it flushes\n// all data.\nfunc (w *Writer) Close() error {\n\treturn w.Sync()\n}\n\n// Sync flushes buffered data to the logger as a new log entry even if it\n// doesn't contain a newline.\nfunc (w *Writer) Sync() error {\n\t// Don't allow empty messages on explicit Sync calls or on Close\n\t// because we don't want an extraneous empty message at the end of the\n\t// stream -- it's common for files to end with a newline.\n\tw.flush(false /* allowEmpty */)\n\treturn nil\n}\n\n// flush flushes the buffered data to the logger, allowing empty messages only\n// if the bool is set."},{"path":"zapio/writer.go","start_line":144,"end_line":150,"code":"\nfunc (w *Writer) log(b []byte) {\n\tif ce := w.Log.Check(w.Level, string(b)); ce != nil {\n\t\tce.Write()\n\t}\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.51},"call_graph":{"callees":[{"symbol":"(*Buffer).Bytes","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*Buffer).Len","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*Buffer).Reset","path":"../../../../usr/local/go/src/bytes/buffer.go"},{"symbol":"(*Writer).log","path":"zapio/writer.go"}],"callers":[{"symbol":"(*Writer).Sync","path":"zapio/writer.go"},{"symbol":"(*Writer).writeLine","path":"zapio/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zapio/writer.go","symbol":"(*Writer).log","signature":"func (w *Writer) log(b []byte)","start_line":145,"end_line":149,"code":"func (w *Writer) log(b []byte) {\n\n\tif ce := w.Log.Check(w.Level, string(b)); ce != nil {\n\t\tce.Write()\n\t}\n}\n","neighbors":[{"path":"zapio/writer.go","start_line":125,"end_line":144,"code":"\n// Sync flushes buffered data to the logger as a new log entry even if it\n// doesn't contain a newline.\nfunc (w *Writer) Sync() error {\n\t// Don't allow empty messages on explicit Sync calls or on Close\n\t// because we don't want an extraneous empty message at the end of the\n\t// stream -- it's common for files to end with a newline.\n\tw.flush(false /* allowEmpty */)\n\treturn nil\n}\n\n// flush flushes the buffered data to the logger, allowing empty messages only\n// if the bool is set.\nfunc (w *Writer) flush(allowEmpty bool) {\n\tif allowEmpty || w.buff.Len() \u003e 0 {\n\t\tw.log(w.buff.Bytes())\n\t}\n\tw.buff.Reset()\n}\n"}],"selection":{"visibility":"unexported","reason":"other","score":0.6},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).Check","path":"logger.go"}],"callers":[{"symbol":"(*Writer).flush","path":"zapio/writer.go"},{"symbol":"(*Writer).writeLine","path":"zapio/writer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"(loggerOptionFunc).applyLoggerOption","signature":"func (f loggerOptionFunc) applyLoggerOption(opts *loggerOptions)","start_line":42,"end_line":44,"code":"func (f loggerOptionFunc) applyLoggerOption(opts *loggerOptions) {\n\n\tf(opts)\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":22,"end_line":41,"code":"\nimport (\n\t\"bytes\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// LoggerOption configures the test logger built by NewLogger.\ntype LoggerOption interface {\n\tapplyLoggerOption(*loggerOptions)\n}\n\ntype loggerOptions struct {\n\tLevel      zapcore.LevelEnabler\n\tzapOptions []zap.Option\n}\n\ntype loggerOptionFunc func(*loggerOptions)\n"},{"path":"zaptest/logger.go","start_line":45,"end_line":64,"code":"\n// Level controls which messages are logged by a test Logger built by\n// NewLogger.\nfunc Level(enab zapcore.LevelEnabler) LoggerOption {\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.Level = enab\n\t})\n}\n\n// WrapOptions adds zap.Option's to a test Logger built by NewLogger.\nfunc WrapOptions(zapOpts ...zap.Option) LoggerOption {\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.zapOptions = zapOpts\n\t})\n}\n\n// NewLogger builds a new Logger that logs all messages to the given\n// testing.TB.\n//\n//\tlogger := zaptest.NewLogger(t)"}],"selection":{"visibility":"unexported","reason":"other","score":0.4},"call_graph":{"callees":[{"symbol":"Level$1","path":"zaptest/logger.go"},{"symbol":"WrapOptions$1","path":"zaptest/logger.go"}],"callers":[{"symbol":"(*loggerOptionFunc).applyLoggerOption","path":"zaptest/logger.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"Level","signature":"func Level(enab zapcore.LevelEnabler) LoggerOption","start_line":48,"end_line":52,"code":"func Level(enab zapcore.LevelEnabler) LoggerOption {\n\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.Level = enab\n\t})\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":28,"end_line":47,"code":")\n\n// LoggerOption configures the test logger built by NewLogger.\ntype LoggerOption interface {\n\tapplyLoggerOption(*loggerOptions)\n}\n\ntype loggerOptions struct {\n\tLevel      zapcore.LevelEnabler\n\tzapOptions []zap.Option\n}\n\ntype loggerOptionFunc func(*loggerOptions)\n\nfunc (f loggerOptionFunc) applyLoggerOption(opts *loggerOptions) {\n\tf(opts)\n}\n\n// Level controls which messages are logged by a test Logger built by\n// NewLogger."},{"path":"zaptest/logger.go","start_line":53,"end_line":72,"code":"\n// WrapOptions adds zap.Option's to a test Logger built by NewLogger.\nfunc WrapOptions(zapOpts ...zap.Option) LoggerOption {\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.zapOptions = zapOpts\n\t})\n}\n\n// NewLogger builds a new Logger that logs all messages to the given\n// testing.TB.\n//\n//\tlogger := zaptest.NewLogger(t)\n//\n// Use this with a *testing.T or *testing.B to get logs which get printed only\n// if a test fails or if you ran go test -v.\n//\n// The returned logger defaults to logging debug level messages and above.\n// This may be changed by passing a zaptest.Level during construction.\n//\n//\tlogger := zaptest.NewLogger(t, zaptest.Level(zap.WarnLevel))"}],"selection":{"visibility":"exported","reason":"other","score":0.73},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"WrapOptions","signature":"func WrapOptions(zapOpts ...zap.Option) LoggerOption","start_line":55,"end_line":59,"code":"func WrapOptions(zapOpts ...zap.Option) LoggerOption {\n\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.zapOptions = zapOpts\n\t})\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":35,"end_line":54,"code":"type loggerOptions struct {\n\tLevel      zapcore.LevelEnabler\n\tzapOptions []zap.Option\n}\n\ntype loggerOptionFunc func(*loggerOptions)\n\nfunc (f loggerOptionFunc) applyLoggerOption(opts *loggerOptions) {\n\tf(opts)\n}\n\n// Level controls which messages are logged by a test Logger built by\n// NewLogger.\nfunc Level(enab zapcore.LevelEnabler) LoggerOption {\n\treturn loggerOptionFunc(func(opts *loggerOptions) {\n\t\topts.Level = enab\n\t})\n}\n\n// WrapOptions adds zap.Option's to a test Logger built by NewLogger."},{"path":"zaptest/logger.go","start_line":60,"end_line":79,"code":"\n// NewLogger builds a new Logger that logs all messages to the given\n// testing.TB.\n//\n//\tlogger := zaptest.NewLogger(t)\n//\n// Use this with a *testing.T or *testing.B to get logs which get printed only\n// if a test fails or if you ran go test -v.\n//\n// The returned logger defaults to logging debug level messages and above.\n// This may be changed by passing a zaptest.Level during construction.\n//\n//\tlogger := zaptest.NewLogger(t, zaptest.Level(zap.WarnLevel))\n//\n// You may also pass zap.Option's to customize test logger.\n//\n//\tlogger := zaptest.NewLogger(t, zaptest.WrapOptions(zap.AddCaller()))\nfunc NewLogger(t TestingT, opts ...LoggerOption) *zap.Logger {\n\tcfg := loggerOptions{\n\t\tLevel: zapcore.DebugLevel,"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"NewLogger","signature":"func NewLogger(t TestingT, opts ...LoggerOption) *zap.Logger","start_line":77,"end_line":101,"code":"func NewLogger(t TestingT, opts ...LoggerOption) *zap.Logger {\n\n\tcfg := loggerOptions{\n\t\tLevel: zapcore.DebugLevel,\n\t}\n\tfor _, o := range opts {\n\t\to.applyLoggerOption(\u0026cfg)\n\t}\n\n\twriter := NewTestingWriter(t)\n\tzapOptions := []zap.Option{\n\t\t\n\t\t\n\t\tzap.ErrorOutput(writer.WithMarkFailed(true)),\n\t}\n\tzapOptions = append(zapOptions, cfg.zapOptions...)\n\n\treturn zap.New(\n\t\tzapcore.NewCore(\n\t\t\tzapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig()),\n\t\t\twriter,\n\t\t\tcfg.Level,\n\t\t),\n\t\tzapOptions...,\n\t)\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":57,"end_line":76,"code":"\t\topts.zapOptions = zapOpts\n\t})\n}\n\n// NewLogger builds a new Logger that logs all messages to the given\n// testing.TB.\n//\n//\tlogger := zaptest.NewLogger(t)\n//\n// Use this with a *testing.T or *testing.B to get logs which get printed only\n// if a test fails or if you ran go test -v.\n//\n// The returned logger defaults to logging debug level messages and above.\n// This may be changed by passing a zaptest.Level during construction.\n//\n//\tlogger := zaptest.NewLogger(t, zaptest.Level(zap.WarnLevel))\n//\n// You may also pass zap.Option's to customize test logger.\n//\n//\tlogger := zaptest.NewLogger(t, zaptest.WrapOptions(zap.AddCaller()))"},{"path":"zaptest/logger.go","start_line":102,"end_line":121,"code":"\n// TestingWriter is a WriteSyncer that writes to the given testing.TB.\ntype TestingWriter struct {\n\tt TestingT\n\n\t// If true, the test will be marked as failed if this TestingWriter is\n\t// ever used.\n\tmarkFailed bool\n}\n\n// NewTestingWriter builds a new TestingWriter that writes to the given\n// testing.TB.\n//\n// Use this if you need more flexibility when creating *zap.Logger\n// than zaptest.NewLogger() provides.\n//\n// E.g., if you want to use custom core with zaptest.TestingWriter:\n//\n//\tencoder := newCustomEncoder()\n//\twriter := zaptest.NewTestingWriter(t)"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":[{"symbol":"(TestingWriter).WithMarkFailed","path":"zaptest/logger.go"},{"symbol":"(loggerOptionFunc).applyLoggerOption","path":"zaptest/logger.go"},{"symbol":"ErrorOutput","path":"options.go"},{"symbol":"New","path":"logger.go"},{"symbol":"NewConsoleEncoder","path":"zapcore/console_encoder.go"},{"symbol":"NewCore","path":"zapcore/core.go"},{"symbol":"NewDevelopmentEncoderConfig","path":"config.go"},{"symbol":"NewTestingWriter","path":"zaptest/logger.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"NewTestingWriter","signature":"func NewTestingWriter(t TestingT) TestingWriter","start_line":127,"end_line":129,"code":"func NewTestingWriter(t TestingT) TestingWriter {\n\n\treturn TestingWriter{t: t}\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":107,"end_line":126,"code":"\t// If true, the test will be marked as failed if this TestingWriter is\n\t// ever used.\n\tmarkFailed bool\n}\n\n// NewTestingWriter builds a new TestingWriter that writes to the given\n// testing.TB.\n//\n// Use this if you need more flexibility when creating *zap.Logger\n// than zaptest.NewLogger() provides.\n//\n// E.g., if you want to use custom core with zaptest.TestingWriter:\n//\n//\tencoder := newCustomEncoder()\n//\twriter := zaptest.NewTestingWriter(t)\n//\tlevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)\n//\n//\tcore := newCustomCore(encoder, writer, level)\n//\n//\tlogger := zap.New(core, zap.AddCaller())"},{"path":"zaptest/logger.go","start_line":130,"end_line":149,"code":"\n// WithMarkFailed returns a copy of this TestingWriter with markFailed set to\n// the provided value.\nfunc (w TestingWriter) WithMarkFailed(v bool) TestingWriter {\n\tw.markFailed = v\n\treturn w\n}\n\n// Write writes bytes from p to the underlying testing.TB.\nfunc (w TestingWriter) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\n\t// Strip trailing newline because t.Log always adds one.\n\tp = bytes.TrimRight(p, \"\\n\")\n\n\t// Note: t.Log is safe for concurrent use.\n\tw.t.Logf(\"%s\", p)\n\tif w.markFailed {\n\t\tw.t.Fail()\n\t}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.75},"call_graph":{"callees":null,"callers":[{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"(TestingWriter).WithMarkFailed","signature":"func (w TestingWriter) WithMarkFailed(v bool) TestingWriter","start_line":133,"end_line":136,"code":"func (w TestingWriter) WithMarkFailed(v bool) TestingWriter {\n\n\tw.markFailed = v\n\treturn w\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":113,"end_line":132,"code":"// testing.TB.\n//\n// Use this if you need more flexibility when creating *zap.Logger\n// than zaptest.NewLogger() provides.\n//\n// E.g., if you want to use custom core with zaptest.TestingWriter:\n//\n//\tencoder := newCustomEncoder()\n//\twriter := zaptest.NewTestingWriter(t)\n//\tlevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)\n//\n//\tcore := newCustomCore(encoder, writer, level)\n//\n//\tlogger := zap.New(core, zap.AddCaller())\nfunc NewTestingWriter(t TestingT) TestingWriter {\n\treturn TestingWriter{t: t}\n}\n\n// WithMarkFailed returns a copy of this TestingWriter with markFailed set to\n// the provided value."},{"path":"zaptest/logger.go","start_line":137,"end_line":156,"code":"\n// Write writes bytes from p to the underlying testing.TB.\nfunc (w TestingWriter) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\n\t// Strip trailing newline because t.Log always adds one.\n\tp = bytes.TrimRight(p, \"\\n\")\n\n\t// Note: t.Log is safe for concurrent use.\n\tw.t.Logf(\"%s\", p)\n\tif w.markFailed {\n\t\tw.t.Fail()\n\t}\n\n\treturn n, nil\n}\n\n// Sync commits the current contents (a no-op for TestingWriter).\nfunc (w TestingWriter) Sync() error {\n\treturn nil"}],"selection":{"visibility":"exported","reason":"public_api","score":0.75},"call_graph":{"callees":null,"callers":[{"symbol":"(*TestingWriter).WithMarkFailed","path":"zaptest/logger.go"},{"symbol":"NewLogger","path":"zaptest/logger.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"(TestingWriter).Write","signature":"func (w TestingWriter) Write(p []byte) (n int, err error)","start_line":139,"end_line":152,"code":"func (w TestingWriter) Write(p []byte) (n int, err error) {\n\n\tn = len(p)\n\n\t\n\tp = bytes.TrimRight(p, \"\\n\")\n\n\t\n\tw.t.Logf(\"%s\", p)\n\tif w.markFailed {\n\t\tw.t.Fail()\n\t}\n\n\treturn n, nil\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":119,"end_line":138,"code":"//\n//\tencoder := newCustomEncoder()\n//\twriter := zaptest.NewTestingWriter(t)\n//\tlevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)\n//\n//\tcore := newCustomCore(encoder, writer, level)\n//\n//\tlogger := zap.New(core, zap.AddCaller())\nfunc NewTestingWriter(t TestingT) TestingWriter {\n\treturn TestingWriter{t: t}\n}\n\n// WithMarkFailed returns a copy of this TestingWriter with markFailed set to\n// the provided value.\nfunc (w TestingWriter) WithMarkFailed(v bool) TestingWriter {\n\tw.markFailed = v\n\treturn w\n}\n\n// Write writes bytes from p to the underlying testing.TB."},{"path":"zaptest/logger.go","start_line":153,"end_line":158,"code":"\n// Sync commits the current contents (a no-op for TestingWriter).\nfunc (w TestingWriter) Sync() error {\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.8},"call_graph":{"callees":[{"symbol":"TrimRight","path":"../../../../usr/local/go/src/bytes/bytes.go"}],"callers":[{"symbol":"(*Buffers).WriteTo","path":"../../../../usr/local/go/src/net/net.go"},{"symbol":"(*Config).writeKeyLog","path":"../../../../usr/local/go/src/crypto/tls/common.go"},{"symbol":"(*Conn).unmarshalHandshakeMessage","path":"../../../../usr/local/go/src/crypto/tls/conn.go"},{"symbol":"(*Encoder).Encode","path":"../../../../usr/local/go/src/encoding/json/stream.go"},{"symbol":"(*Encoder).WriteField","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/encode.go"},{"symbol":"(*TestingWriter).Write","path":"zaptest/logger.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).Close","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/transform/transform.go"},{"symbol":"(*Writer).Flush","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/bufio/bufio.go"},{"symbol":"(*Writer).Write","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*Writer).WriteField","path":"../../../../usr/local/go/src/mime/multipart/writer.go"},{"symbol":"(*Writer).writeBytes","path":"../../../../usr/local/go/src/compress/gzip/gzip.go"},{"symbol":"(*byteStringReplacer).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"(*dumper).Write","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"(*encoder).Close","path":"../../../../usr/local/go/src/encoding/base64/base64.go"},{"symbol":"(*http2Framer).endWrite","path":"../../../../usr/local/go/src/net/http/h2_bundle.go"},{"symbol":"(*huffmanBitWriter).write","path":"../../../../usr/local/go/src/compress/flate/huffman_bit_writer.go"},{"symbol":"(*multiError).writeSingleline","path":"../../go/pkg/mod/go.uber.org/multierr@v1.10.0/error.go"},{"symbol":"(*multiWriter).Write","path":"../../../../usr/local/go/src/io/multi.go"},{"symbol":"(*normWriter).Write","path":"../../../../usr/local/go/src/vendor/golang.org/x/text/unicode/norm/readwriter.go"},{"symbol":"(*state).walk","path":"../../../../usr/local/go/src/text/template/exec.go"},{"symbol":"(stringWriter).WriteString","path":"../../../../usr/local/go/src/strings/replace.go"},{"symbol":"Dump","path":"../../../../usr/local/go/src/encoding/hex/hex.go"},{"symbol":"Fprintf","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"Fprintln","path":"../../../../usr/local/go/src/fmt/print.go"},{"symbol":"HuffmanDecode","path":"../../../../usr/local/go/src/vendor/golang.org/x/net/http2/hpack/huffman.go"},{"symbol":"Write","path":"../../../../usr/local/go/src/encoding/binary/binary.go"},{"symbol":"printStack","path":"../../../../usr/local/go/src/internal/bisect/bisect.go"},{"symbol":"transcriptMsg","path":"../../../../usr/local/go/src/crypto/tls/handshake_messages.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/logger.go","symbol":"(TestingWriter).Sync","signature":"func (w TestingWriter) Sync() error","start_line":155,"end_line":157,"code":"func (w TestingWriter) Sync() error {\n\n\treturn nil\n}\n","neighbors":[{"path":"zaptest/logger.go","start_line":135,"end_line":154,"code":"\treturn w\n}\n\n// Write writes bytes from p to the underlying testing.TB.\nfunc (w TestingWriter) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\n\t// Strip trailing newline because t.Log always adds one.\n\tp = bytes.TrimRight(p, \"\\n\")\n\n\t// Note: t.Log is safe for concurrent use.\n\tw.t.Logf(\"%s\", p)\n\tif w.markFailed {\n\t\tw.t.Fail()\n\t}\n\n\treturn n, nil\n}\n\n// Sync commits the current contents (a no-op for TestingWriter)."}],"selection":{"visibility":"exported","reason":"other","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(*BufferedWriteSyncer).Sync","path":"zapcore/buffered_write_syncer.go"},{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*TestingWriter).Sync","path":"zaptest/logger.go"},{"symbol":"(*ioCore).Sync","path":"zapcore/core.go"},{"symbol":"(*lockedWriteSyncer).Sync","path":"zapcore/write_syncer.go"},{"symbol":"(multiWriteSyncer).Sync","path":"zapcore/write_syncer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/logged_entry.go","symbol":"(LoggedEntry).ContextMap","signature":"func (e LoggedEntry) ContextMap() map[string]interface{}","start_line":33,"end_line":39,"code":"func (e LoggedEntry) ContextMap() map[string]interface{\n} {\n\tencoder := zapcore.NewMapObjectEncoder()\n\tfor _, f := range e.Context {\n\t\tf.AddTo(encoder)\n\t}\n\treturn encoder.Fields\n}\n","neighbors":[{"path":"zaptest/observer/logged_entry.go","start_line":13,"end_line":32,"code":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage observer\n\nimport \"go.uber.org/zap/zapcore\"\n\n// A LoggedEntry is an encoding-agnostic representation of a log message.\n// Field availability is context dependent.\ntype LoggedEntry struct {\n\tzapcore.Entry\n\tContext []zapcore.Field\n}\n\n// ContextMap returns a map for all fields in Context."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(Field).AddTo","path":"zapcore/field.go"},{"symbol":"NewMapObjectEncoder","path":"zapcore/memory_encoder.go"}],"callers":[{"symbol":"(*LoggedEntry).ContextMap","path":"zaptest/observer/logged_entry.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).Len","signature":"func (o *ObservedLogs) Len() int","start_line":43,"end_line":48,"code":"func (o *ObservedLogs) Len() int {\n\n\to.mu.RLock()\n\tn := len(o.logs)\n\to.mu.RUnlock()\n\treturn n\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":23,"end_line":42,"code":"// applications that want to unit test their log output without tying their\n// tests to a particular output encoding.\npackage observer // import \"go.uber.org/zap/zaptest/observer\"\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap/internal\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// ObservedLogs is a concurrency-safe, ordered collection of observed logs.\ntype ObservedLogs struct {\n\tmu   sync.RWMutex\n\tlogs []LoggedEntry\n}\n\n// Len returns the number of items in the collection."},{"path":"zaptest/observer/observer.go","start_line":49,"end_line":68,"code":"\n// All returns a copy of all the observed logs.\nfunc (o *ObservedLogs) All() []LoggedEntry {\n\to.mu.RLock()\n\tret := make([]LoggedEntry, len(o.logs))\n\tcopy(ret, o.logs)\n\to.mu.RUnlock()\n\treturn ret\n}\n\n// TakeAll returns a copy of all the observed logs, and truncates the observed\n// slice.\nfunc (o *ObservedLogs) TakeAll() []LoggedEntry {\n\to.mu.Lock()\n\tret := o.logs\n\to.logs = nil\n\to.mu.Unlock()\n\treturn ret\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).All","signature":"func (o *ObservedLogs) All() []LoggedEntry","start_line":51,"end_line":57,"code":"func (o *ObservedLogs) All() []LoggedEntry {\n\n\to.mu.RLock()\n\tret := make([]LoggedEntry, len(o.logs))\n\tcopy(ret, o.logs)\n\to.mu.RUnlock()\n\treturn ret\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":31,"end_line":50,"code":"\n\t\"go.uber.org/zap/internal\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// ObservedLogs is a concurrency-safe, ordered collection of observed logs.\ntype ObservedLogs struct {\n\tmu   sync.RWMutex\n\tlogs []LoggedEntry\n}\n\n// Len returns the number of items in the collection.\nfunc (o *ObservedLogs) Len() int {\n\to.mu.RLock()\n\tn := len(o.logs)\n\to.mu.RUnlock()\n\treturn n\n}\n\n// All returns a copy of all the observed logs."},{"path":"zaptest/observer/observer.go","start_line":58,"end_line":77,"code":"\n// TakeAll returns a copy of all the observed logs, and truncates the observed\n// slice.\nfunc (o *ObservedLogs) TakeAll() []LoggedEntry {\n\to.mu.Lock()\n\tret := o.logs\n\to.logs = nil\n\to.mu.Unlock()\n\treturn ret\n}\n\n// AllUntimed returns a copy of all the observed logs, but overwrites the\n// observed timestamps with time.Time's zero value. This is useful when making\n// assertions in tests.\nfunc (o *ObservedLogs) AllUntimed() []LoggedEntry {\n\tret := o.All()\n\tfor i := range ret {\n\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":[{"symbol":"(*ObservedLogs).AllUntimed","path":"zaptest/observer/observer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).TakeAll","signature":"func (o *ObservedLogs) TakeAll() []LoggedEntry","start_line":61,"end_line":67,"code":"func (o *ObservedLogs) TakeAll() []LoggedEntry {\n\n\to.mu.Lock()\n\tret := o.logs\n\to.logs = nil\n\to.mu.Unlock()\n\treturn ret\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":41,"end_line":60,"code":"\n// Len returns the number of items in the collection.\nfunc (o *ObservedLogs) Len() int {\n\to.mu.RLock()\n\tn := len(o.logs)\n\to.mu.RUnlock()\n\treturn n\n}\n\n// All returns a copy of all the observed logs.\nfunc (o *ObservedLogs) All() []LoggedEntry {\n\to.mu.RLock()\n\tret := make([]LoggedEntry, len(o.logs))\n\tcopy(ret, o.logs)\n\to.mu.RUnlock()\n\treturn ret\n}\n\n// TakeAll returns a copy of all the observed logs, and truncates the observed\n// slice."},{"path":"zaptest/observer/observer.go","start_line":68,"end_line":87,"code":"\n// AllUntimed returns a copy of all the observed logs, but overwrites the\n// observed timestamps with time.Time's zero value. This is useful when making\n// assertions in tests.\nfunc (o *ObservedLogs) AllUntimed() []LoggedEntry {\n\tret := o.All()\n\tfor i := range ret {\n\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret\n}\n\n// FilterLevelExact filters entries to those logged at exactly the given level.\nfunc (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n\n// FilterMessage filters entries to those that have the specified message."}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).AllUntimed","signature":"func (o *ObservedLogs) AllUntimed() []LoggedEntry","start_line":72,"end_line":78,"code":"func (o *ObservedLogs) AllUntimed() []LoggedEntry {\n\n\tret := o.All()\n\tfor i := range ret {\n\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":52,"end_line":71,"code":"\to.mu.RLock()\n\tret := make([]LoggedEntry, len(o.logs))\n\tcopy(ret, o.logs)\n\to.mu.RUnlock()\n\treturn ret\n}\n\n// TakeAll returns a copy of all the observed logs, and truncates the observed\n// slice.\nfunc (o *ObservedLogs) TakeAll() []LoggedEntry {\n\to.mu.Lock()\n\tret := o.logs\n\to.logs = nil\n\to.mu.Unlock()\n\treturn ret\n}\n\n// AllUntimed returns a copy of all the observed logs, but overwrites the\n// observed timestamps with time.Time's zero value. This is useful when making\n// assertions in tests."},{"path":"zaptest/observer/observer.go","start_line":79,"end_line":98,"code":"\n// FilterLevelExact filters entries to those logged at exactly the given level.\nfunc (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n\n// FilterMessage filters entries to those that have the specified message.\nfunc (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n\n// FilterLoggerName filters entries to those logged through logger with the specified logger name.\nfunc (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).All","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterLevelExact","signature":"func (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs","start_line":81,"end_line":85,"code":"func (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":61,"end_line":80,"code":"func (o *ObservedLogs) TakeAll() []LoggedEntry {\n\to.mu.Lock()\n\tret := o.logs\n\to.logs = nil\n\to.mu.Unlock()\n\treturn ret\n}\n\n// AllUntimed returns a copy of all the observed logs, but overwrites the\n// observed timestamps with time.Time's zero value. This is useful when making\n// assertions in tests.\nfunc (o *ObservedLogs) AllUntimed() []LoggedEntry {\n\tret := o.All()\n\tfor i := range ret {\n\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret\n}\n\n// FilterLevelExact filters entries to those logged at exactly the given level."},{"path":"zaptest/observer/observer.go","start_line":86,"end_line":105,"code":"\n// FilterMessage filters entries to those that have the specified message.\nfunc (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n\n// FilterLoggerName filters entries to those logged through logger with the specified logger name.\nfunc (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})\n}\n\n// FilterMessageSnippet filters entries to those that have a message containing the specified snippet.\nfunc (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterMessage","signature":"func (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs","start_line":88,"end_line":92,"code":"func (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":68,"end_line":87,"code":"\n// AllUntimed returns a copy of all the observed logs, but overwrites the\n// observed timestamps with time.Time's zero value. This is useful when making\n// assertions in tests.\nfunc (o *ObservedLogs) AllUntimed() []LoggedEntry {\n\tret := o.All()\n\tfor i := range ret {\n\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret\n}\n\n// FilterLevelExact filters entries to those logged at exactly the given level.\nfunc (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n\n// FilterMessage filters entries to those that have the specified message."},{"path":"zaptest/observer/observer.go","start_line":93,"end_line":112,"code":"\n// FilterLoggerName filters entries to those logged through logger with the specified logger name.\nfunc (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})\n}\n\n// FilterMessageSnippet filters entries to those that have a message containing the specified snippet.\nfunc (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})\n}\n\n// FilterField filters entries to those that have the specified field.\nfunc (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Equals(field) {"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterLoggerName","signature":"func (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs","start_line":95,"end_line":99,"code":"func (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":75,"end_line":94,"code":"\t\tret[i].Time = time.Time{}\n\t}\n\treturn ret\n}\n\n// FilterLevelExact filters entries to those logged at exactly the given level.\nfunc (o *ObservedLogs) FilterLevelExact(level zapcore.Level) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n\n// FilterMessage filters entries to those that have the specified message.\nfunc (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n\n// FilterLoggerName filters entries to those logged through logger with the specified logger name."},{"path":"zaptest/observer/observer.go","start_line":100,"end_line":119,"code":"\n// FilterMessageSnippet filters entries to those that have a message containing the specified snippet.\nfunc (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})\n}\n\n// FilterField filters entries to those that have the specified field.\nfunc (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Equals(field) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterMessageSnippet","signature":"func (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs","start_line":102,"end_line":106,"code":"func (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":82,"end_line":101,"code":"\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Level == level\n\t})\n}\n\n// FilterMessage filters entries to those that have the specified message.\nfunc (o *ObservedLogs) FilterMessage(msg string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n\n// FilterLoggerName filters entries to those logged through logger with the specified logger name.\nfunc (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})\n}\n\n// FilterMessageSnippet filters entries to those that have a message containing the specified snippet."},{"path":"zaptest/observer/observer.go","start_line":107,"end_line":126,"code":"\n// FilterField filters entries to those that have the specified field.\nfunc (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Equals(field) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// FilterFieldKey filters entries to those that have the specified key.\nfunc (o *ObservedLogs) FilterFieldKey(key string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Key == key {\n\t\t\t\treturn true\n\t\t\t}"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterField","signature":"func (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs","start_line":109,"end_line":118,"code":"func (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Equals(field) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":89,"end_line":108,"code":"\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.Message == msg\n\t})\n}\n\n// FilterLoggerName filters entries to those logged through logger with the specified logger name.\nfunc (o *ObservedLogs) FilterLoggerName(name string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn e.LoggerName == name\n\t})\n}\n\n// FilterMessageSnippet filters entries to those that have a message containing the specified snippet.\nfunc (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})\n}\n\n// FilterField filters entries to those that have the specified field."},{"path":"zaptest/observer/observer.go","start_line":119,"end_line":138,"code":"\n// FilterFieldKey filters entries to those that have the specified key.\nfunc (o *ObservedLogs) FilterFieldKey(key string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Key == key {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// Filter returns a copy of this ObservedLogs containing only those entries\n// for which the provided function returns true.\nfunc (o *ObservedLogs) Filter(keep func(LoggedEntry) bool) *ObservedLogs {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tvar filtered []LoggedEntry"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).FilterFieldKey","signature":"func (o *ObservedLogs) FilterFieldKey(key string) *ObservedLogs","start_line":121,"end_line":130,"code":"func (o *ObservedLogs) FilterFieldKey(key string) *ObservedLogs {\n\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Key == key {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":101,"end_line":120,"code":"// FilterMessageSnippet filters entries to those that have a message containing the specified snippet.\nfunc (o *ObservedLogs) FilterMessageSnippet(snippet string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\treturn strings.Contains(e.Message, snippet)\n\t})\n}\n\n// FilterField filters entries to those that have the specified field.\nfunc (o *ObservedLogs) FilterField(field zapcore.Field) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Equals(field) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// FilterFieldKey filters entries to those that have the specified key."},{"path":"zaptest/observer/observer.go","start_line":131,"end_line":150,"code":"\n// Filter returns a copy of this ObservedLogs containing only those entries\n// for which the provided function returns true.\nfunc (o *ObservedLogs) Filter(keep func(LoggedEntry) bool) *ObservedLogs {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tvar filtered []LoggedEntry\n\tfor _, entry := range o.logs {\n\t\tif keep(entry) {\n\t\t\tfiltered = append(filtered, entry)\n\t\t}\n\t}\n\treturn \u0026ObservedLogs{logs: filtered}\n}\n\nfunc (o *ObservedLogs) add(log LoggedEntry) {\n\to.mu.Lock()\n\to.logs = append(o.logs, log)\n\to.mu.Unlock()"}],"selection":{"visibility":"exported","reason":"other","score":0.7},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).Filter","path":"zaptest/observer/observer.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).Filter","signature":"func (o *ObservedLogs) Filter(keep func(LoggedEntry) bool) *ObservedLogs","start_line":134,"end_line":145,"code":"func (o *ObservedLogs) Filter(keep func(LoggedEntry) bool) *ObservedLogs {\n\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tvar filtered []LoggedEntry\n\tfor _, entry := range o.logs {\n\t\tif keep(entry) {\n\t\t\tfiltered = append(filtered, entry)\n\t\t}\n\t}\n\treturn \u0026ObservedLogs{logs: filtered}\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":114,"end_line":133,"code":"\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// FilterFieldKey filters entries to those that have the specified key.\nfunc (o *ObservedLogs) FilterFieldKey(key string) *ObservedLogs {\n\treturn o.Filter(func(e LoggedEntry) bool {\n\t\tfor _, ctxField := range e.Context {\n\t\t\tif ctxField.Key == key {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// Filter returns a copy of this ObservedLogs containing only those entries\n// for which the provided function returns true."},{"path":"zaptest/observer/observer.go","start_line":146,"end_line":165,"code":"\nfunc (o *ObservedLogs) add(log LoggedEntry) {\n\to.mu.Lock()\n\to.logs = append(o.logs, log)\n\to.mu.Unlock()\n}\n\n// New creates a new Core that buffers logs in memory (without any encoding).\n// It's particularly useful in tests.\nfunc New(enab zapcore.LevelEnabler) (zapcore.Core, *ObservedLogs) {\n\tol := \u0026ObservedLogs{}\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: enab,\n\t\tlogs:         ol,\n\t}, ol\n}\n\ntype contextObserver struct {\n\tzapcore.LevelEnabler\n\tlogs    *ObservedLogs"}],"selection":{"visibility":"exported","reason":"other","score":0.72},"call_graph":{"callees":[{"symbol":"(*RWMutex).RLock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).RUnlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"FilterField$1","path":"zaptest/observer/observer.go"},{"symbol":"FilterFieldKey$1","path":"zaptest/observer/observer.go"},{"symbol":"FilterLevelExact$1","path":"zaptest/observer/observer.go"},{"symbol":"FilterLoggerName$1","path":"zaptest/observer/observer.go"},{"symbol":"FilterMessage$1","path":"zaptest/observer/observer.go"},{"symbol":"FilterMessageSnippet$1","path":"zaptest/observer/observer.go"}],"callers":[{"symbol":"(*ObservedLogs).FilterField","path":"zaptest/observer/observer.go"},{"symbol":"(*ObservedLogs).FilterFieldKey","path":"zaptest/observer/observer.go"},{"symbol":"(*ObservedLogs).FilterLevelExact","path":"zaptest/observer/observer.go"},{"symbol":"(*ObservedLogs).FilterLoggerName","path":"zaptest/observer/observer.go"},{"symbol":"(*ObservedLogs).FilterMessage","path":"zaptest/observer/observer.go"},{"symbol":"(*ObservedLogs).FilterMessageSnippet","path":"zaptest/observer/observer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*ObservedLogs).add","signature":"func (o *ObservedLogs) add(log LoggedEntry)","start_line":147,"end_line":151,"code":"func (o *ObservedLogs) add(log LoggedEntry) {\n\n\to.mu.Lock()\n\to.logs = append(o.logs, log)\n\to.mu.Unlock()\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":127,"end_line":146,"code":"\t\t}\n\t\treturn false\n\t})\n}\n\n// Filter returns a copy of this ObservedLogs containing only those entries\n// for which the provided function returns true.\nfunc (o *ObservedLogs) Filter(keep func(LoggedEntry) bool) *ObservedLogs {\n\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tvar filtered []LoggedEntry\n\tfor _, entry := range o.logs {\n\t\tif keep(entry) {\n\t\t\tfiltered = append(filtered, entry)\n\t\t}\n\t}\n\treturn \u0026ObservedLogs{logs: filtered}\n}\n"},{"path":"zaptest/observer/observer.go","start_line":152,"end_line":171,"code":"\n// New creates a new Core that buffers logs in memory (without any encoding).\n// It's particularly useful in tests.\nfunc New(enab zapcore.LevelEnabler) (zapcore.Core, *ObservedLogs) {\n\tol := \u0026ObservedLogs{}\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: enab,\n\t\tlogs:         ol,\n\t}, ol\n}\n\ntype contextObserver struct {\n\tzapcore.LevelEnabler\n\tlogs    *ObservedLogs\n\tcontext []zapcore.Field\n}\n\nvar (\n\t_ zapcore.Core            = (*contextObserver)(nil)\n\t_ internal.LeveledEnabler = (*contextObserver)(nil)"}],"selection":{"visibility":"unexported","reason":"other","score":0.5},"call_graph":{"callees":[{"symbol":"(*RWMutex).Lock","path":"../../../../usr/local/go/src/sync/rwmutex.go"},{"symbol":"(*RWMutex).Unlock","path":"../../../../usr/local/go/src/sync/rwmutex.go"}],"callers":[{"symbol":"(*contextObserver).Write","path":"zaptest/observer/observer.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"New","signature":"func New(enab zapcore.LevelEnabler) (zapcore.Core, *ObservedLogs)","start_line":155,"end_line":161,"code":"func New(enab zapcore.LevelEnabler) (zapcore.Core, *ObservedLogs) {\n\n\tol := \u0026ObservedLogs{}\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: enab,\n\t\tlogs:         ol,\n\t}, ol\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":135,"end_line":154,"code":"\to.mu.RLock()\n\tdefer o.mu.RUnlock()\n\n\tvar filtered []LoggedEntry\n\tfor _, entry := range o.logs {\n\t\tif keep(entry) {\n\t\t\tfiltered = append(filtered, entry)\n\t\t}\n\t}\n\treturn \u0026ObservedLogs{logs: filtered}\n}\n\nfunc (o *ObservedLogs) add(log LoggedEntry) {\n\to.mu.Lock()\n\to.logs = append(o.logs, log)\n\to.mu.Unlock()\n}\n\n// New creates a new Core that buffers logs in memory (without any encoding).\n// It's particularly useful in tests."},{"path":"zaptest/observer/observer.go","start_line":162,"end_line":181,"code":"\ntype contextObserver struct {\n\tzapcore.LevelEnabler\n\tlogs    *ObservedLogs\n\tcontext []zapcore.Field\n}\n\nvar (\n\t_ zapcore.Core            = (*contextObserver)(nil)\n\t_ internal.LeveledEnabler = (*contextObserver)(nil)\n)\n\nfunc (co *contextObserver) Level() zapcore.Level {\n\treturn zapcore.LevelOf(co.LevelEnabler)\n}\n\nfunc (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif co.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, co)\n\t}"}],"selection":{"visibility":"exported","reason":"constructor","score":0.85},"call_graph":{"callees":null,"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*contextObserver).Level","signature":"func (co *contextObserver) Level() zapcore.Level","start_line":174,"end_line":176,"code":"func (co *contextObserver) Level() zapcore.Level {\n\n\treturn zapcore.LevelOf(co.LevelEnabler)\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":154,"end_line":173,"code":"// It's particularly useful in tests.\nfunc New(enab zapcore.LevelEnabler) (zapcore.Core, *ObservedLogs) {\n\tol := \u0026ObservedLogs{}\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: enab,\n\t\tlogs:         ol,\n\t}, ol\n}\n\ntype contextObserver struct {\n\tzapcore.LevelEnabler\n\tlogs    *ObservedLogs\n\tcontext []zapcore.Field\n}\n\nvar (\n\t_ zapcore.Core            = (*contextObserver)(nil)\n\t_ internal.LeveledEnabler = (*contextObserver)(nil)\n)\n"},{"path":"zaptest/observer/observer.go","start_line":177,"end_line":196,"code":"\nfunc (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif co.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, co)\n\t}\n\treturn ce\n}\n\nfunc (co *contextObserver) With(fields []zapcore.Field) zapcore.Core {\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: co.LevelEnabler,\n\t\tlogs:         co.logs,\n\t\tcontext:      append(co.context[:len(co.context):len(co.context)], fields...),\n\t}\n}\n\nfunc (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error {\n\tall := make([]zapcore.Field, 0, len(fields)+len(co.context))\n\tall = append(all, co.context...)\n\tall = append(all, fields...)"}],"selection":{"visibility":"exported","reason":"other","score":0.63},"call_graph":{"callees":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"callers":[{"symbol":"LevelOf","path":"zapcore/level.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*contextObserver).Check","signature":"func (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry","start_line":178,"end_line":183,"code":"func (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\n\tif co.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, co)\n\t}\n\treturn ce\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":158,"end_line":177,"code":"\t\tLevelEnabler: enab,\n\t\tlogs:         ol,\n\t}, ol\n}\n\ntype contextObserver struct {\n\tzapcore.LevelEnabler\n\tlogs    *ObservedLogs\n\tcontext []zapcore.Field\n}\n\nvar (\n\t_ zapcore.Core            = (*contextObserver)(nil)\n\t_ internal.LeveledEnabler = (*contextObserver)(nil)\n)\n\nfunc (co *contextObserver) Level() zapcore.Level {\n\treturn zapcore.LevelOf(co.LevelEnabler)\n}\n"},{"path":"zaptest/observer/observer.go","start_line":184,"end_line":203,"code":"\nfunc (co *contextObserver) With(fields []zapcore.Field) zapcore.Core {\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: co.LevelEnabler,\n\t\tlogs:         co.logs,\n\t\tcontext:      append(co.context[:len(co.context):len(co.context)], fields...),\n\t}\n}\n\nfunc (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error {\n\tall := make([]zapcore.Field, 0, len(fields)+len(co.context))\n\tall = append(all, co.context...)\n\tall = append(all, fields...)\n\tco.logs.add(LoggedEntry{ent, all})\n\treturn nil\n}\n\nfunc (co *contextObserver) Sync() error {\n\treturn nil\n}"}],"selection":{"visibility":"exported","reason":"other","score":0.74},"call_graph":{"callees":[{"symbol":"(*CheckedEntry).AddCore","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Enabled","path":"zapcore/increase_level.go"},{"symbol":"(AtomicLevel).Enabled","path":"level.go"},{"symbol":"(Level).Enabled","path":"zapcore/level.go"},{"symbol":"(LevelEnablerFunc).Enabled","path":"level.go"},{"symbol":"(multiCore).Enabled","path":"zapcore/tee.go"},{"symbol":"(nopCore).Enabled","path":"zapcore/core.go"}],"callers":[{"symbol":"(*Logger).check","path":"logger.go"},{"symbol":"(*hooked).Check","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).Check","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).Check","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).Check","path":"zapcore/sampler.go"},{"symbol":"(multiCore).Check","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*contextObserver).With","signature":"func (co *contextObserver) With(fields []zapcore.Field) zapcore.Core","start_line":185,"end_line":191,"code":"func (co *contextObserver) With(fields []zapcore.Field) zapcore.Core {\n\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: co.LevelEnabler,\n\t\tlogs:         co.logs,\n\t\tcontext:      append(co.context[:len(co.context):len(co.context)], fields...),\n\t}\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":165,"end_line":184,"code":"\tlogs    *ObservedLogs\n\tcontext []zapcore.Field\n}\n\nvar (\n\t_ zapcore.Core            = (*contextObserver)(nil)\n\t_ internal.LeveledEnabler = (*contextObserver)(nil)\n)\n\nfunc (co *contextObserver) Level() zapcore.Level {\n\treturn zapcore.LevelOf(co.LevelEnabler)\n}\n\nfunc (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif co.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, co)\n\t}\n\treturn ce\n}\n"},{"path":"zaptest/observer/observer.go","start_line":192,"end_line":204,"code":"\nfunc (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error {\n\tall := make([]zapcore.Field, 0, len(fields)+len(co.context))\n\tall = append(all, co.context...)\n\tall = append(all, fields...)\n\tco.logs.add(LoggedEntry{ent, all})\n\treturn nil\n}\n\nfunc (co *contextObserver) Sync() error {\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"public_api","score":0.89},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).With","path":"logger.go"},{"symbol":"(*hooked).With","path":"zapcore/hook.go"},{"symbol":"(*lazyWithCore).With","path":"zapcore/lazy_with.go"},{"symbol":"(*levelFilterCore).With","path":"zapcore/increase_level.go"},{"symbol":"(*sampler).With","path":"zapcore/sampler.go"},{"symbol":"(multiCore).With","path":"zapcore/tee.go"},{"symbol":"Fields$1","path":"options.go"},{"symbol":"initOnce$1","path":"zapcore/lazy_with.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*contextObserver).Write","signature":"func (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error","start_line":193,"end_line":199,"code":"func (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error {\n\n\tall := make([]zapcore.Field, 0, len(fields)+len(co.context))\n\tall = append(all, co.context...)\n\tall = append(all, fields...)\n\tco.logs.add(LoggedEntry{ent, all})\n\treturn nil\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":173,"end_line":192,"code":"\nfunc (co *contextObserver) Level() zapcore.Level {\n\treturn zapcore.LevelOf(co.LevelEnabler)\n}\n\nfunc (co *contextObserver) Check(ent zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif co.Enabled(ent.Level) {\n\t\treturn ce.AddCore(ent, co)\n\t}\n\treturn ce\n}\n\nfunc (co *contextObserver) With(fields []zapcore.Field) zapcore.Core {\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: co.LevelEnabler,\n\t\tlogs:         co.logs,\n\t\tcontext:      append(co.context[:len(co.context):len(co.context)], fields...),\n\t}\n}\n"},{"path":"zaptest/observer/observer.go","start_line":200,"end_line":204,"code":"\nfunc (co *contextObserver) Sync() error {\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.8},"call_graph":{"callees":[{"symbol":"(*ObservedLogs).add","path":"zaptest/observer/observer.go"}],"callers":[{"symbol":"(*CheckedEntry).Write","path":"zapcore/entry.go"},{"symbol":"(*levelFilterCore).Write","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Write","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/observer/observer.go","symbol":"(*contextObserver).Sync","signature":"func (co *contextObserver) Sync() error","start_line":201,"end_line":203,"code":"func (co *contextObserver) Sync() error {\n\n\treturn nil\n}\n","neighbors":[{"path":"zaptest/observer/observer.go","start_line":181,"end_line":200,"code":"\t}\n\treturn ce\n}\n\nfunc (co *contextObserver) With(fields []zapcore.Field) zapcore.Core {\n\treturn \u0026contextObserver{\n\t\tLevelEnabler: co.LevelEnabler,\n\t\tlogs:         co.logs,\n\t\tcontext:      append(co.context[:len(co.context):len(co.context)], fields...),\n\t}\n}\n\nfunc (co *contextObserver) Write(ent zapcore.Entry, fields []zapcore.Field) error {\n\tall := make([]zapcore.Field, 0, len(fields)+len(co.context))\n\tall = append(all, co.context...)\n\tall = append(all, fields...)\n\tco.logs.add(LoggedEntry{ent, all})\n\treturn nil\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.66},"call_graph":{"callees":null,"callers":[{"symbol":"(*Logger).Sync","path":"logger.go"},{"symbol":"(*levelFilterCore).Sync","path":"zapcore/increase_level.go"},{"symbol":"(multiCore).Sync","path":"zapcore/tee.go"}],"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/timeout.go","symbol":"Timeout","signature":"func Timeout(base time.Duration) time.Duration","start_line":34,"end_line":36,"code":"func Timeout(base time.Duration) time.Duration {\n\n\treturn ztest.Timeout(base)\n}\n","neighbors":[{"path":"zaptest/timeout.go","start_line":14,"end_line":33,"code":"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zaptest\n\nimport (\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/ztest\"\n)\n\n// Timeout scales the provided duration by $TEST_TIMEOUT_SCALE.\n//\n// Deprecated: This function is intended for internal testing and shouldn't be\n// used outside zap itself. It was introduced before Go supported internal\n// packages."},{"path":"zaptest/timeout.go","start_line":37,"end_line":46,"code":"\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE.\n//\n// Deprecated: This function is intended for internal testing and shouldn't be\n// used outside zap itself. It was introduced before Go supported internal\n// packages.\nfunc Sleep(base time.Duration) {\n\tztest.Sleep(base)\n}\n"}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"Timeout","path":"internal/ztest/timeout.go"}],"callers":null,"precision":"native"}}
{"repo":"uber-go/zap","commit":"07077a697f639389cc998ff91b8885feb25f520d","lang":"go","path":"zaptest/timeout.go","symbol":"Sleep","signature":"func Sleep(base time.Duration)","start_line":43,"end_line":45,"code":"func Sleep(base time.Duration) {\n\n\tztest.Sleep(base)\n}\n","neighbors":[{"path":"zaptest/timeout.go","start_line":23,"end_line":42,"code":"import (\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/ztest\"\n)\n\n// Timeout scales the provided duration by $TEST_TIMEOUT_SCALE.\n//\n// Deprecated: This function is intended for internal testing and shouldn't be\n// used outside zap itself. It was introduced before Go supported internal\n// packages.\nfunc Timeout(base time.Duration) time.Duration {\n\treturn ztest.Timeout(base)\n}\n\n// Sleep scales the sleep duration by $TEST_TIMEOUT_SCALE.\n//\n// Deprecated: This function is intended for internal testing and shouldn't be\n// used outside zap itself. It was introduced before Go supported internal\n// packages."}],"selection":{"visibility":"exported","reason":"other","score":0.61},"call_graph":{"callees":[{"symbol":"Sleep","path":"internal/ztest/timeout.go"}],"callers":null,"precision":"native"}}
